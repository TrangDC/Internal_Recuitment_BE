// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AttachmentQuery) CollectFields(ctx context.Context, satisfies ...string) (*AttachmentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AttachmentQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "candidateJobEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobQuery{config: a.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			a.withCandidateJobEdge = query
		case "candidateJobFeedbackEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobFeedbackQuery{config: a.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			a.withCandidateJobFeedbackEdge = query
		case "candidateInterviewEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateInterviewQuery{config: a.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			a.withCandidateInterviewEdge = query
		case "candidateEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateQuery{config: a.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			a.withCandidateEdge = query
		}
	}
	return nil
}

type attachmentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AttachmentPaginateOption
}

func newAttachmentPaginateArgs(rv map[string]interface{}) *attachmentPaginateArgs {
	args := &attachmentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &AttachmentOrder{Field: &AttachmentOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithAttachmentOrder(order))
			}
		case *AttachmentOrder:
			if v != nil {
				args.opts = append(args.opts, WithAttachmentOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (at *AuditTrailQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuditTrailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return at, nil
	}
	if err := at.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return at, nil
}

func (at *AuditTrailQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "userEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: at.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			at.withUserEdge = query
		}
	}
	return nil
}

type audittrailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuditTrailPaginateOption
}

func newAuditTrailPaginateArgs(rv map[string]interface{}) *audittrailPaginateArgs {
	args := &audittrailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &AuditTrailOrder{Field: &AuditTrailOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithAuditTrailOrder(order))
			}
		case *AuditTrailOrder:
			if v != nil {
				args.opts = append(args.opts, WithAuditTrailOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CandidateQuery) CollectFields(ctx context.Context, satisfies ...string) (*CandidateQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CandidateQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "candidateJobEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobQuery{config: c.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedCandidateJobEdges(alias, func(wq *CandidateJobQuery) {
				*wq = *query
			})
		case "referenceUserEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: c.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			c.withReferenceUserEdge = query
		case "attachmentEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &AttachmentQuery{config: c.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedAttachmentEdges(alias, func(wq *AttachmentQuery) {
				*wq = *query
			})
		case "candidateSkillEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EntitySkillQuery{config: c.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedCandidateSkillEdges(alias, func(wq *EntitySkillQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type candidatePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CandidatePaginateOption
}

func newCandidatePaginateArgs(rv map[string]interface{}) *candidatePaginateArgs {
	args := &candidatePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &CandidateOrder{Field: &CandidateOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCandidateOrder(order))
			}
		case *CandidateOrder:
			if v != nil {
				args.opts = append(args.opts, WithCandidateOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ci *CandidateInterviewQuery) CollectFields(ctx context.Context, satisfies ...string) (*CandidateInterviewQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ci, nil
	}
	if err := ci.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ci, nil
}

func (ci *CandidateInterviewQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "candidateJobEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobQuery{config: ci.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ci.withCandidateJobEdge = query
		case "attachmentEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &AttachmentQuery{config: ci.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ci.WithNamedAttachmentEdges(alias, func(wq *AttachmentQuery) {
				*wq = *query
			})
		case "interviewerEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ci.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ci.WithNamedInterviewerEdges(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "createdByEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ci.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ci.withCreatedByEdge = query
		case "userInterviewers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateInterviewerQuery{config: ci.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ci.WithNamedUserInterviewers(alias, func(wq *CandidateInterviewerQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type candidateinterviewPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CandidateInterviewPaginateOption
}

func newCandidateInterviewPaginateArgs(rv map[string]interface{}) *candidateinterviewPaginateArgs {
	args := &candidateinterviewPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &CandidateInterviewOrder{Field: &CandidateInterviewOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCandidateInterviewOrder(order))
			}
		case *CandidateInterviewOrder:
			if v != nil {
				args.opts = append(args.opts, WithCandidateInterviewOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ci *CandidateInterviewerQuery) CollectFields(ctx context.Context, satisfies ...string) (*CandidateInterviewerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ci, nil
	}
	if err := ci.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ci, nil
}

func (ci *CandidateInterviewerQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "userEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ci.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ci.withUserEdge = query
		case "interviewEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateInterviewQuery{config: ci.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ci.withInterviewEdge = query
		}
	}
	return nil
}

type candidateinterviewerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CandidateInterviewerPaginateOption
}

func newCandidateInterviewerPaginateArgs(rv map[string]interface{}) *candidateinterviewerPaginateArgs {
	args := &candidateinterviewerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &CandidateInterviewerOrder{Field: &CandidateInterviewerOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCandidateInterviewerOrder(order))
			}
		case *CandidateInterviewerOrder:
			if v != nil {
				args.opts = append(args.opts, WithCandidateInterviewerOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cj *CandidateJobQuery) CollectFields(ctx context.Context, satisfies ...string) (*CandidateJobQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cj, nil
	}
	if err := cj.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cj, nil
}

func (cj *CandidateJobQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "attachmentEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &AttachmentQuery{config: cj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cj.WithNamedAttachmentEdges(alias, func(wq *AttachmentQuery) {
				*wq = *query
			})
		case "hiringJobEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringJobQuery{config: cj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cj.withHiringJobEdge = query
		case "candidateJobFeedback":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobFeedbackQuery{config: cj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cj.WithNamedCandidateJobFeedback(alias, func(wq *CandidateJobFeedbackQuery) {
				*wq = *query
			})
		case "candidateEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateQuery{config: cj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cj.withCandidateEdge = query
		case "candidateJobInterview":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateInterviewQuery{config: cj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cj.WithNamedCandidateJobInterview(alias, func(wq *CandidateInterviewQuery) {
				*wq = *query
			})
		case "createdByEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: cj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cj.withCreatedByEdge = query
		case "candidateJobStep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobStepQuery{config: cj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cj.WithNamedCandidateJobStep(alias, func(wq *CandidateJobStepQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type candidatejobPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CandidateJobPaginateOption
}

func newCandidateJobPaginateArgs(rv map[string]interface{}) *candidatejobPaginateArgs {
	args := &candidatejobPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &CandidateJobOrder{Field: &CandidateJobOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCandidateJobOrder(order))
			}
		case *CandidateJobOrder:
			if v != nil {
				args.opts = append(args.opts, WithCandidateJobOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cjf *CandidateJobFeedbackQuery) CollectFields(ctx context.Context, satisfies ...string) (*CandidateJobFeedbackQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cjf, nil
	}
	if err := cjf.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cjf, nil
}

func (cjf *CandidateJobFeedbackQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "createdByEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: cjf.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cjf.withCreatedByEdge = query
		case "candidateJobEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobQuery{config: cjf.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cjf.withCandidateJobEdge = query
		case "attachmentEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &AttachmentQuery{config: cjf.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cjf.WithNamedAttachmentEdges(alias, func(wq *AttachmentQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type candidatejobfeedbackPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CandidateJobFeedbackPaginateOption
}

func newCandidateJobFeedbackPaginateArgs(rv map[string]interface{}) *candidatejobfeedbackPaginateArgs {
	args := &candidatejobfeedbackPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &CandidateJobFeedbackOrder{Field: &CandidateJobFeedbackOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCandidateJobFeedbackOrder(order))
			}
		case *CandidateJobFeedbackOrder:
			if v != nil {
				args.opts = append(args.opts, WithCandidateJobFeedbackOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cjs *CandidateJobStepQuery) CollectFields(ctx context.Context, satisfies ...string) (*CandidateJobStepQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cjs, nil
	}
	if err := cjs.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cjs, nil
}

func (cjs *CandidateJobStepQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "candidateJobEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobQuery{config: cjs.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			cjs.withCandidateJobEdge = query
		}
	}
	return nil
}

type candidatejobstepPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CandidateJobStepPaginateOption
}

func newCandidateJobStepPaginateArgs(rv map[string]interface{}) *candidatejobstepPaginateArgs {
	args := &candidatejobstepPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &CandidateJobStepOrder{Field: &CandidateJobStepOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithCandidateJobStepOrder(order))
			}
		case *CandidateJobStepOrder:
			if v != nil {
				args.opts = append(args.opts, WithCandidateJobStepOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (era *EmailRoleAttributeQuery) CollectFields(ctx context.Context, satisfies ...string) (*EmailRoleAttributeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return era, nil
	}
	if err := era.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return era, nil
}

func (era *EmailRoleAttributeQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "emailTemplateEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EmailTemplateQuery{config: era.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			era.withEmailTemplateEdge = query
		case "roleEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &RoleQuery{config: era.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			era.withRoleEdge = query
		}
	}
	return nil
}

type emailroleattributePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EmailRoleAttributePaginateOption
}

func newEmailRoleAttributePaginateArgs(rv map[string]interface{}) *emailroleattributePaginateArgs {
	args := &emailroleattributePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &EmailRoleAttributeOrder{Field: &EmailRoleAttributeOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEmailRoleAttributeOrder(order))
			}
		case *EmailRoleAttributeOrder:
			if v != nil {
				args.opts = append(args.opts, WithEmailRoleAttributeOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (et *EmailTemplateQuery) CollectFields(ctx context.Context, satisfies ...string) (*EmailTemplateQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return et, nil
	}
	if err := et.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return et, nil
}

func (et *EmailTemplateQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "roleEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &RoleQuery{config: et.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			et.WithNamedRoleEdges(alias, func(wq *RoleQuery) {
				*wq = *query
			})
		case "roleEmailTemplates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EmailRoleAttributeQuery{config: et.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			et.WithNamedRoleEmailTemplates(alias, func(wq *EmailRoleAttributeQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type emailtemplatePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EmailTemplatePaginateOption
}

func newEmailTemplatePaginateArgs(rv map[string]interface{}) *emailtemplatePaginateArgs {
	args := &emailtemplatePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &EmailTemplateOrder{Field: &EmailTemplateOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEmailTemplateOrder(order))
			}
		case *EmailTemplateOrder:
			if v != nil {
				args.opts = append(args.opts, WithEmailTemplateOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ep *EntityPermissionQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntityPermissionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ep, nil
	}
	if err := ep.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ep, nil
}

func (ep *EntityPermissionQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "permissionEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &PermissionQuery{config: ep.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ep.withPermissionEdges = query
		case "userEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ep.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ep.withUserEdge = query
		case "roleEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &RoleQuery{config: ep.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ep.withRoleEdge = query
		}
	}
	return nil
}

type entitypermissionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntityPermissionPaginateOption
}

func newEntityPermissionPaginateArgs(rv map[string]interface{}) *entitypermissionPaginateArgs {
	args := &entitypermissionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &EntityPermissionOrder{Field: &EntityPermissionOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntityPermissionOrder(order))
			}
		case *EntityPermissionOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntityPermissionOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (es *EntitySkillQuery) CollectFields(ctx context.Context, satisfies ...string) (*EntitySkillQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return es, nil
	}
	if err := es.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return es, nil
}

func (es *EntitySkillQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "skillEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &SkillQuery{config: es.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			es.withSkillEdge = query
		case "hiringJobEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringJobQuery{config: es.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			es.withHiringJobEdge = query
		case "candidateEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateQuery{config: es.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			es.withCandidateEdge = query
		}
	}
	return nil
}

type entityskillPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EntitySkillPaginateOption
}

func newEntitySkillPaginateArgs(rv map[string]interface{}) *entityskillPaginateArgs {
	args := &entityskillPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &EntitySkillOrder{Field: &EntitySkillOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEntitySkillOrder(order))
			}
		case *EntitySkillOrder:
			if v != nil {
				args.opts = append(args.opts, WithEntitySkillOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hj *HiringJobQuery) CollectFields(ctx context.Context, satisfies ...string) (*HiringJobQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hj, nil
	}
	if err := hj.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hj, nil
}

func (hj *HiringJobQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "ownerEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: hj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			hj.withOwnerEdge = query
		case "candidateJobEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobQuery{config: hj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			hj.WithNamedCandidateJobEdges(alias, func(wq *CandidateJobQuery) {
				*wq = *query
			})
		case "hiringJobSkillEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EntitySkillQuery{config: hj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			hj.WithNamedHiringJobSkillEdges(alias, func(wq *EntitySkillQuery) {
				*wq = *query
			})
		case "hiringTeamEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamQuery{config: hj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			hj.withHiringTeamEdge = query
		case "jobPositionEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &JobPositionQuery{config: hj.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			hj.withJobPositionEdge = query
		}
	}
	return nil
}

type hiringjobPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HiringJobPaginateOption
}

func newHiringJobPaginateArgs(rv map[string]interface{}) *hiringjobPaginateArgs {
	args := &hiringjobPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HiringJobOrder{Field: &HiringJobOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHiringJobOrder(order))
			}
		case *HiringJobOrder:
			if v != nil {
				args.opts = append(args.opts, WithHiringJobOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ht *HiringTeamQuery) CollectFields(ctx context.Context, satisfies ...string) (*HiringTeamQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ht, nil
	}
	if err := ht.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ht, nil
}

func (ht *HiringTeamQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "hiringTeamJobEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringJobQuery{config: ht.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ht.WithNamedHiringTeamJobEdges(alias, func(wq *HiringJobQuery) {
				*wq = *query
			})
		case "hiringMemberEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ht.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ht.WithNamedHiringMemberEdges(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "approversUsers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ht.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ht.WithNamedApproversUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "userEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ht.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ht.WithNamedUserEdges(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "hiringTeamApprovers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamApproverQuery{config: ht.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ht.WithNamedHiringTeamApprovers(alias, func(wq *HiringTeamApproverQuery) {
				*wq = *query
			})
		case "userHiringTeams":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamManagerQuery{config: ht.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ht.WithNamedUserHiringTeams(alias, func(wq *HiringTeamManagerQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type hiringteamPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HiringTeamPaginateOption
}

func newHiringTeamPaginateArgs(rv map[string]interface{}) *hiringteamPaginateArgs {
	args := &hiringteamPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HiringTeamOrder{Field: &HiringTeamOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHiringTeamOrder(order))
			}
		case *HiringTeamOrder:
			if v != nil {
				args.opts = append(args.opts, WithHiringTeamOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hta *HiringTeamApproverQuery) CollectFields(ctx context.Context, satisfies ...string) (*HiringTeamApproverQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hta, nil
	}
	if err := hta.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hta, nil
}

func (hta *HiringTeamApproverQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: hta.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			hta.withUser = query
		case "hiringTeam":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamQuery{config: hta.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			hta.withHiringTeam = query
		}
	}
	return nil
}

type hiringteamapproverPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HiringTeamApproverPaginateOption
}

func newHiringTeamApproverPaginateArgs(rv map[string]interface{}) *hiringteamapproverPaginateArgs {
	args := &hiringteamapproverPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HiringTeamApproverOrder{Field: &HiringTeamApproverOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHiringTeamApproverOrder(order))
			}
		case *HiringTeamApproverOrder:
			if v != nil {
				args.opts = append(args.opts, WithHiringTeamApproverOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (htm *HiringTeamManagerQuery) CollectFields(ctx context.Context, satisfies ...string) (*HiringTeamManagerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return htm, nil
	}
	if err := htm.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return htm, nil
}

func (htm *HiringTeamManagerQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "userEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: htm.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			htm.withUserEdge = query
		case "hiringTeamEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamQuery{config: htm.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			htm.withHiringTeamEdge = query
		}
	}
	return nil
}

type hiringteammanagerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HiringTeamManagerPaginateOption
}

func newHiringTeamManagerPaginateArgs(rv map[string]interface{}) *hiringteammanagerPaginateArgs {
	args := &hiringteammanagerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &HiringTeamManagerOrder{Field: &HiringTeamManagerOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHiringTeamManagerOrder(order))
			}
		case *HiringTeamManagerOrder:
			if v != nil {
				args.opts = append(args.opts, WithHiringTeamManagerOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jp *JobPositionQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobPositionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jp, nil
	}
	if err := jp.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jp, nil
}

func (jp *JobPositionQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "hiringJobPositionEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringJobQuery{config: jp.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			jp.WithNamedHiringJobPositionEdges(alias, func(wq *HiringJobQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type jobpositionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobPositionPaginateOption
}

func newJobPositionPaginateArgs(rv map[string]interface{}) *jobpositionPaginateArgs {
	args := &jobpositionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &JobPositionOrder{Field: &JobPositionOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJobPositionOrder(order))
			}
		case *JobPositionOrder:
			if v != nil {
				args.opts = append(args.opts, WithJobPositionOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oe *OutgoingEmailQuery) CollectFields(ctx context.Context, satisfies ...string) (*OutgoingEmailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oe, nil
	}
	if err := oe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oe, nil
}

func (oe *OutgoingEmailQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	return nil
}

type outgoingemailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OutgoingEmailPaginateOption
}

func newOutgoingEmailPaginateArgs(rv map[string]interface{}) *outgoingemailPaginateArgs {
	args := &outgoingemailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &OutgoingEmailOrder{Field: &OutgoingEmailOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOutgoingEmailOrder(order))
			}
		case *OutgoingEmailOrder:
			if v != nil {
				args.opts = append(args.opts, WithOutgoingEmailOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pe *PermissionQuery) CollectFields(ctx context.Context, satisfies ...string) (*PermissionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pe, nil
	}
	if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pe, nil
}

func (pe *PermissionQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "groupPermissionEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &PermissionGroupQuery{config: pe.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			pe.withGroupPermissionEdge = query
		case "userPermissionEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EntityPermissionQuery{config: pe.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			pe.WithNamedUserPermissionEdge(alias, func(wq *EntityPermissionQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type permissionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PermissionPaginateOption
}

func newPermissionPaginateArgs(rv map[string]interface{}) *permissionPaginateArgs {
	args := &permissionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &PermissionOrder{Field: &PermissionOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPermissionOrder(order))
			}
		case *PermissionOrder:
			if v != nil {
				args.opts = append(args.opts, WithPermissionOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pg *PermissionGroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*PermissionGroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pg, nil
	}
	if err := pg.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pg, nil
}

func (pg *PermissionGroupQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "groupPermissionParent":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &PermissionGroupQuery{config: pg.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			pg.withGroupPermissionParent = query
		case "groupPermissionChildren":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &PermissionGroupQuery{config: pg.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			pg.WithNamedGroupPermissionChildren(alias, func(wq *PermissionGroupQuery) {
				*wq = *query
			})
		case "permissionEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &PermissionQuery{config: pg.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			pg.WithNamedPermissionEdges(alias, func(wq *PermissionQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type permissiongroupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PermissionGroupPaginateOption
}

func newPermissionGroupPaginateArgs(rv map[string]interface{}) *permissiongroupPaginateArgs {
	args := &permissiongroupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &PermissionGroupOrder{Field: &PermissionGroupOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPermissionGroupOrder(order))
			}
		case *PermissionGroupOrder:
			if v != nil {
				args.opts = append(args.opts, WithPermissionGroupOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rt *RecTeamQuery) CollectFields(ctx context.Context, satisfies ...string) (*RecTeamQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rt, nil
	}
	if err := rt.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rt, nil
}

func (rt *RecTeamQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "recMemberEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: rt.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			rt.WithNamedRecMemberEdges(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "recLeaderEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: rt.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			rt.withRecLeaderEdge = query
		}
	}
	return nil
}

type recteamPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RecTeamPaginateOption
}

func newRecTeamPaginateArgs(rv map[string]interface{}) *recteamPaginateArgs {
	args := &recteamPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &RecTeamOrder{Field: &RecTeamOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithRecTeamOrder(order))
			}
		case *RecTeamOrder:
			if v != nil {
				args.opts = append(args.opts, WithRecTeamOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RoleQuery) CollectFields(ctx context.Context, satisfies ...string) (*RoleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if err := r.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return r, nil
}

func (r *RoleQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "rolePermissionEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EntityPermissionQuery{config: r.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedRolePermissionEdges(alias, func(wq *EntityPermissionQuery) {
				*wq = *query
			})
		case "userEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: r.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedUserEdges(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "emailTemplateEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EmailTemplateQuery{config: r.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedEmailTemplateEdges(alias, func(wq *EmailTemplateQuery) {
				*wq = *query
			})
		case "userRoles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserRoleQuery{config: r.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedUserRoles(alias, func(wq *UserRoleQuery) {
				*wq = *query
			})
		case "emailTemplateRoles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EmailRoleAttributeQuery{config: r.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedEmailTemplateRoles(alias, func(wq *EmailRoleAttributeQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type rolePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RolePaginateOption
}

func newRolePaginateArgs(rv map[string]interface{}) *rolePaginateArgs {
	args := &rolePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &RoleOrder{Field: &RoleOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithRoleOrder(order))
			}
		case *RoleOrder:
			if v != nil {
				args.opts = append(args.opts, WithRoleOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SkillQuery) CollectFields(ctx context.Context, satisfies ...string) (*SkillQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SkillQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "skillTypeEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &SkillTypeQuery{config: s.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			s.withSkillTypeEdge = query
		case "entitySkillEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EntitySkillQuery{config: s.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedEntitySkillEdges(alias, func(wq *EntitySkillQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type skillPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SkillPaginateOption
}

func newSkillPaginateArgs(rv map[string]interface{}) *skillPaginateArgs {
	args := &skillPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &SkillOrder{Field: &SkillOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithSkillOrder(order))
			}
		case *SkillOrder:
			if v != nil {
				args.opts = append(args.opts, WithSkillOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (st *SkillTypeQuery) CollectFields(ctx context.Context, satisfies ...string) (*SkillTypeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return st, nil
	}
	if err := st.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return st, nil
}

func (st *SkillTypeQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "skillEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &SkillQuery{config: st.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			st.WithNamedSkillEdges(alias, func(wq *SkillQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type skilltypePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SkillTypePaginateOption
}

func newSkillTypePaginateArgs(rv map[string]interface{}) *skilltypePaginateArgs {
	args := &skilltypePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &SkillTypeOrder{Field: &SkillTypeOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithSkillTypeOrder(order))
			}
		case *SkillTypeOrder:
			if v != nil {
				args.opts = append(args.opts, WithSkillTypeOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "auditEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &AuditTrailQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedAuditEdge(alias, func(wq *AuditTrailQuery) {
				*wq = *query
			})
		case "hiringOwner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringJobQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHiringOwner(alias, func(wq *HiringJobQuery) {
				*wq = *query
			})
		case "candidateJobFeedback":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobFeedbackQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCandidateJobFeedback(alias, func(wq *CandidateJobFeedbackQuery) {
				*wq = *query
			})
		case "interviewEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateInterviewQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedInterviewEdges(alias, func(wq *CandidateInterviewQuery) {
				*wq = *query
			})
		case "candidateJobEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateJobQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCandidateJobEdges(alias, func(wq *CandidateJobQuery) {
				*wq = *query
			})
		case "candidateInterviewEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateInterviewQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCandidateInterviewEdges(alias, func(wq *CandidateInterviewQuery) {
				*wq = *query
			})
		case "candidateReferenceEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCandidateReferenceEdges(alias, func(wq *CandidateQuery) {
				*wq = *query
			})
		case "userPermissionEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &EntityPermissionQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedUserPermissionEdges(alias, func(wq *EntityPermissionQuery) {
				*wq = *query
			})
		case "roleEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &RoleQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedRoleEdges(alias, func(wq *RoleQuery) {
				*wq = *query
			})
		case "hiringTeamEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHiringTeamEdges(alias, func(wq *HiringTeamQuery) {
				*wq = *query
			})
		case "memberOfHiringTeamEdges":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.withMemberOfHiringTeamEdges = query
		case "approversHiringTeams":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedApproversHiringTeams(alias, func(wq *HiringTeamQuery) {
				*wq = *query
			})
		case "leaderRecEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &RecTeamQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.withLeaderRecEdge = query
		case "recTeams":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &RecTeamQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.withRecTeams = query
		case "interviewUsers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &CandidateInterviewerQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedInterviewUsers(alias, func(wq *CandidateInterviewerQuery) {
				*wq = *query
			})
		case "roleUsers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserRoleQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedRoleUsers(alias, func(wq *UserRoleQuery) {
				*wq = *query
			})
		case "hiringTeamUsers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamManagerQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHiringTeamUsers(alias, func(wq *HiringTeamManagerQuery) {
				*wq = *query
			})
		case "hiringTeamApprovers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &HiringTeamApproverQuery{config: u.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedHiringTeamApprovers(alias, func(wq *HiringTeamApproverQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]interface{}) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ur *UserRoleQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserRoleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ur, nil
	}
	if err := ur.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ur, nil
}

func (ur *UserRoleQuery) collectField(ctx context.Context, op *graphql.OperationContext, field graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(op, field.Selections, satisfies) {
		switch field.Name {
		case "userEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &UserQuery{config: ur.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ur.withUserEdge = query
		case "roleEdge":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = &RoleQuery{config: ur.config}
			)
			if err := query.collectField(ctx, op, field, path, satisfies...); err != nil {
				return err
			}
			ur.withRoleEdge = query
		}
	}
	return nil
}

type userrolePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserRolePaginateOption
}

func newUserRolePaginateArgs(rv map[string]interface{}) *userrolePaginateArgs {
	args := &userrolePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]interface{}:
			var (
				err1, err2 error
				order      = &UserRoleOrder{Field: &UserRoleOrderField{}}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserRoleOrder(order))
			}
		case *UserRoleOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserRoleOrder(v))
			}
		}
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput interface{}, path ...string) map[string]interface{} {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	for _, name := range path {
		var field *graphql.CollectedField
		for _, f := range graphql.CollectFields(oc, fc.Field.Selections, nil) {
			if f.Alias == name {
				field = &f
				break
			}
		}
		if field == nil {
			return nil
		}
		cf, err := fc.Child(ctx, *field)
		if err != nil {
			args := field.ArgumentMap(oc.Variables)
			return unmarshalArgs(ctx, whereInput, args)
		}
		fc = cf
	}
	return fc.Args
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput interface{}, args map[string]interface{}) map[string]interface{} {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}
