// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"
	"trec/ent/attachment"
	"trec/ent/audittrail"
	"trec/ent/candidate"
	"trec/ent/candidateaward"
	"trec/ent/candidatecertificate"
	"trec/ent/candidateeducate"
	"trec/ent/candidateexp"
	"trec/ent/candidateinterview"
	"trec/ent/candidateinterviewer"
	"trec/ent/candidatejob"
	"trec/ent/candidatejobfeedback"
	"trec/ent/candidatejobstep"
	"trec/ent/emailroleattribute"
	"trec/ent/emailtemplate"
	"trec/ent/entitypermission"
	"trec/ent/entityskill"
	"trec/ent/hiringjob"
	"trec/ent/hiringteam"
	"trec/ent/hiringteamapprover"
	"trec/ent/hiringteammanager"
	"trec/ent/jobposition"
	"trec/ent/outgoingemail"
	"trec/ent/permission"
	"trec/ent/permissiongroup"
	"trec/ent/recteam"
	"trec/ent/role"
	"trec/ent/skill"
	"trec/ent/skilltype"
	"trec/ent/user"
	"trec/ent/userrole"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    uuid.UUID `msgpack:"i"`
	Value Value     `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AttachmentEdge is the edge representation of Attachment.
type AttachmentEdge struct {
	Node   *Attachment `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// AttachmentConnection is the connection containing edges to Attachment.
type AttachmentConnection struct {
	Edges      []*AttachmentEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *AttachmentConnection) build(nodes []*Attachment, pager *attachmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Attachment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Attachment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Attachment {
			return nodes[i]
		}
	}
	c.Edges = make([]*AttachmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AttachmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AttachmentPaginateOption enables pagination customization.
type AttachmentPaginateOption func(*attachmentPager) error

// WithAttachmentOrder configures pagination ordering.
func WithAttachmentOrder(order *AttachmentOrder) AttachmentPaginateOption {
	if order == nil {
		order = DefaultAttachmentOrder
	}
	o := *order
	return func(pager *attachmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAttachmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAttachmentFilter configures pagination filter.
func WithAttachmentFilter(filter func(*AttachmentQuery) (*AttachmentQuery, error)) AttachmentPaginateOption {
	return func(pager *attachmentPager) error {
		if filter == nil {
			return errors.New("AttachmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type attachmentPager struct {
	order  *AttachmentOrder
	filter func(*AttachmentQuery) (*AttachmentQuery, error)
}

func newAttachmentPager(opts []AttachmentPaginateOption) (*attachmentPager, error) {
	pager := &attachmentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAttachmentOrder
	}
	return pager, nil
}

func (p *attachmentPager) applyFilter(query *AttachmentQuery) (*AttachmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *attachmentPager) toCursor(a *Attachment) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *attachmentPager) applyCursors(query *AttachmentQuery, after, before *Cursor) *AttachmentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAttachmentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *attachmentPager) applyOrder(query *AttachmentQuery, reverse bool) *AttachmentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAttachmentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAttachmentOrder.Field.field))
	}
	return query
}

func (p *attachmentPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAttachmentOrder.Field {
			b.Comma().Ident(DefaultAttachmentOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Attachment.
func (a *AttachmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AttachmentPaginateOption,
) (*AttachmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAttachmentPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AttachmentConnection{Edges: []*AttachmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AttachmentOrderFieldCreatedAt orders Attachment by created_at.
	AttachmentOrderFieldCreatedAt = &AttachmentOrderField{
		field: attachment.FieldCreatedAt,
		toCursor: func(a *Attachment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.CreatedAt,
			}
		},
	}
	// AttachmentOrderFieldUpdatedAt orders Attachment by updated_at.
	AttachmentOrderFieldUpdatedAt = &AttachmentOrderField{
		field: attachment.FieldUpdatedAt,
		toCursor: func(a *Attachment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.UpdatedAt,
			}
		},
	}
	// AttachmentOrderFieldDeletedAt orders Attachment by deleted_at.
	AttachmentOrderFieldDeletedAt = &AttachmentOrderField{
		field: attachment.FieldDeletedAt,
		toCursor: func(a *Attachment) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AttachmentOrderField) String() string {
	var str string
	switch f.field {
	case attachment.FieldCreatedAt:
		str = "created_at"
	case attachment.FieldUpdatedAt:
		str = "updated_at"
	case attachment.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AttachmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AttachmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AttachmentOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AttachmentOrderFieldCreatedAt
	case "updated_at":
		*f = *AttachmentOrderFieldUpdatedAt
	case "deleted_at":
		*f = *AttachmentOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid AttachmentOrderField", str)
	}
	return nil
}

// AttachmentOrderField defines the ordering field of Attachment.
type AttachmentOrderField struct {
	field    string
	toCursor func(*Attachment) Cursor
}

// AttachmentOrder defines the ordering of Attachment.
type AttachmentOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *AttachmentOrderField `json:"field"`
}

// DefaultAttachmentOrder is the default ordering of Attachment.
var DefaultAttachmentOrder = &AttachmentOrder{
	Direction: OrderDirectionAsc,
	Field: &AttachmentOrderField{
		field: attachment.FieldID,
		toCursor: func(a *Attachment) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Attachment into AttachmentEdge.
func (a *Attachment) ToEdge(order *AttachmentOrder) *AttachmentEdge {
	if order == nil {
		order = DefaultAttachmentOrder
	}
	return &AttachmentEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AuditTrailEdge is the edge representation of AuditTrail.
type AuditTrailEdge struct {
	Node   *AuditTrail `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// AuditTrailConnection is the connection containing edges to AuditTrail.
type AuditTrailConnection struct {
	Edges      []*AuditTrailEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *AuditTrailConnection) build(nodes []*AuditTrail, pager *audittrailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuditTrail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuditTrail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuditTrail {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuditTrailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuditTrailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuditTrailPaginateOption enables pagination customization.
type AuditTrailPaginateOption func(*audittrailPager) error

// WithAuditTrailOrder configures pagination ordering.
func WithAuditTrailOrder(order *AuditTrailOrder) AuditTrailPaginateOption {
	if order == nil {
		order = DefaultAuditTrailOrder
	}
	o := *order
	return func(pager *audittrailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuditTrailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuditTrailFilter configures pagination filter.
func WithAuditTrailFilter(filter func(*AuditTrailQuery) (*AuditTrailQuery, error)) AuditTrailPaginateOption {
	return func(pager *audittrailPager) error {
		if filter == nil {
			return errors.New("AuditTrailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type audittrailPager struct {
	order  *AuditTrailOrder
	filter func(*AuditTrailQuery) (*AuditTrailQuery, error)
}

func newAuditTrailPager(opts []AuditTrailPaginateOption) (*audittrailPager, error) {
	pager := &audittrailPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuditTrailOrder
	}
	return pager, nil
}

func (p *audittrailPager) applyFilter(query *AuditTrailQuery) (*AuditTrailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *audittrailPager) toCursor(at *AuditTrail) Cursor {
	return p.order.Field.toCursor(at)
}

func (p *audittrailPager) applyCursors(query *AuditTrailQuery, after, before *Cursor) *AuditTrailQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAuditTrailOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *audittrailPager) applyOrder(query *AuditTrailQuery, reverse bool) *AuditTrailQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAuditTrailOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAuditTrailOrder.Field.field))
	}
	return query
}

func (p *audittrailPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAuditTrailOrder.Field {
			b.Comma().Ident(DefaultAuditTrailOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuditTrail.
func (at *AuditTrailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuditTrailPaginateOption,
) (*AuditTrailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuditTrailPager(opts)
	if err != nil {
		return nil, err
	}
	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}
	conn := &AuditTrailConnection{Edges: []*AuditTrailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = at.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	at = pager.applyCursors(at, after, before)
	at = pager.applyOrder(at, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		at.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := at.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := at.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuditTrailOrderFieldCreatedAt orders AuditTrail by created_at.
	AuditTrailOrderFieldCreatedAt = &AuditTrailOrderField{
		field: audittrail.FieldCreatedAt,
		toCursor: func(at *AuditTrail) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.CreatedAt,
			}
		},
	}
	// AuditTrailOrderFieldUpdatedAt orders AuditTrail by updated_at.
	AuditTrailOrderFieldUpdatedAt = &AuditTrailOrderField{
		field: audittrail.FieldUpdatedAt,
		toCursor: func(at *AuditTrail) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.UpdatedAt,
			}
		},
	}
	// AuditTrailOrderFieldDeletedAt orders AuditTrail by deleted_at.
	AuditTrailOrderFieldDeletedAt = &AuditTrailOrderField{
		field: audittrail.FieldDeletedAt,
		toCursor: func(at *AuditTrail) Cursor {
			return Cursor{
				ID:    at.ID,
				Value: at.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuditTrailOrderField) String() string {
	var str string
	switch f.field {
	case audittrail.FieldCreatedAt:
		str = "created_at"
	case audittrail.FieldUpdatedAt:
		str = "updated_at"
	case audittrail.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuditTrailOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuditTrailOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuditTrailOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *AuditTrailOrderFieldCreatedAt
	case "updated_at":
		*f = *AuditTrailOrderFieldUpdatedAt
	case "deleted_at":
		*f = *AuditTrailOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid AuditTrailOrderField", str)
	}
	return nil
}

// AuditTrailOrderField defines the ordering field of AuditTrail.
type AuditTrailOrderField struct {
	field    string
	toCursor func(*AuditTrail) Cursor
}

// AuditTrailOrder defines the ordering of AuditTrail.
type AuditTrailOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *AuditTrailOrderField `json:"field"`
}

// DefaultAuditTrailOrder is the default ordering of AuditTrail.
var DefaultAuditTrailOrder = &AuditTrailOrder{
	Direction: OrderDirectionAsc,
	Field: &AuditTrailOrderField{
		field: audittrail.FieldID,
		toCursor: func(at *AuditTrail) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts AuditTrail into AuditTrailEdge.
func (at *AuditTrail) ToEdge(order *AuditTrailOrder) *AuditTrailEdge {
	if order == nil {
		order = DefaultAuditTrailOrder
	}
	return &AuditTrailEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// CandidateEdge is the edge representation of Candidate.
type CandidateEdge struct {
	Node   *Candidate `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// CandidateConnection is the connection containing edges to Candidate.
type CandidateConnection struct {
	Edges      []*CandidateEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *CandidateConnection) build(nodes []*Candidate, pager *candidatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Candidate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Candidate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Candidate {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidatePaginateOption enables pagination customization.
type CandidatePaginateOption func(*candidatePager) error

// WithCandidateOrder configures pagination ordering.
func WithCandidateOrder(order *CandidateOrder) CandidatePaginateOption {
	if order == nil {
		order = DefaultCandidateOrder
	}
	o := *order
	return func(pager *candidatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateFilter configures pagination filter.
func WithCandidateFilter(filter func(*CandidateQuery) (*CandidateQuery, error)) CandidatePaginateOption {
	return func(pager *candidatePager) error {
		if filter == nil {
			return errors.New("CandidateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidatePager struct {
	order  *CandidateOrder
	filter func(*CandidateQuery) (*CandidateQuery, error)
}

func newCandidatePager(opts []CandidatePaginateOption) (*candidatePager, error) {
	pager := &candidatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateOrder
	}
	return pager, nil
}

func (p *candidatePager) applyFilter(query *CandidateQuery) (*CandidateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidatePager) toCursor(c *Candidate) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *candidatePager) applyCursors(query *CandidateQuery, after, before *Cursor) *CandidateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidatePager) applyOrder(query *CandidateQuery, reverse bool) *CandidateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateOrder.Field.field))
	}
	return query
}

func (p *candidatePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateOrder.Field {
			b.Comma().Ident(DefaultCandidateOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Candidate.
func (c *CandidateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidatePaginateOption,
) (*CandidateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidatePager(opts)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CandidateConnection{Edges: []*CandidateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateOrderFieldCreatedAt orders Candidate by created_at.
	CandidateOrderFieldCreatedAt = &CandidateOrderField{
		field: candidate.FieldCreatedAt,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// CandidateOrderFieldUpdatedAt orders Candidate by updated_at.
	CandidateOrderFieldUpdatedAt = &CandidateOrderField{
		field: candidate.FieldUpdatedAt,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
	// CandidateOrderFieldDeletedAt orders Candidate by deleted_at.
	CandidateOrderFieldDeletedAt = &CandidateOrderField{
		field: candidate.FieldDeletedAt,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.DeletedAt,
			}
		},
	}
	// CandidateOrderFieldName orders Candidate by name.
	CandidateOrderFieldName = &CandidateOrderField{
		field: candidate.FieldName,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CandidateOrderFieldEmail orders Candidate by email.
	CandidateOrderFieldEmail = &CandidateOrderField{
		field: candidate.FieldEmail,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Email,
			}
		},
	}
	// CandidateOrderFieldLastApplyDate orders Candidate by last_apply_date.
	CandidateOrderFieldLastApplyDate = &CandidateOrderField{
		field: candidate.FieldLastApplyDate,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.LastApplyDate,
			}
		},
	}
	// CandidateOrderFieldRecruitTime orders Candidate by recruit_time.
	CandidateOrderFieldRecruitTime = &CandidateOrderField{
		field: candidate.FieldRecruitTime,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.RecruitTime,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateOrderField) String() string {
	var str string
	switch f.field {
	case candidate.FieldCreatedAt:
		str = "created_at"
	case candidate.FieldUpdatedAt:
		str = "updated_at"
	case candidate.FieldDeletedAt:
		str = "deleted_at"
	case candidate.FieldName:
		str = "name"
	case candidate.FieldEmail:
		str = "email"
	case candidate.FieldLastApplyDate:
		str = "last_apply_date"
	case candidate.FieldRecruitTime:
		str = "recruit_time"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateOrderFieldDeletedAt
	case "name":
		*f = *CandidateOrderFieldName
	case "email":
		*f = *CandidateOrderFieldEmail
	case "last_apply_date":
		*f = *CandidateOrderFieldLastApplyDate
	case "recruit_time":
		*f = *CandidateOrderFieldRecruitTime
	default:
		return fmt.Errorf("%s is not a valid CandidateOrderField", str)
	}
	return nil
}

// CandidateOrderField defines the ordering field of Candidate.
type CandidateOrderField struct {
	field    string
	toCursor func(*Candidate) Cursor
}

// CandidateOrder defines the ordering of Candidate.
type CandidateOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *CandidateOrderField `json:"field"`
}

// DefaultCandidateOrder is the default ordering of Candidate.
var DefaultCandidateOrder = &CandidateOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateOrderField{
		field: candidate.FieldID,
		toCursor: func(c *Candidate) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Candidate into CandidateEdge.
func (c *Candidate) ToEdge(order *CandidateOrder) *CandidateEdge {
	if order == nil {
		order = DefaultCandidateOrder
	}
	return &CandidateEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CandidateAwardEdge is the edge representation of CandidateAward.
type CandidateAwardEdge struct {
	Node   *CandidateAward `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CandidateAwardConnection is the connection containing edges to CandidateAward.
type CandidateAwardConnection struct {
	Edges      []*CandidateAwardEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *CandidateAwardConnection) build(nodes []*CandidateAward, pager *candidateawardPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateAward
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateAward {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateAward {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateAwardEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateAwardEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateAwardPaginateOption enables pagination customization.
type CandidateAwardPaginateOption func(*candidateawardPager) error

// WithCandidateAwardOrder configures pagination ordering.
func WithCandidateAwardOrder(order *CandidateAwardOrder) CandidateAwardPaginateOption {
	if order == nil {
		order = DefaultCandidateAwardOrder
	}
	o := *order
	return func(pager *candidateawardPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateAwardOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateAwardFilter configures pagination filter.
func WithCandidateAwardFilter(filter func(*CandidateAwardQuery) (*CandidateAwardQuery, error)) CandidateAwardPaginateOption {
	return func(pager *candidateawardPager) error {
		if filter == nil {
			return errors.New("CandidateAwardQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidateawardPager struct {
	order  *CandidateAwardOrder
	filter func(*CandidateAwardQuery) (*CandidateAwardQuery, error)
}

func newCandidateAwardPager(opts []CandidateAwardPaginateOption) (*candidateawardPager, error) {
	pager := &candidateawardPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateAwardOrder
	}
	return pager, nil
}

func (p *candidateawardPager) applyFilter(query *CandidateAwardQuery) (*CandidateAwardQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidateawardPager) toCursor(ca *CandidateAward) Cursor {
	return p.order.Field.toCursor(ca)
}

func (p *candidateawardPager) applyCursors(query *CandidateAwardQuery, after, before *Cursor) *CandidateAwardQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateAwardOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidateawardPager) applyOrder(query *CandidateAwardQuery, reverse bool) *CandidateAwardQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateAwardOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateAwardOrder.Field.field))
	}
	return query
}

func (p *candidateawardPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateAwardOrder.Field {
			b.Comma().Ident(DefaultCandidateAwardOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateAward.
func (ca *CandidateAwardQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateAwardPaginateOption,
) (*CandidateAwardConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateAwardPager(opts)
	if err != nil {
		return nil, err
	}
	if ca, err = pager.applyFilter(ca); err != nil {
		return nil, err
	}
	conn := &CandidateAwardConnection{Edges: []*CandidateAwardEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ca.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ca = pager.applyCursors(ca, after, before)
	ca = pager.applyOrder(ca, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ca.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ca.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ca.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateAwardOrderFieldCreatedAt orders CandidateAward by created_at.
	CandidateAwardOrderFieldCreatedAt = &CandidateAwardOrderField{
		field: candidateaward.FieldCreatedAt,
		toCursor: func(ca *CandidateAward) Cursor {
			return Cursor{
				ID:    ca.ID,
				Value: ca.CreatedAt,
			}
		},
	}
	// CandidateAwardOrderFieldUpdatedAt orders CandidateAward by updated_at.
	CandidateAwardOrderFieldUpdatedAt = &CandidateAwardOrderField{
		field: candidateaward.FieldUpdatedAt,
		toCursor: func(ca *CandidateAward) Cursor {
			return Cursor{
				ID:    ca.ID,
				Value: ca.UpdatedAt,
			}
		},
	}
	// CandidateAwardOrderFieldDeletedAt orders CandidateAward by deleted_at.
	CandidateAwardOrderFieldDeletedAt = &CandidateAwardOrderField{
		field: candidateaward.FieldDeletedAt,
		toCursor: func(ca *CandidateAward) Cursor {
			return Cursor{
				ID:    ca.ID,
				Value: ca.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateAwardOrderField) String() string {
	var str string
	switch f.field {
	case candidateaward.FieldCreatedAt:
		str = "created_at"
	case candidateaward.FieldUpdatedAt:
		str = "updated_at"
	case candidateaward.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateAwardOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateAwardOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateAwardOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateAwardOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateAwardOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateAwardOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateAwardOrderField", str)
	}
	return nil
}

// CandidateAwardOrderField defines the ordering field of CandidateAward.
type CandidateAwardOrderField struct {
	field    string
	toCursor func(*CandidateAward) Cursor
}

// CandidateAwardOrder defines the ordering of CandidateAward.
type CandidateAwardOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CandidateAwardOrderField `json:"field"`
}

// DefaultCandidateAwardOrder is the default ordering of CandidateAward.
var DefaultCandidateAwardOrder = &CandidateAwardOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateAwardOrderField{
		field: candidateaward.FieldID,
		toCursor: func(ca *CandidateAward) Cursor {
			return Cursor{ID: ca.ID}
		},
	},
}

// ToEdge converts CandidateAward into CandidateAwardEdge.
func (ca *CandidateAward) ToEdge(order *CandidateAwardOrder) *CandidateAwardEdge {
	if order == nil {
		order = DefaultCandidateAwardOrder
	}
	return &CandidateAwardEdge{
		Node:   ca,
		Cursor: order.Field.toCursor(ca),
	}
}

// CandidateCertificateEdge is the edge representation of CandidateCertificate.
type CandidateCertificateEdge struct {
	Node   *CandidateCertificate `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// CandidateCertificateConnection is the connection containing edges to CandidateCertificate.
type CandidateCertificateConnection struct {
	Edges      []*CandidateCertificateEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *CandidateCertificateConnection) build(nodes []*CandidateCertificate, pager *candidatecertificatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateCertificate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateCertificate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateCertificate {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateCertificateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateCertificateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateCertificatePaginateOption enables pagination customization.
type CandidateCertificatePaginateOption func(*candidatecertificatePager) error

// WithCandidateCertificateOrder configures pagination ordering.
func WithCandidateCertificateOrder(order *CandidateCertificateOrder) CandidateCertificatePaginateOption {
	if order == nil {
		order = DefaultCandidateCertificateOrder
	}
	o := *order
	return func(pager *candidatecertificatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateCertificateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateCertificateFilter configures pagination filter.
func WithCandidateCertificateFilter(filter func(*CandidateCertificateQuery) (*CandidateCertificateQuery, error)) CandidateCertificatePaginateOption {
	return func(pager *candidatecertificatePager) error {
		if filter == nil {
			return errors.New("CandidateCertificateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidatecertificatePager struct {
	order  *CandidateCertificateOrder
	filter func(*CandidateCertificateQuery) (*CandidateCertificateQuery, error)
}

func newCandidateCertificatePager(opts []CandidateCertificatePaginateOption) (*candidatecertificatePager, error) {
	pager := &candidatecertificatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateCertificateOrder
	}
	return pager, nil
}

func (p *candidatecertificatePager) applyFilter(query *CandidateCertificateQuery) (*CandidateCertificateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidatecertificatePager) toCursor(cc *CandidateCertificate) Cursor {
	return p.order.Field.toCursor(cc)
}

func (p *candidatecertificatePager) applyCursors(query *CandidateCertificateQuery, after, before *Cursor) *CandidateCertificateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateCertificateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidatecertificatePager) applyOrder(query *CandidateCertificateQuery, reverse bool) *CandidateCertificateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateCertificateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateCertificateOrder.Field.field))
	}
	return query
}

func (p *candidatecertificatePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateCertificateOrder.Field {
			b.Comma().Ident(DefaultCandidateCertificateOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateCertificate.
func (cc *CandidateCertificateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateCertificatePaginateOption,
) (*CandidateCertificateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateCertificatePager(opts)
	if err != nil {
		return nil, err
	}
	if cc, err = pager.applyFilter(cc); err != nil {
		return nil, err
	}
	conn := &CandidateCertificateConnection{Edges: []*CandidateCertificateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	cc = pager.applyCursors(cc, after, before)
	cc = pager.applyOrder(cc, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		cc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := cc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateCertificateOrderFieldCreatedAt orders CandidateCertificate by created_at.
	CandidateCertificateOrderFieldCreatedAt = &CandidateCertificateOrderField{
		field: candidatecertificate.FieldCreatedAt,
		toCursor: func(cc *CandidateCertificate) Cursor {
			return Cursor{
				ID:    cc.ID,
				Value: cc.CreatedAt,
			}
		},
	}
	// CandidateCertificateOrderFieldUpdatedAt orders CandidateCertificate by updated_at.
	CandidateCertificateOrderFieldUpdatedAt = &CandidateCertificateOrderField{
		field: candidatecertificate.FieldUpdatedAt,
		toCursor: func(cc *CandidateCertificate) Cursor {
			return Cursor{
				ID:    cc.ID,
				Value: cc.UpdatedAt,
			}
		},
	}
	// CandidateCertificateOrderFieldDeletedAt orders CandidateCertificate by deleted_at.
	CandidateCertificateOrderFieldDeletedAt = &CandidateCertificateOrderField{
		field: candidatecertificate.FieldDeletedAt,
		toCursor: func(cc *CandidateCertificate) Cursor {
			return Cursor{
				ID:    cc.ID,
				Value: cc.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateCertificateOrderField) String() string {
	var str string
	switch f.field {
	case candidatecertificate.FieldCreatedAt:
		str = "created_at"
	case candidatecertificate.FieldUpdatedAt:
		str = "updated_at"
	case candidatecertificate.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateCertificateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateCertificateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateCertificateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateCertificateOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateCertificateOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateCertificateOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateCertificateOrderField", str)
	}
	return nil
}

// CandidateCertificateOrderField defines the ordering field of CandidateCertificate.
type CandidateCertificateOrderField struct {
	field    string
	toCursor func(*CandidateCertificate) Cursor
}

// CandidateCertificateOrder defines the ordering of CandidateCertificate.
type CandidateCertificateOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *CandidateCertificateOrderField `json:"field"`
}

// DefaultCandidateCertificateOrder is the default ordering of CandidateCertificate.
var DefaultCandidateCertificateOrder = &CandidateCertificateOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateCertificateOrderField{
		field: candidatecertificate.FieldID,
		toCursor: func(cc *CandidateCertificate) Cursor {
			return Cursor{ID: cc.ID}
		},
	},
}

// ToEdge converts CandidateCertificate into CandidateCertificateEdge.
func (cc *CandidateCertificate) ToEdge(order *CandidateCertificateOrder) *CandidateCertificateEdge {
	if order == nil {
		order = DefaultCandidateCertificateOrder
	}
	return &CandidateCertificateEdge{
		Node:   cc,
		Cursor: order.Field.toCursor(cc),
	}
}

// CandidateEducateEdge is the edge representation of CandidateEducate.
type CandidateEducateEdge struct {
	Node   *CandidateEducate `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// CandidateEducateConnection is the connection containing edges to CandidateEducate.
type CandidateEducateConnection struct {
	Edges      []*CandidateEducateEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *CandidateEducateConnection) build(nodes []*CandidateEducate, pager *candidateeducatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateEducate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateEducate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateEducate {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateEducateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateEducateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateEducatePaginateOption enables pagination customization.
type CandidateEducatePaginateOption func(*candidateeducatePager) error

// WithCandidateEducateOrder configures pagination ordering.
func WithCandidateEducateOrder(order *CandidateEducateOrder) CandidateEducatePaginateOption {
	if order == nil {
		order = DefaultCandidateEducateOrder
	}
	o := *order
	return func(pager *candidateeducatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateEducateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateEducateFilter configures pagination filter.
func WithCandidateEducateFilter(filter func(*CandidateEducateQuery) (*CandidateEducateQuery, error)) CandidateEducatePaginateOption {
	return func(pager *candidateeducatePager) error {
		if filter == nil {
			return errors.New("CandidateEducateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidateeducatePager struct {
	order  *CandidateEducateOrder
	filter func(*CandidateEducateQuery) (*CandidateEducateQuery, error)
}

func newCandidateEducatePager(opts []CandidateEducatePaginateOption) (*candidateeducatePager, error) {
	pager := &candidateeducatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateEducateOrder
	}
	return pager, nil
}

func (p *candidateeducatePager) applyFilter(query *CandidateEducateQuery) (*CandidateEducateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidateeducatePager) toCursor(ce *CandidateEducate) Cursor {
	return p.order.Field.toCursor(ce)
}

func (p *candidateeducatePager) applyCursors(query *CandidateEducateQuery, after, before *Cursor) *CandidateEducateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateEducateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidateeducatePager) applyOrder(query *CandidateEducateQuery, reverse bool) *CandidateEducateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateEducateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateEducateOrder.Field.field))
	}
	return query
}

func (p *candidateeducatePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateEducateOrder.Field {
			b.Comma().Ident(DefaultCandidateEducateOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateEducate.
func (ce *CandidateEducateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateEducatePaginateOption,
) (*CandidateEducateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateEducatePager(opts)
	if err != nil {
		return nil, err
	}
	if ce, err = pager.applyFilter(ce); err != nil {
		return nil, err
	}
	conn := &CandidateEducateConnection{Edges: []*CandidateEducateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ce.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ce = pager.applyCursors(ce, after, before)
	ce = pager.applyOrder(ce, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ce.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ce.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ce.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateEducateOrderFieldCreatedAt orders CandidateEducate by created_at.
	CandidateEducateOrderFieldCreatedAt = &CandidateEducateOrderField{
		field: candidateeducate.FieldCreatedAt,
		toCursor: func(ce *CandidateEducate) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.CreatedAt,
			}
		},
	}
	// CandidateEducateOrderFieldUpdatedAt orders CandidateEducate by updated_at.
	CandidateEducateOrderFieldUpdatedAt = &CandidateEducateOrderField{
		field: candidateeducate.FieldUpdatedAt,
		toCursor: func(ce *CandidateEducate) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.UpdatedAt,
			}
		},
	}
	// CandidateEducateOrderFieldDeletedAt orders CandidateEducate by deleted_at.
	CandidateEducateOrderFieldDeletedAt = &CandidateEducateOrderField{
		field: candidateeducate.FieldDeletedAt,
		toCursor: func(ce *CandidateEducate) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateEducateOrderField) String() string {
	var str string
	switch f.field {
	case candidateeducate.FieldCreatedAt:
		str = "created_at"
	case candidateeducate.FieldUpdatedAt:
		str = "updated_at"
	case candidateeducate.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateEducateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateEducateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateEducateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateEducateOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateEducateOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateEducateOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateEducateOrderField", str)
	}
	return nil
}

// CandidateEducateOrderField defines the ordering field of CandidateEducate.
type CandidateEducateOrderField struct {
	field    string
	toCursor func(*CandidateEducate) Cursor
}

// CandidateEducateOrder defines the ordering of CandidateEducate.
type CandidateEducateOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *CandidateEducateOrderField `json:"field"`
}

// DefaultCandidateEducateOrder is the default ordering of CandidateEducate.
var DefaultCandidateEducateOrder = &CandidateEducateOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateEducateOrderField{
		field: candidateeducate.FieldID,
		toCursor: func(ce *CandidateEducate) Cursor {
			return Cursor{ID: ce.ID}
		},
	},
}

// ToEdge converts CandidateEducate into CandidateEducateEdge.
func (ce *CandidateEducate) ToEdge(order *CandidateEducateOrder) *CandidateEducateEdge {
	if order == nil {
		order = DefaultCandidateEducateOrder
	}
	return &CandidateEducateEdge{
		Node:   ce,
		Cursor: order.Field.toCursor(ce),
	}
}

// CandidateExpEdge is the edge representation of CandidateExp.
type CandidateExpEdge struct {
	Node   *CandidateExp `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CandidateExpConnection is the connection containing edges to CandidateExp.
type CandidateExpConnection struct {
	Edges      []*CandidateExpEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CandidateExpConnection) build(nodes []*CandidateExp, pager *candidateexpPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateExp
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateExp {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateExp {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateExpEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateExpEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateExpPaginateOption enables pagination customization.
type CandidateExpPaginateOption func(*candidateexpPager) error

// WithCandidateExpOrder configures pagination ordering.
func WithCandidateExpOrder(order *CandidateExpOrder) CandidateExpPaginateOption {
	if order == nil {
		order = DefaultCandidateExpOrder
	}
	o := *order
	return func(pager *candidateexpPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateExpOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateExpFilter configures pagination filter.
func WithCandidateExpFilter(filter func(*CandidateExpQuery) (*CandidateExpQuery, error)) CandidateExpPaginateOption {
	return func(pager *candidateexpPager) error {
		if filter == nil {
			return errors.New("CandidateExpQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidateexpPager struct {
	order  *CandidateExpOrder
	filter func(*CandidateExpQuery) (*CandidateExpQuery, error)
}

func newCandidateExpPager(opts []CandidateExpPaginateOption) (*candidateexpPager, error) {
	pager := &candidateexpPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateExpOrder
	}
	return pager, nil
}

func (p *candidateexpPager) applyFilter(query *CandidateExpQuery) (*CandidateExpQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidateexpPager) toCursor(ce *CandidateExp) Cursor {
	return p.order.Field.toCursor(ce)
}

func (p *candidateexpPager) applyCursors(query *CandidateExpQuery, after, before *Cursor) *CandidateExpQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateExpOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidateexpPager) applyOrder(query *CandidateExpQuery, reverse bool) *CandidateExpQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateExpOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateExpOrder.Field.field))
	}
	return query
}

func (p *candidateexpPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateExpOrder.Field {
			b.Comma().Ident(DefaultCandidateExpOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateExp.
func (ce *CandidateExpQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateExpPaginateOption,
) (*CandidateExpConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateExpPager(opts)
	if err != nil {
		return nil, err
	}
	if ce, err = pager.applyFilter(ce); err != nil {
		return nil, err
	}
	conn := &CandidateExpConnection{Edges: []*CandidateExpEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ce.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ce = pager.applyCursors(ce, after, before)
	ce = pager.applyOrder(ce, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ce.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ce.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ce.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateExpOrderFieldCreatedAt orders CandidateExp by created_at.
	CandidateExpOrderFieldCreatedAt = &CandidateExpOrderField{
		field: candidateexp.FieldCreatedAt,
		toCursor: func(ce *CandidateExp) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.CreatedAt,
			}
		},
	}
	// CandidateExpOrderFieldUpdatedAt orders CandidateExp by updated_at.
	CandidateExpOrderFieldUpdatedAt = &CandidateExpOrderField{
		field: candidateexp.FieldUpdatedAt,
		toCursor: func(ce *CandidateExp) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.UpdatedAt,
			}
		},
	}
	// CandidateExpOrderFieldDeletedAt orders CandidateExp by deleted_at.
	CandidateExpOrderFieldDeletedAt = &CandidateExpOrderField{
		field: candidateexp.FieldDeletedAt,
		toCursor: func(ce *CandidateExp) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateExpOrderField) String() string {
	var str string
	switch f.field {
	case candidateexp.FieldCreatedAt:
		str = "created_at"
	case candidateexp.FieldUpdatedAt:
		str = "updated_at"
	case candidateexp.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateExpOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateExpOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateExpOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateExpOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateExpOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateExpOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateExpOrderField", str)
	}
	return nil
}

// CandidateExpOrderField defines the ordering field of CandidateExp.
type CandidateExpOrderField struct {
	field    string
	toCursor func(*CandidateExp) Cursor
}

// CandidateExpOrder defines the ordering of CandidateExp.
type CandidateExpOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CandidateExpOrderField `json:"field"`
}

// DefaultCandidateExpOrder is the default ordering of CandidateExp.
var DefaultCandidateExpOrder = &CandidateExpOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateExpOrderField{
		field: candidateexp.FieldID,
		toCursor: func(ce *CandidateExp) Cursor {
			return Cursor{ID: ce.ID}
		},
	},
}

// ToEdge converts CandidateExp into CandidateExpEdge.
func (ce *CandidateExp) ToEdge(order *CandidateExpOrder) *CandidateExpEdge {
	if order == nil {
		order = DefaultCandidateExpOrder
	}
	return &CandidateExpEdge{
		Node:   ce,
		Cursor: order.Field.toCursor(ce),
	}
}

// CandidateInterviewEdge is the edge representation of CandidateInterview.
type CandidateInterviewEdge struct {
	Node   *CandidateInterview `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// CandidateInterviewConnection is the connection containing edges to CandidateInterview.
type CandidateInterviewConnection struct {
	Edges      []*CandidateInterviewEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *CandidateInterviewConnection) build(nodes []*CandidateInterview, pager *candidateinterviewPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateInterview
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateInterview {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateInterview {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateInterviewEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateInterviewEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateInterviewPaginateOption enables pagination customization.
type CandidateInterviewPaginateOption func(*candidateinterviewPager) error

// WithCandidateInterviewOrder configures pagination ordering.
func WithCandidateInterviewOrder(order *CandidateInterviewOrder) CandidateInterviewPaginateOption {
	if order == nil {
		order = DefaultCandidateInterviewOrder
	}
	o := *order
	return func(pager *candidateinterviewPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateInterviewOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateInterviewFilter configures pagination filter.
func WithCandidateInterviewFilter(filter func(*CandidateInterviewQuery) (*CandidateInterviewQuery, error)) CandidateInterviewPaginateOption {
	return func(pager *candidateinterviewPager) error {
		if filter == nil {
			return errors.New("CandidateInterviewQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidateinterviewPager struct {
	order  *CandidateInterviewOrder
	filter func(*CandidateInterviewQuery) (*CandidateInterviewQuery, error)
}

func newCandidateInterviewPager(opts []CandidateInterviewPaginateOption) (*candidateinterviewPager, error) {
	pager := &candidateinterviewPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateInterviewOrder
	}
	return pager, nil
}

func (p *candidateinterviewPager) applyFilter(query *CandidateInterviewQuery) (*CandidateInterviewQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidateinterviewPager) toCursor(ci *CandidateInterview) Cursor {
	return p.order.Field.toCursor(ci)
}

func (p *candidateinterviewPager) applyCursors(query *CandidateInterviewQuery, after, before *Cursor) *CandidateInterviewQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateInterviewOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidateinterviewPager) applyOrder(query *CandidateInterviewQuery, reverse bool) *CandidateInterviewQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateInterviewOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateInterviewOrder.Field.field))
	}
	return query
}

func (p *candidateinterviewPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateInterviewOrder.Field {
			b.Comma().Ident(DefaultCandidateInterviewOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateInterview.
func (ci *CandidateInterviewQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateInterviewPaginateOption,
) (*CandidateInterviewConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateInterviewPager(opts)
	if err != nil {
		return nil, err
	}
	if ci, err = pager.applyFilter(ci); err != nil {
		return nil, err
	}
	conn := &CandidateInterviewConnection{Edges: []*CandidateInterviewEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ci.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ci = pager.applyCursors(ci, after, before)
	ci = pager.applyOrder(ci, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ci.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ci.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ci.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateInterviewOrderFieldCreatedAt orders CandidateInterview by created_at.
	CandidateInterviewOrderFieldCreatedAt = &CandidateInterviewOrderField{
		field: candidateinterview.FieldCreatedAt,
		toCursor: func(ci *CandidateInterview) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.CreatedAt,
			}
		},
	}
	// CandidateInterviewOrderFieldUpdatedAt orders CandidateInterview by updated_at.
	CandidateInterviewOrderFieldUpdatedAt = &CandidateInterviewOrderField{
		field: candidateinterview.FieldUpdatedAt,
		toCursor: func(ci *CandidateInterview) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.UpdatedAt,
			}
		},
	}
	// CandidateInterviewOrderFieldDeletedAt orders CandidateInterview by deleted_at.
	CandidateInterviewOrderFieldDeletedAt = &CandidateInterviewOrderField{
		field: candidateinterview.FieldDeletedAt,
		toCursor: func(ci *CandidateInterview) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.DeletedAt,
			}
		},
	}
	// CandidateInterviewOrderFieldTitle orders CandidateInterview by title.
	CandidateInterviewOrderFieldTitle = &CandidateInterviewOrderField{
		field: candidateinterview.FieldTitle,
		toCursor: func(ci *CandidateInterview) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.Title,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateInterviewOrderField) String() string {
	var str string
	switch f.field {
	case candidateinterview.FieldCreatedAt:
		str = "created_at"
	case candidateinterview.FieldUpdatedAt:
		str = "updated_at"
	case candidateinterview.FieldDeletedAt:
		str = "deleted_at"
	case candidateinterview.FieldTitle:
		str = "title"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateInterviewOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateInterviewOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateInterviewOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateInterviewOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateInterviewOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateInterviewOrderFieldDeletedAt
	case "title":
		*f = *CandidateInterviewOrderFieldTitle
	default:
		return fmt.Errorf("%s is not a valid CandidateInterviewOrderField", str)
	}
	return nil
}

// CandidateInterviewOrderField defines the ordering field of CandidateInterview.
type CandidateInterviewOrderField struct {
	field    string
	toCursor func(*CandidateInterview) Cursor
}

// CandidateInterviewOrder defines the ordering of CandidateInterview.
type CandidateInterviewOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *CandidateInterviewOrderField `json:"field"`
}

// DefaultCandidateInterviewOrder is the default ordering of CandidateInterview.
var DefaultCandidateInterviewOrder = &CandidateInterviewOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateInterviewOrderField{
		field: candidateinterview.FieldID,
		toCursor: func(ci *CandidateInterview) Cursor {
			return Cursor{ID: ci.ID}
		},
	},
}

// ToEdge converts CandidateInterview into CandidateInterviewEdge.
func (ci *CandidateInterview) ToEdge(order *CandidateInterviewOrder) *CandidateInterviewEdge {
	if order == nil {
		order = DefaultCandidateInterviewOrder
	}
	return &CandidateInterviewEdge{
		Node:   ci,
		Cursor: order.Field.toCursor(ci),
	}
}

// CandidateInterviewerEdge is the edge representation of CandidateInterviewer.
type CandidateInterviewerEdge struct {
	Node   *CandidateInterviewer `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// CandidateInterviewerConnection is the connection containing edges to CandidateInterviewer.
type CandidateInterviewerConnection struct {
	Edges      []*CandidateInterviewerEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *CandidateInterviewerConnection) build(nodes []*CandidateInterviewer, pager *candidateinterviewerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateInterviewer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateInterviewer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateInterviewer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateInterviewerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateInterviewerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateInterviewerPaginateOption enables pagination customization.
type CandidateInterviewerPaginateOption func(*candidateinterviewerPager) error

// WithCandidateInterviewerOrder configures pagination ordering.
func WithCandidateInterviewerOrder(order *CandidateInterviewerOrder) CandidateInterviewerPaginateOption {
	if order == nil {
		order = DefaultCandidateInterviewerOrder
	}
	o := *order
	return func(pager *candidateinterviewerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateInterviewerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateInterviewerFilter configures pagination filter.
func WithCandidateInterviewerFilter(filter func(*CandidateInterviewerQuery) (*CandidateInterviewerQuery, error)) CandidateInterviewerPaginateOption {
	return func(pager *candidateinterviewerPager) error {
		if filter == nil {
			return errors.New("CandidateInterviewerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidateinterviewerPager struct {
	order  *CandidateInterviewerOrder
	filter func(*CandidateInterviewerQuery) (*CandidateInterviewerQuery, error)
}

func newCandidateInterviewerPager(opts []CandidateInterviewerPaginateOption) (*candidateinterviewerPager, error) {
	pager := &candidateinterviewerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateInterviewerOrder
	}
	return pager, nil
}

func (p *candidateinterviewerPager) applyFilter(query *CandidateInterviewerQuery) (*CandidateInterviewerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidateinterviewerPager) toCursor(ci *CandidateInterviewer) Cursor {
	return p.order.Field.toCursor(ci)
}

func (p *candidateinterviewerPager) applyCursors(query *CandidateInterviewerQuery, after, before *Cursor) *CandidateInterviewerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateInterviewerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidateinterviewerPager) applyOrder(query *CandidateInterviewerQuery, reverse bool) *CandidateInterviewerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateInterviewerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateInterviewerOrder.Field.field))
	}
	return query
}

func (p *candidateinterviewerPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateInterviewerOrder.Field {
			b.Comma().Ident(DefaultCandidateInterviewerOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateInterviewer.
func (ci *CandidateInterviewerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateInterviewerPaginateOption,
) (*CandidateInterviewerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateInterviewerPager(opts)
	if err != nil {
		return nil, err
	}
	if ci, err = pager.applyFilter(ci); err != nil {
		return nil, err
	}
	conn := &CandidateInterviewerConnection{Edges: []*CandidateInterviewerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ci.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ci = pager.applyCursors(ci, after, before)
	ci = pager.applyOrder(ci, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ci.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ci.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ci.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateInterviewerOrderFieldCreatedAt orders CandidateInterviewer by created_at.
	CandidateInterviewerOrderFieldCreatedAt = &CandidateInterviewerOrderField{
		field: candidateinterviewer.FieldCreatedAt,
		toCursor: func(ci *CandidateInterviewer) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.CreatedAt,
			}
		},
	}
	// CandidateInterviewerOrderFieldUpdatedAt orders CandidateInterviewer by updated_at.
	CandidateInterviewerOrderFieldUpdatedAt = &CandidateInterviewerOrderField{
		field: candidateinterviewer.FieldUpdatedAt,
		toCursor: func(ci *CandidateInterviewer) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.UpdatedAt,
			}
		},
	}
	// CandidateInterviewerOrderFieldDeletedAt orders CandidateInterviewer by deleted_at.
	CandidateInterviewerOrderFieldDeletedAt = &CandidateInterviewerOrderField{
		field: candidateinterviewer.FieldDeletedAt,
		toCursor: func(ci *CandidateInterviewer) Cursor {
			return Cursor{
				ID:    ci.ID,
				Value: ci.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateInterviewerOrderField) String() string {
	var str string
	switch f.field {
	case candidateinterviewer.FieldCreatedAt:
		str = "created_at"
	case candidateinterviewer.FieldUpdatedAt:
		str = "updated_at"
	case candidateinterviewer.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateInterviewerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateInterviewerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateInterviewerOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateInterviewerOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateInterviewerOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateInterviewerOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateInterviewerOrderField", str)
	}
	return nil
}

// CandidateInterviewerOrderField defines the ordering field of CandidateInterviewer.
type CandidateInterviewerOrderField struct {
	field    string
	toCursor func(*CandidateInterviewer) Cursor
}

// CandidateInterviewerOrder defines the ordering of CandidateInterviewer.
type CandidateInterviewerOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *CandidateInterviewerOrderField `json:"field"`
}

// DefaultCandidateInterviewerOrder is the default ordering of CandidateInterviewer.
var DefaultCandidateInterviewerOrder = &CandidateInterviewerOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateInterviewerOrderField{
		field: candidateinterviewer.FieldID,
		toCursor: func(ci *CandidateInterviewer) Cursor {
			return Cursor{ID: ci.ID}
		},
	},
}

// ToEdge converts CandidateInterviewer into CandidateInterviewerEdge.
func (ci *CandidateInterviewer) ToEdge(order *CandidateInterviewerOrder) *CandidateInterviewerEdge {
	if order == nil {
		order = DefaultCandidateInterviewerOrder
	}
	return &CandidateInterviewerEdge{
		Node:   ci,
		Cursor: order.Field.toCursor(ci),
	}
}

// CandidateJobEdge is the edge representation of CandidateJob.
type CandidateJobEdge struct {
	Node   *CandidateJob `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CandidateJobConnection is the connection containing edges to CandidateJob.
type CandidateJobConnection struct {
	Edges      []*CandidateJobEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CandidateJobConnection) build(nodes []*CandidateJob, pager *candidatejobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateJobPaginateOption enables pagination customization.
type CandidateJobPaginateOption func(*candidatejobPager) error

// WithCandidateJobOrder configures pagination ordering.
func WithCandidateJobOrder(order *CandidateJobOrder) CandidateJobPaginateOption {
	if order == nil {
		order = DefaultCandidateJobOrder
	}
	o := *order
	return func(pager *candidatejobPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateJobOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateJobFilter configures pagination filter.
func WithCandidateJobFilter(filter func(*CandidateJobQuery) (*CandidateJobQuery, error)) CandidateJobPaginateOption {
	return func(pager *candidatejobPager) error {
		if filter == nil {
			return errors.New("CandidateJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidatejobPager struct {
	order  *CandidateJobOrder
	filter func(*CandidateJobQuery) (*CandidateJobQuery, error)
}

func newCandidateJobPager(opts []CandidateJobPaginateOption) (*candidatejobPager, error) {
	pager := &candidatejobPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateJobOrder
	}
	return pager, nil
}

func (p *candidatejobPager) applyFilter(query *CandidateJobQuery) (*CandidateJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidatejobPager) toCursor(cj *CandidateJob) Cursor {
	return p.order.Field.toCursor(cj)
}

func (p *candidatejobPager) applyCursors(query *CandidateJobQuery, after, before *Cursor) *CandidateJobQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateJobOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidatejobPager) applyOrder(query *CandidateJobQuery, reverse bool) *CandidateJobQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateJobOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateJobOrder.Field.field))
	}
	return query
}

func (p *candidatejobPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateJobOrder.Field {
			b.Comma().Ident(DefaultCandidateJobOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateJob.
func (cj *CandidateJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateJobPaginateOption,
) (*CandidateJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateJobPager(opts)
	if err != nil {
		return nil, err
	}
	if cj, err = pager.applyFilter(cj); err != nil {
		return nil, err
	}
	conn := &CandidateJobConnection{Edges: []*CandidateJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cj.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	cj = pager.applyCursors(cj, after, before)
	cj = pager.applyOrder(cj, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		cj.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cj.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := cj.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateJobOrderFieldCreatedAt orders CandidateJob by created_at.
	CandidateJobOrderFieldCreatedAt = &CandidateJobOrderField{
		field: candidatejob.FieldCreatedAt,
		toCursor: func(cj *CandidateJob) Cursor {
			return Cursor{
				ID:    cj.ID,
				Value: cj.CreatedAt,
			}
		},
	}
	// CandidateJobOrderFieldUpdatedAt orders CandidateJob by updated_at.
	CandidateJobOrderFieldUpdatedAt = &CandidateJobOrderField{
		field: candidatejob.FieldUpdatedAt,
		toCursor: func(cj *CandidateJob) Cursor {
			return Cursor{
				ID:    cj.ID,
				Value: cj.UpdatedAt,
			}
		},
	}
	// CandidateJobOrderFieldDeletedAt orders CandidateJob by deleted_at.
	CandidateJobOrderFieldDeletedAt = &CandidateJobOrderField{
		field: candidatejob.FieldDeletedAt,
		toCursor: func(cj *CandidateJob) Cursor {
			return Cursor{
				ID:    cj.ID,
				Value: cj.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateJobOrderField) String() string {
	var str string
	switch f.field {
	case candidatejob.FieldCreatedAt:
		str = "created_at"
	case candidatejob.FieldUpdatedAt:
		str = "updated_at"
	case candidatejob.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateJobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateJobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateJobOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateJobOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateJobOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateJobOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateJobOrderField", str)
	}
	return nil
}

// CandidateJobOrderField defines the ordering field of CandidateJob.
type CandidateJobOrderField struct {
	field    string
	toCursor func(*CandidateJob) Cursor
}

// CandidateJobOrder defines the ordering of CandidateJob.
type CandidateJobOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CandidateJobOrderField `json:"field"`
}

// DefaultCandidateJobOrder is the default ordering of CandidateJob.
var DefaultCandidateJobOrder = &CandidateJobOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateJobOrderField{
		field: candidatejob.FieldID,
		toCursor: func(cj *CandidateJob) Cursor {
			return Cursor{ID: cj.ID}
		},
	},
}

// ToEdge converts CandidateJob into CandidateJobEdge.
func (cj *CandidateJob) ToEdge(order *CandidateJobOrder) *CandidateJobEdge {
	if order == nil {
		order = DefaultCandidateJobOrder
	}
	return &CandidateJobEdge{
		Node:   cj,
		Cursor: order.Field.toCursor(cj),
	}
}

// CandidateJobFeedbackEdge is the edge representation of CandidateJobFeedback.
type CandidateJobFeedbackEdge struct {
	Node   *CandidateJobFeedback `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// CandidateJobFeedbackConnection is the connection containing edges to CandidateJobFeedback.
type CandidateJobFeedbackConnection struct {
	Edges      []*CandidateJobFeedbackEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *CandidateJobFeedbackConnection) build(nodes []*CandidateJobFeedback, pager *candidatejobfeedbackPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateJobFeedback
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateJobFeedback {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateJobFeedback {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateJobFeedbackEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateJobFeedbackEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateJobFeedbackPaginateOption enables pagination customization.
type CandidateJobFeedbackPaginateOption func(*candidatejobfeedbackPager) error

// WithCandidateJobFeedbackOrder configures pagination ordering.
func WithCandidateJobFeedbackOrder(order *CandidateJobFeedbackOrder) CandidateJobFeedbackPaginateOption {
	if order == nil {
		order = DefaultCandidateJobFeedbackOrder
	}
	o := *order
	return func(pager *candidatejobfeedbackPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateJobFeedbackOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateJobFeedbackFilter configures pagination filter.
func WithCandidateJobFeedbackFilter(filter func(*CandidateJobFeedbackQuery) (*CandidateJobFeedbackQuery, error)) CandidateJobFeedbackPaginateOption {
	return func(pager *candidatejobfeedbackPager) error {
		if filter == nil {
			return errors.New("CandidateJobFeedbackQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidatejobfeedbackPager struct {
	order  *CandidateJobFeedbackOrder
	filter func(*CandidateJobFeedbackQuery) (*CandidateJobFeedbackQuery, error)
}

func newCandidateJobFeedbackPager(opts []CandidateJobFeedbackPaginateOption) (*candidatejobfeedbackPager, error) {
	pager := &candidatejobfeedbackPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateJobFeedbackOrder
	}
	return pager, nil
}

func (p *candidatejobfeedbackPager) applyFilter(query *CandidateJobFeedbackQuery) (*CandidateJobFeedbackQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidatejobfeedbackPager) toCursor(cjf *CandidateJobFeedback) Cursor {
	return p.order.Field.toCursor(cjf)
}

func (p *candidatejobfeedbackPager) applyCursors(query *CandidateJobFeedbackQuery, after, before *Cursor) *CandidateJobFeedbackQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateJobFeedbackOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidatejobfeedbackPager) applyOrder(query *CandidateJobFeedbackQuery, reverse bool) *CandidateJobFeedbackQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateJobFeedbackOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateJobFeedbackOrder.Field.field))
	}
	return query
}

func (p *candidatejobfeedbackPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateJobFeedbackOrder.Field {
			b.Comma().Ident(DefaultCandidateJobFeedbackOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateJobFeedback.
func (cjf *CandidateJobFeedbackQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateJobFeedbackPaginateOption,
) (*CandidateJobFeedbackConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateJobFeedbackPager(opts)
	if err != nil {
		return nil, err
	}
	if cjf, err = pager.applyFilter(cjf); err != nil {
		return nil, err
	}
	conn := &CandidateJobFeedbackConnection{Edges: []*CandidateJobFeedbackEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cjf.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	cjf = pager.applyCursors(cjf, after, before)
	cjf = pager.applyOrder(cjf, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		cjf.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cjf.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := cjf.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateJobFeedbackOrderFieldCreatedAt orders CandidateJobFeedback by created_at.
	CandidateJobFeedbackOrderFieldCreatedAt = &CandidateJobFeedbackOrderField{
		field: candidatejobfeedback.FieldCreatedAt,
		toCursor: func(cjf *CandidateJobFeedback) Cursor {
			return Cursor{
				ID:    cjf.ID,
				Value: cjf.CreatedAt,
			}
		},
	}
	// CandidateJobFeedbackOrderFieldUpdatedAt orders CandidateJobFeedback by updated_at.
	CandidateJobFeedbackOrderFieldUpdatedAt = &CandidateJobFeedbackOrderField{
		field: candidatejobfeedback.FieldUpdatedAt,
		toCursor: func(cjf *CandidateJobFeedback) Cursor {
			return Cursor{
				ID:    cjf.ID,
				Value: cjf.UpdatedAt,
			}
		},
	}
	// CandidateJobFeedbackOrderFieldDeletedAt orders CandidateJobFeedback by deleted_at.
	CandidateJobFeedbackOrderFieldDeletedAt = &CandidateJobFeedbackOrderField{
		field: candidatejobfeedback.FieldDeletedAt,
		toCursor: func(cjf *CandidateJobFeedback) Cursor {
			return Cursor{
				ID:    cjf.ID,
				Value: cjf.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateJobFeedbackOrderField) String() string {
	var str string
	switch f.field {
	case candidatejobfeedback.FieldCreatedAt:
		str = "created_at"
	case candidatejobfeedback.FieldUpdatedAt:
		str = "updated_at"
	case candidatejobfeedback.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateJobFeedbackOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateJobFeedbackOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateJobFeedbackOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateJobFeedbackOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateJobFeedbackOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateJobFeedbackOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateJobFeedbackOrderField", str)
	}
	return nil
}

// CandidateJobFeedbackOrderField defines the ordering field of CandidateJobFeedback.
type CandidateJobFeedbackOrderField struct {
	field    string
	toCursor func(*CandidateJobFeedback) Cursor
}

// CandidateJobFeedbackOrder defines the ordering of CandidateJobFeedback.
type CandidateJobFeedbackOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *CandidateJobFeedbackOrderField `json:"field"`
}

// DefaultCandidateJobFeedbackOrder is the default ordering of CandidateJobFeedback.
var DefaultCandidateJobFeedbackOrder = &CandidateJobFeedbackOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateJobFeedbackOrderField{
		field: candidatejobfeedback.FieldID,
		toCursor: func(cjf *CandidateJobFeedback) Cursor {
			return Cursor{ID: cjf.ID}
		},
	},
}

// ToEdge converts CandidateJobFeedback into CandidateJobFeedbackEdge.
func (cjf *CandidateJobFeedback) ToEdge(order *CandidateJobFeedbackOrder) *CandidateJobFeedbackEdge {
	if order == nil {
		order = DefaultCandidateJobFeedbackOrder
	}
	return &CandidateJobFeedbackEdge{
		Node:   cjf,
		Cursor: order.Field.toCursor(cjf),
	}
}

// CandidateJobStepEdge is the edge representation of CandidateJobStep.
type CandidateJobStepEdge struct {
	Node   *CandidateJobStep `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// CandidateJobStepConnection is the connection containing edges to CandidateJobStep.
type CandidateJobStepConnection struct {
	Edges      []*CandidateJobStepEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *CandidateJobStepConnection) build(nodes []*CandidateJobStep, pager *candidatejobstepPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CandidateJobStep
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CandidateJobStep {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CandidateJobStep {
			return nodes[i]
		}
	}
	c.Edges = make([]*CandidateJobStepEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CandidateJobStepEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CandidateJobStepPaginateOption enables pagination customization.
type CandidateJobStepPaginateOption func(*candidatejobstepPager) error

// WithCandidateJobStepOrder configures pagination ordering.
func WithCandidateJobStepOrder(order *CandidateJobStepOrder) CandidateJobStepPaginateOption {
	if order == nil {
		order = DefaultCandidateJobStepOrder
	}
	o := *order
	return func(pager *candidatejobstepPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCandidateJobStepOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCandidateJobStepFilter configures pagination filter.
func WithCandidateJobStepFilter(filter func(*CandidateJobStepQuery) (*CandidateJobStepQuery, error)) CandidateJobStepPaginateOption {
	return func(pager *candidatejobstepPager) error {
		if filter == nil {
			return errors.New("CandidateJobStepQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type candidatejobstepPager struct {
	order  *CandidateJobStepOrder
	filter func(*CandidateJobStepQuery) (*CandidateJobStepQuery, error)
}

func newCandidateJobStepPager(opts []CandidateJobStepPaginateOption) (*candidatejobstepPager, error) {
	pager := &candidatejobstepPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCandidateJobStepOrder
	}
	return pager, nil
}

func (p *candidatejobstepPager) applyFilter(query *CandidateJobStepQuery) (*CandidateJobStepQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *candidatejobstepPager) toCursor(cjs *CandidateJobStep) Cursor {
	return p.order.Field.toCursor(cjs)
}

func (p *candidatejobstepPager) applyCursors(query *CandidateJobStepQuery, after, before *Cursor) *CandidateJobStepQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCandidateJobStepOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *candidatejobstepPager) applyOrder(query *CandidateJobStepQuery, reverse bool) *CandidateJobStepQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCandidateJobStepOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCandidateJobStepOrder.Field.field))
	}
	return query
}

func (p *candidatejobstepPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCandidateJobStepOrder.Field {
			b.Comma().Ident(DefaultCandidateJobStepOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CandidateJobStep.
func (cjs *CandidateJobStepQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CandidateJobStepPaginateOption,
) (*CandidateJobStepConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCandidateJobStepPager(opts)
	if err != nil {
		return nil, err
	}
	if cjs, err = pager.applyFilter(cjs); err != nil {
		return nil, err
	}
	conn := &CandidateJobStepConnection{Edges: []*CandidateJobStepEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cjs.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	cjs = pager.applyCursors(cjs, after, before)
	cjs = pager.applyOrder(cjs, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		cjs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cjs.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := cjs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CandidateJobStepOrderFieldCreatedAt orders CandidateJobStep by created_at.
	CandidateJobStepOrderFieldCreatedAt = &CandidateJobStepOrderField{
		field: candidatejobstep.FieldCreatedAt,
		toCursor: func(cjs *CandidateJobStep) Cursor {
			return Cursor{
				ID:    cjs.ID,
				Value: cjs.CreatedAt,
			}
		},
	}
	// CandidateJobStepOrderFieldUpdatedAt orders CandidateJobStep by updated_at.
	CandidateJobStepOrderFieldUpdatedAt = &CandidateJobStepOrderField{
		field: candidatejobstep.FieldUpdatedAt,
		toCursor: func(cjs *CandidateJobStep) Cursor {
			return Cursor{
				ID:    cjs.ID,
				Value: cjs.UpdatedAt,
			}
		},
	}
	// CandidateJobStepOrderFieldDeletedAt orders CandidateJobStep by deleted_at.
	CandidateJobStepOrderFieldDeletedAt = &CandidateJobStepOrderField{
		field: candidatejobstep.FieldDeletedAt,
		toCursor: func(cjs *CandidateJobStep) Cursor {
			return Cursor{
				ID:    cjs.ID,
				Value: cjs.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CandidateJobStepOrderField) String() string {
	var str string
	switch f.field {
	case candidatejobstep.FieldCreatedAt:
		str = "created_at"
	case candidatejobstep.FieldUpdatedAt:
		str = "updated_at"
	case candidatejobstep.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CandidateJobStepOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CandidateJobStepOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CandidateJobStepOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *CandidateJobStepOrderFieldCreatedAt
	case "updated_at":
		*f = *CandidateJobStepOrderFieldUpdatedAt
	case "deleted_at":
		*f = *CandidateJobStepOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid CandidateJobStepOrderField", str)
	}
	return nil
}

// CandidateJobStepOrderField defines the ordering field of CandidateJobStep.
type CandidateJobStepOrderField struct {
	field    string
	toCursor func(*CandidateJobStep) Cursor
}

// CandidateJobStepOrder defines the ordering of CandidateJobStep.
type CandidateJobStepOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *CandidateJobStepOrderField `json:"field"`
}

// DefaultCandidateJobStepOrder is the default ordering of CandidateJobStep.
var DefaultCandidateJobStepOrder = &CandidateJobStepOrder{
	Direction: OrderDirectionAsc,
	Field: &CandidateJobStepOrderField{
		field: candidatejobstep.FieldID,
		toCursor: func(cjs *CandidateJobStep) Cursor {
			return Cursor{ID: cjs.ID}
		},
	},
}

// ToEdge converts CandidateJobStep into CandidateJobStepEdge.
func (cjs *CandidateJobStep) ToEdge(order *CandidateJobStepOrder) *CandidateJobStepEdge {
	if order == nil {
		order = DefaultCandidateJobStepOrder
	}
	return &CandidateJobStepEdge{
		Node:   cjs,
		Cursor: order.Field.toCursor(cjs),
	}
}

// EmailRoleAttributeEdge is the edge representation of EmailRoleAttribute.
type EmailRoleAttributeEdge struct {
	Node   *EmailRoleAttribute `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// EmailRoleAttributeConnection is the connection containing edges to EmailRoleAttribute.
type EmailRoleAttributeConnection struct {
	Edges      []*EmailRoleAttributeEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *EmailRoleAttributeConnection) build(nodes []*EmailRoleAttribute, pager *emailroleattributePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EmailRoleAttribute
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EmailRoleAttribute {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EmailRoleAttribute {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailRoleAttributeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailRoleAttributeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailRoleAttributePaginateOption enables pagination customization.
type EmailRoleAttributePaginateOption func(*emailroleattributePager) error

// WithEmailRoleAttributeOrder configures pagination ordering.
func WithEmailRoleAttributeOrder(order *EmailRoleAttributeOrder) EmailRoleAttributePaginateOption {
	if order == nil {
		order = DefaultEmailRoleAttributeOrder
	}
	o := *order
	return func(pager *emailroleattributePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmailRoleAttributeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmailRoleAttributeFilter configures pagination filter.
func WithEmailRoleAttributeFilter(filter func(*EmailRoleAttributeQuery) (*EmailRoleAttributeQuery, error)) EmailRoleAttributePaginateOption {
	return func(pager *emailroleattributePager) error {
		if filter == nil {
			return errors.New("EmailRoleAttributeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailroleattributePager struct {
	order  *EmailRoleAttributeOrder
	filter func(*EmailRoleAttributeQuery) (*EmailRoleAttributeQuery, error)
}

func newEmailRoleAttributePager(opts []EmailRoleAttributePaginateOption) (*emailroleattributePager, error) {
	pager := &emailroleattributePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmailRoleAttributeOrder
	}
	return pager, nil
}

func (p *emailroleattributePager) applyFilter(query *EmailRoleAttributeQuery) (*EmailRoleAttributeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailroleattributePager) toCursor(era *EmailRoleAttribute) Cursor {
	return p.order.Field.toCursor(era)
}

func (p *emailroleattributePager) applyCursors(query *EmailRoleAttributeQuery, after, before *Cursor) *EmailRoleAttributeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEmailRoleAttributeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *emailroleattributePager) applyOrder(query *EmailRoleAttributeQuery, reverse bool) *EmailRoleAttributeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEmailRoleAttributeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEmailRoleAttributeOrder.Field.field))
	}
	return query
}

func (p *emailroleattributePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmailRoleAttributeOrder.Field {
			b.Comma().Ident(DefaultEmailRoleAttributeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EmailRoleAttribute.
func (era *EmailRoleAttributeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailRoleAttributePaginateOption,
) (*EmailRoleAttributeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailRoleAttributePager(opts)
	if err != nil {
		return nil, err
	}
	if era, err = pager.applyFilter(era); err != nil {
		return nil, err
	}
	conn := &EmailRoleAttributeConnection{Edges: []*EmailRoleAttributeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = era.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	era = pager.applyCursors(era, after, before)
	era = pager.applyOrder(era, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		era.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := era.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := era.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmailRoleAttributeOrderFieldCreatedAt orders EmailRoleAttribute by created_at.
	EmailRoleAttributeOrderFieldCreatedAt = &EmailRoleAttributeOrderField{
		field: emailroleattribute.FieldCreatedAt,
		toCursor: func(era *EmailRoleAttribute) Cursor {
			return Cursor{
				ID:    era.ID,
				Value: era.CreatedAt,
			}
		},
	}
	// EmailRoleAttributeOrderFieldUpdatedAt orders EmailRoleAttribute by updated_at.
	EmailRoleAttributeOrderFieldUpdatedAt = &EmailRoleAttributeOrderField{
		field: emailroleattribute.FieldUpdatedAt,
		toCursor: func(era *EmailRoleAttribute) Cursor {
			return Cursor{
				ID:    era.ID,
				Value: era.UpdatedAt,
			}
		},
	}
	// EmailRoleAttributeOrderFieldDeletedAt orders EmailRoleAttribute by deleted_at.
	EmailRoleAttributeOrderFieldDeletedAt = &EmailRoleAttributeOrderField{
		field: emailroleattribute.FieldDeletedAt,
		toCursor: func(era *EmailRoleAttribute) Cursor {
			return Cursor{
				ID:    era.ID,
				Value: era.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmailRoleAttributeOrderField) String() string {
	var str string
	switch f.field {
	case emailroleattribute.FieldCreatedAt:
		str = "created_at"
	case emailroleattribute.FieldUpdatedAt:
		str = "updated_at"
	case emailroleattribute.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmailRoleAttributeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmailRoleAttributeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmailRoleAttributeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EmailRoleAttributeOrderFieldCreatedAt
	case "updated_at":
		*f = *EmailRoleAttributeOrderFieldUpdatedAt
	case "deleted_at":
		*f = *EmailRoleAttributeOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid EmailRoleAttributeOrderField", str)
	}
	return nil
}

// EmailRoleAttributeOrderField defines the ordering field of EmailRoleAttribute.
type EmailRoleAttributeOrderField struct {
	field    string
	toCursor func(*EmailRoleAttribute) Cursor
}

// EmailRoleAttributeOrder defines the ordering of EmailRoleAttribute.
type EmailRoleAttributeOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *EmailRoleAttributeOrderField `json:"field"`
}

// DefaultEmailRoleAttributeOrder is the default ordering of EmailRoleAttribute.
var DefaultEmailRoleAttributeOrder = &EmailRoleAttributeOrder{
	Direction: OrderDirectionAsc,
	Field: &EmailRoleAttributeOrderField{
		field: emailroleattribute.FieldID,
		toCursor: func(era *EmailRoleAttribute) Cursor {
			return Cursor{ID: era.ID}
		},
	},
}

// ToEdge converts EmailRoleAttribute into EmailRoleAttributeEdge.
func (era *EmailRoleAttribute) ToEdge(order *EmailRoleAttributeOrder) *EmailRoleAttributeEdge {
	if order == nil {
		order = DefaultEmailRoleAttributeOrder
	}
	return &EmailRoleAttributeEdge{
		Node:   era,
		Cursor: order.Field.toCursor(era),
	}
}

// EmailTemplateEdge is the edge representation of EmailTemplate.
type EmailTemplateEdge struct {
	Node   *EmailTemplate `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EmailTemplateConnection is the connection containing edges to EmailTemplate.
type EmailTemplateConnection struct {
	Edges      []*EmailTemplateEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *EmailTemplateConnection) build(nodes []*EmailTemplate, pager *emailtemplatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EmailTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EmailTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EmailTemplate {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailTemplatePaginateOption enables pagination customization.
type EmailTemplatePaginateOption func(*emailtemplatePager) error

// WithEmailTemplateOrder configures pagination ordering.
func WithEmailTemplateOrder(order *EmailTemplateOrder) EmailTemplatePaginateOption {
	if order == nil {
		order = DefaultEmailTemplateOrder
	}
	o := *order
	return func(pager *emailtemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmailTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmailTemplateFilter configures pagination filter.
func WithEmailTemplateFilter(filter func(*EmailTemplateQuery) (*EmailTemplateQuery, error)) EmailTemplatePaginateOption {
	return func(pager *emailtemplatePager) error {
		if filter == nil {
			return errors.New("EmailTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailtemplatePager struct {
	order  *EmailTemplateOrder
	filter func(*EmailTemplateQuery) (*EmailTemplateQuery, error)
}

func newEmailTemplatePager(opts []EmailTemplatePaginateOption) (*emailtemplatePager, error) {
	pager := &emailtemplatePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmailTemplateOrder
	}
	return pager, nil
}

func (p *emailtemplatePager) applyFilter(query *EmailTemplateQuery) (*EmailTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailtemplatePager) toCursor(et *EmailTemplate) Cursor {
	return p.order.Field.toCursor(et)
}

func (p *emailtemplatePager) applyCursors(query *EmailTemplateQuery, after, before *Cursor) *EmailTemplateQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEmailTemplateOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *emailtemplatePager) applyOrder(query *EmailTemplateQuery, reverse bool) *EmailTemplateQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEmailTemplateOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEmailTemplateOrder.Field.field))
	}
	return query
}

func (p *emailtemplatePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmailTemplateOrder.Field {
			b.Comma().Ident(DefaultEmailTemplateOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EmailTemplate.
func (et *EmailTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailTemplatePaginateOption,
) (*EmailTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailTemplatePager(opts)
	if err != nil {
		return nil, err
	}
	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}
	conn := &EmailTemplateConnection{Edges: []*EmailTemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = et.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	et = pager.applyCursors(et, after, before)
	et = pager.applyOrder(et, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		et.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := et.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := et.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmailTemplateOrderFieldCreatedAt orders EmailTemplate by created_at.
	EmailTemplateOrderFieldCreatedAt = &EmailTemplateOrderField{
		field: emailtemplate.FieldCreatedAt,
		toCursor: func(et *EmailTemplate) Cursor {
			return Cursor{
				ID:    et.ID,
				Value: et.CreatedAt,
			}
		},
	}
	// EmailTemplateOrderFieldUpdatedAt orders EmailTemplate by updated_at.
	EmailTemplateOrderFieldUpdatedAt = &EmailTemplateOrderField{
		field: emailtemplate.FieldUpdatedAt,
		toCursor: func(et *EmailTemplate) Cursor {
			return Cursor{
				ID:    et.ID,
				Value: et.UpdatedAt,
			}
		},
	}
	// EmailTemplateOrderFieldDeletedAt orders EmailTemplate by deleted_at.
	EmailTemplateOrderFieldDeletedAt = &EmailTemplateOrderField{
		field: emailtemplate.FieldDeletedAt,
		toCursor: func(et *EmailTemplate) Cursor {
			return Cursor{
				ID:    et.ID,
				Value: et.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmailTemplateOrderField) String() string {
	var str string
	switch f.field {
	case emailtemplate.FieldCreatedAt:
		str = "created_at"
	case emailtemplate.FieldUpdatedAt:
		str = "updated_at"
	case emailtemplate.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmailTemplateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmailTemplateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmailTemplateOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EmailTemplateOrderFieldCreatedAt
	case "updated_at":
		*f = *EmailTemplateOrderFieldUpdatedAt
	case "deleted_at":
		*f = *EmailTemplateOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid EmailTemplateOrderField", str)
	}
	return nil
}

// EmailTemplateOrderField defines the ordering field of EmailTemplate.
type EmailTemplateOrderField struct {
	field    string
	toCursor func(*EmailTemplate) Cursor
}

// EmailTemplateOrder defines the ordering of EmailTemplate.
type EmailTemplateOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EmailTemplateOrderField `json:"field"`
}

// DefaultEmailTemplateOrder is the default ordering of EmailTemplate.
var DefaultEmailTemplateOrder = &EmailTemplateOrder{
	Direction: OrderDirectionAsc,
	Field: &EmailTemplateOrderField{
		field: emailtemplate.FieldID,
		toCursor: func(et *EmailTemplate) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// ToEdge converts EmailTemplate into EmailTemplateEdge.
func (et *EmailTemplate) ToEdge(order *EmailTemplateOrder) *EmailTemplateEdge {
	if order == nil {
		order = DefaultEmailTemplateOrder
	}
	return &EmailTemplateEdge{
		Node:   et,
		Cursor: order.Field.toCursor(et),
	}
}

// EntityPermissionEdge is the edge representation of EntityPermission.
type EntityPermissionEdge struct {
	Node   *EntityPermission `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// EntityPermissionConnection is the connection containing edges to EntityPermission.
type EntityPermissionConnection struct {
	Edges      []*EntityPermissionEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *EntityPermissionConnection) build(nodes []*EntityPermission, pager *entitypermissionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntityPermission
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntityPermission {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntityPermission {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntityPermissionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntityPermissionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntityPermissionPaginateOption enables pagination customization.
type EntityPermissionPaginateOption func(*entitypermissionPager) error

// WithEntityPermissionOrder configures pagination ordering.
func WithEntityPermissionOrder(order *EntityPermissionOrder) EntityPermissionPaginateOption {
	if order == nil {
		order = DefaultEntityPermissionOrder
	}
	o := *order
	return func(pager *entitypermissionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntityPermissionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntityPermissionFilter configures pagination filter.
func WithEntityPermissionFilter(filter func(*EntityPermissionQuery) (*EntityPermissionQuery, error)) EntityPermissionPaginateOption {
	return func(pager *entitypermissionPager) error {
		if filter == nil {
			return errors.New("EntityPermissionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entitypermissionPager struct {
	order  *EntityPermissionOrder
	filter func(*EntityPermissionQuery) (*EntityPermissionQuery, error)
}

func newEntityPermissionPager(opts []EntityPermissionPaginateOption) (*entitypermissionPager, error) {
	pager := &entitypermissionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntityPermissionOrder
	}
	return pager, nil
}

func (p *entitypermissionPager) applyFilter(query *EntityPermissionQuery) (*EntityPermissionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entitypermissionPager) toCursor(ep *EntityPermission) Cursor {
	return p.order.Field.toCursor(ep)
}

func (p *entitypermissionPager) applyCursors(query *EntityPermissionQuery, after, before *Cursor) *EntityPermissionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEntityPermissionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *entitypermissionPager) applyOrder(query *EntityPermissionQuery, reverse bool) *EntityPermissionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEntityPermissionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEntityPermissionOrder.Field.field))
	}
	return query
}

func (p *entitypermissionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntityPermissionOrder.Field {
			b.Comma().Ident(DefaultEntityPermissionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntityPermission.
func (ep *EntityPermissionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntityPermissionPaginateOption,
) (*EntityPermissionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntityPermissionPager(opts)
	if err != nil {
		return nil, err
	}
	if ep, err = pager.applyFilter(ep); err != nil {
		return nil, err
	}
	conn := &EntityPermissionConnection{Edges: []*EntityPermissionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ep.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ep = pager.applyCursors(ep, after, before)
	ep = pager.applyOrder(ep, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ep.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ep.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ep.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntityPermissionOrderFieldCreatedAt orders EntityPermission by created_at.
	EntityPermissionOrderFieldCreatedAt = &EntityPermissionOrderField{
		field: entitypermission.FieldCreatedAt,
		toCursor: func(ep *EntityPermission) Cursor {
			return Cursor{
				ID:    ep.ID,
				Value: ep.CreatedAt,
			}
		},
	}
	// EntityPermissionOrderFieldUpdatedAt orders EntityPermission by updated_at.
	EntityPermissionOrderFieldUpdatedAt = &EntityPermissionOrderField{
		field: entitypermission.FieldUpdatedAt,
		toCursor: func(ep *EntityPermission) Cursor {
			return Cursor{
				ID:    ep.ID,
				Value: ep.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntityPermissionOrderField) String() string {
	var str string
	switch f.field {
	case entitypermission.FieldCreatedAt:
		str = "created_at"
	case entitypermission.FieldUpdatedAt:
		str = "updated_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntityPermissionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntityPermissionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntityPermissionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntityPermissionOrderFieldCreatedAt
	case "updated_at":
		*f = *EntityPermissionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid EntityPermissionOrderField", str)
	}
	return nil
}

// EntityPermissionOrderField defines the ordering field of EntityPermission.
type EntityPermissionOrderField struct {
	field    string
	toCursor func(*EntityPermission) Cursor
}

// EntityPermissionOrder defines the ordering of EntityPermission.
type EntityPermissionOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *EntityPermissionOrderField `json:"field"`
}

// DefaultEntityPermissionOrder is the default ordering of EntityPermission.
var DefaultEntityPermissionOrder = &EntityPermissionOrder{
	Direction: OrderDirectionAsc,
	Field: &EntityPermissionOrderField{
		field: entitypermission.FieldID,
		toCursor: func(ep *EntityPermission) Cursor {
			return Cursor{ID: ep.ID}
		},
	},
}

// ToEdge converts EntityPermission into EntityPermissionEdge.
func (ep *EntityPermission) ToEdge(order *EntityPermissionOrder) *EntityPermissionEdge {
	if order == nil {
		order = DefaultEntityPermissionOrder
	}
	return &EntityPermissionEdge{
		Node:   ep,
		Cursor: order.Field.toCursor(ep),
	}
}

// EntitySkillEdge is the edge representation of EntitySkill.
type EntitySkillEdge struct {
	Node   *EntitySkill `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// EntitySkillConnection is the connection containing edges to EntitySkill.
type EntitySkillConnection struct {
	Edges      []*EntitySkillEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *EntitySkillConnection) build(nodes []*EntitySkill, pager *entityskillPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EntitySkill
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EntitySkill {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EntitySkill {
			return nodes[i]
		}
	}
	c.Edges = make([]*EntitySkillEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EntitySkillEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EntitySkillPaginateOption enables pagination customization.
type EntitySkillPaginateOption func(*entityskillPager) error

// WithEntitySkillOrder configures pagination ordering.
func WithEntitySkillOrder(order *EntitySkillOrder) EntitySkillPaginateOption {
	if order == nil {
		order = DefaultEntitySkillOrder
	}
	o := *order
	return func(pager *entityskillPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEntitySkillOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEntitySkillFilter configures pagination filter.
func WithEntitySkillFilter(filter func(*EntitySkillQuery) (*EntitySkillQuery, error)) EntitySkillPaginateOption {
	return func(pager *entityskillPager) error {
		if filter == nil {
			return errors.New("EntitySkillQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type entityskillPager struct {
	order  *EntitySkillOrder
	filter func(*EntitySkillQuery) (*EntitySkillQuery, error)
}

func newEntitySkillPager(opts []EntitySkillPaginateOption) (*entityskillPager, error) {
	pager := &entityskillPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEntitySkillOrder
	}
	return pager, nil
}

func (p *entityskillPager) applyFilter(query *EntitySkillQuery) (*EntitySkillQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *entityskillPager) toCursor(es *EntitySkill) Cursor {
	return p.order.Field.toCursor(es)
}

func (p *entityskillPager) applyCursors(query *EntitySkillQuery, after, before *Cursor) *EntitySkillQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEntitySkillOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *entityskillPager) applyOrder(query *EntitySkillQuery, reverse bool) *EntitySkillQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEntitySkillOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEntitySkillOrder.Field.field))
	}
	return query
}

func (p *entityskillPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEntitySkillOrder.Field {
			b.Comma().Ident(DefaultEntitySkillOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EntitySkill.
func (es *EntitySkillQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EntitySkillPaginateOption,
) (*EntitySkillConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEntitySkillPager(opts)
	if err != nil {
		return nil, err
	}
	if es, err = pager.applyFilter(es); err != nil {
		return nil, err
	}
	conn := &EntitySkillConnection{Edges: []*EntitySkillEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = es.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	es = pager.applyCursors(es, after, before)
	es = pager.applyOrder(es, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		es.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := es.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := es.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EntitySkillOrderFieldCreatedAt orders EntitySkill by created_at.
	EntitySkillOrderFieldCreatedAt = &EntitySkillOrderField{
		field: entityskill.FieldCreatedAt,
		toCursor: func(es *EntitySkill) Cursor {
			return Cursor{
				ID:    es.ID,
				Value: es.CreatedAt,
			}
		},
	}
	// EntitySkillOrderFieldUpdatedAt orders EntitySkill by updated_at.
	EntitySkillOrderFieldUpdatedAt = &EntitySkillOrderField{
		field: entityskill.FieldUpdatedAt,
		toCursor: func(es *EntitySkill) Cursor {
			return Cursor{
				ID:    es.ID,
				Value: es.UpdatedAt,
			}
		},
	}
	// EntitySkillOrderFieldDeletedAt orders EntitySkill by deleted_at.
	EntitySkillOrderFieldDeletedAt = &EntitySkillOrderField{
		field: entityskill.FieldDeletedAt,
		toCursor: func(es *EntitySkill) Cursor {
			return Cursor{
				ID:    es.ID,
				Value: es.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EntitySkillOrderField) String() string {
	var str string
	switch f.field {
	case entityskill.FieldCreatedAt:
		str = "created_at"
	case entityskill.FieldUpdatedAt:
		str = "updated_at"
	case entityskill.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EntitySkillOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EntitySkillOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EntitySkillOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *EntitySkillOrderFieldCreatedAt
	case "updated_at":
		*f = *EntitySkillOrderFieldUpdatedAt
	case "deleted_at":
		*f = *EntitySkillOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid EntitySkillOrderField", str)
	}
	return nil
}

// EntitySkillOrderField defines the ordering field of EntitySkill.
type EntitySkillOrderField struct {
	field    string
	toCursor func(*EntitySkill) Cursor
}

// EntitySkillOrder defines the ordering of EntitySkill.
type EntitySkillOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *EntitySkillOrderField `json:"field"`
}

// DefaultEntitySkillOrder is the default ordering of EntitySkill.
var DefaultEntitySkillOrder = &EntitySkillOrder{
	Direction: OrderDirectionAsc,
	Field: &EntitySkillOrderField{
		field: entityskill.FieldID,
		toCursor: func(es *EntitySkill) Cursor {
			return Cursor{ID: es.ID}
		},
	},
}

// ToEdge converts EntitySkill into EntitySkillEdge.
func (es *EntitySkill) ToEdge(order *EntitySkillOrder) *EntitySkillEdge {
	if order == nil {
		order = DefaultEntitySkillOrder
	}
	return &EntitySkillEdge{
		Node:   es,
		Cursor: order.Field.toCursor(es),
	}
}

// HiringJobEdge is the edge representation of HiringJob.
type HiringJobEdge struct {
	Node   *HiringJob `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// HiringJobConnection is the connection containing edges to HiringJob.
type HiringJobConnection struct {
	Edges      []*HiringJobEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *HiringJobConnection) build(nodes []*HiringJob, pager *hiringjobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HiringJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HiringJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HiringJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*HiringJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HiringJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HiringJobPaginateOption enables pagination customization.
type HiringJobPaginateOption func(*hiringjobPager) error

// WithHiringJobOrder configures pagination ordering.
func WithHiringJobOrder(order *HiringJobOrder) HiringJobPaginateOption {
	if order == nil {
		order = DefaultHiringJobOrder
	}
	o := *order
	return func(pager *hiringjobPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHiringJobOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHiringJobFilter configures pagination filter.
func WithHiringJobFilter(filter func(*HiringJobQuery) (*HiringJobQuery, error)) HiringJobPaginateOption {
	return func(pager *hiringjobPager) error {
		if filter == nil {
			return errors.New("HiringJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hiringjobPager struct {
	order  *HiringJobOrder
	filter func(*HiringJobQuery) (*HiringJobQuery, error)
}

func newHiringJobPager(opts []HiringJobPaginateOption) (*hiringjobPager, error) {
	pager := &hiringjobPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHiringJobOrder
	}
	return pager, nil
}

func (p *hiringjobPager) applyFilter(query *HiringJobQuery) (*HiringJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hiringjobPager) toCursor(hj *HiringJob) Cursor {
	return p.order.Field.toCursor(hj)
}

func (p *hiringjobPager) applyCursors(query *HiringJobQuery, after, before *Cursor) *HiringJobQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHiringJobOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hiringjobPager) applyOrder(query *HiringJobQuery, reverse bool) *HiringJobQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHiringJobOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHiringJobOrder.Field.field))
	}
	return query
}

func (p *hiringjobPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHiringJobOrder.Field {
			b.Comma().Ident(DefaultHiringJobOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HiringJob.
func (hj *HiringJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HiringJobPaginateOption,
) (*HiringJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHiringJobPager(opts)
	if err != nil {
		return nil, err
	}
	if hj, err = pager.applyFilter(hj); err != nil {
		return nil, err
	}
	conn := &HiringJobConnection{Edges: []*HiringJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hj.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	hj = pager.applyCursors(hj, after, before)
	hj = pager.applyOrder(hj, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		hj.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hj.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hj.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HiringJobOrderFieldCreatedAt orders HiringJob by created_at.
	HiringJobOrderFieldCreatedAt = &HiringJobOrderField{
		field: hiringjob.FieldCreatedAt,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.CreatedAt,
			}
		},
	}
	// HiringJobOrderFieldUpdatedAt orders HiringJob by updated_at.
	HiringJobOrderFieldUpdatedAt = &HiringJobOrderField{
		field: hiringjob.FieldUpdatedAt,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.UpdatedAt,
			}
		},
	}
	// HiringJobOrderFieldDeletedAt orders HiringJob by deleted_at.
	HiringJobOrderFieldDeletedAt = &HiringJobOrderField{
		field: hiringjob.FieldDeletedAt,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.DeletedAt,
			}
		},
	}
	// HiringJobOrderFieldSlug orders HiringJob by slug.
	HiringJobOrderFieldSlug = &HiringJobOrderField{
		field: hiringjob.FieldSlug,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.Slug,
			}
		},
	}
	// HiringJobOrderFieldName orders HiringJob by name.
	HiringJobOrderFieldName = &HiringJobOrderField{
		field: hiringjob.FieldName,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.Name,
			}
		},
	}
	// HiringJobOrderFieldAmount orders HiringJob by amount.
	HiringJobOrderFieldAmount = &HiringJobOrderField{
		field: hiringjob.FieldAmount,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.Amount,
			}
		},
	}
	// HiringJobOrderFieldSalaryFrom orders HiringJob by salary_from.
	HiringJobOrderFieldSalaryFrom = &HiringJobOrderField{
		field: hiringjob.FieldSalaryFrom,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.SalaryFrom,
			}
		},
	}
	// HiringJobOrderFieldSalaryTo orders HiringJob by salary_to.
	HiringJobOrderFieldSalaryTo = &HiringJobOrderField{
		field: hiringjob.FieldSalaryTo,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.SalaryTo,
			}
		},
	}
	// HiringJobOrderFieldLastApplyDate orders HiringJob by last_apply_date.
	HiringJobOrderFieldLastApplyDate = &HiringJobOrderField{
		field: hiringjob.FieldLastApplyDate,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.LastApplyDate,
			}
		},
	}
	// HiringJobOrderFieldPriority orders HiringJob by priority.
	HiringJobOrderFieldPriority = &HiringJobOrderField{
		field: hiringjob.FieldPriority,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{
				ID:    hj.ID,
				Value: hj.Priority,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HiringJobOrderField) String() string {
	var str string
	switch f.field {
	case hiringjob.FieldCreatedAt:
		str = "created_at"
	case hiringjob.FieldUpdatedAt:
		str = "updated_at"
	case hiringjob.FieldDeletedAt:
		str = "deleted_at"
	case hiringjob.FieldSlug:
		str = "SLUG"
	case hiringjob.FieldName:
		str = "name"
	case hiringjob.FieldAmount:
		str = "amount"
	case hiringjob.FieldSalaryFrom:
		str = "salary_from"
	case hiringjob.FieldSalaryTo:
		str = "salary_to"
	case hiringjob.FieldLastApplyDate:
		str = "last_apply_date"
	case hiringjob.FieldPriority:
		str = "priority"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HiringJobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HiringJobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HiringJobOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *HiringJobOrderFieldCreatedAt
	case "updated_at":
		*f = *HiringJobOrderFieldUpdatedAt
	case "deleted_at":
		*f = *HiringJobOrderFieldDeletedAt
	case "SLUG":
		*f = *HiringJobOrderFieldSlug
	case "name":
		*f = *HiringJobOrderFieldName
	case "amount":
		*f = *HiringJobOrderFieldAmount
	case "salary_from":
		*f = *HiringJobOrderFieldSalaryFrom
	case "salary_to":
		*f = *HiringJobOrderFieldSalaryTo
	case "last_apply_date":
		*f = *HiringJobOrderFieldLastApplyDate
	case "priority":
		*f = *HiringJobOrderFieldPriority
	default:
		return fmt.Errorf("%s is not a valid HiringJobOrderField", str)
	}
	return nil
}

// HiringJobOrderField defines the ordering field of HiringJob.
type HiringJobOrderField struct {
	field    string
	toCursor func(*HiringJob) Cursor
}

// HiringJobOrder defines the ordering of HiringJob.
type HiringJobOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *HiringJobOrderField `json:"field"`
}

// DefaultHiringJobOrder is the default ordering of HiringJob.
var DefaultHiringJobOrder = &HiringJobOrder{
	Direction: OrderDirectionAsc,
	Field: &HiringJobOrderField{
		field: hiringjob.FieldID,
		toCursor: func(hj *HiringJob) Cursor {
			return Cursor{ID: hj.ID}
		},
	},
}

// ToEdge converts HiringJob into HiringJobEdge.
func (hj *HiringJob) ToEdge(order *HiringJobOrder) *HiringJobEdge {
	if order == nil {
		order = DefaultHiringJobOrder
	}
	return &HiringJobEdge{
		Node:   hj,
		Cursor: order.Field.toCursor(hj),
	}
}

// HiringTeamEdge is the edge representation of HiringTeam.
type HiringTeamEdge struct {
	Node   *HiringTeam `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// HiringTeamConnection is the connection containing edges to HiringTeam.
type HiringTeamConnection struct {
	Edges      []*HiringTeamEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *HiringTeamConnection) build(nodes []*HiringTeam, pager *hiringteamPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HiringTeam
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HiringTeam {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HiringTeam {
			return nodes[i]
		}
	}
	c.Edges = make([]*HiringTeamEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HiringTeamEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HiringTeamPaginateOption enables pagination customization.
type HiringTeamPaginateOption func(*hiringteamPager) error

// WithHiringTeamOrder configures pagination ordering.
func WithHiringTeamOrder(order *HiringTeamOrder) HiringTeamPaginateOption {
	if order == nil {
		order = DefaultHiringTeamOrder
	}
	o := *order
	return func(pager *hiringteamPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHiringTeamOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHiringTeamFilter configures pagination filter.
func WithHiringTeamFilter(filter func(*HiringTeamQuery) (*HiringTeamQuery, error)) HiringTeamPaginateOption {
	return func(pager *hiringteamPager) error {
		if filter == nil {
			return errors.New("HiringTeamQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hiringteamPager struct {
	order  *HiringTeamOrder
	filter func(*HiringTeamQuery) (*HiringTeamQuery, error)
}

func newHiringTeamPager(opts []HiringTeamPaginateOption) (*hiringteamPager, error) {
	pager := &hiringteamPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHiringTeamOrder
	}
	return pager, nil
}

func (p *hiringteamPager) applyFilter(query *HiringTeamQuery) (*HiringTeamQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hiringteamPager) toCursor(ht *HiringTeam) Cursor {
	return p.order.Field.toCursor(ht)
}

func (p *hiringteamPager) applyCursors(query *HiringTeamQuery, after, before *Cursor) *HiringTeamQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHiringTeamOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hiringteamPager) applyOrder(query *HiringTeamQuery, reverse bool) *HiringTeamQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHiringTeamOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHiringTeamOrder.Field.field))
	}
	return query
}

func (p *hiringteamPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHiringTeamOrder.Field {
			b.Comma().Ident(DefaultHiringTeamOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HiringTeam.
func (ht *HiringTeamQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HiringTeamPaginateOption,
) (*HiringTeamConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHiringTeamPager(opts)
	if err != nil {
		return nil, err
	}
	if ht, err = pager.applyFilter(ht); err != nil {
		return nil, err
	}
	conn := &HiringTeamConnection{Edges: []*HiringTeamEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ht.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ht = pager.applyCursors(ht, after, before)
	ht = pager.applyOrder(ht, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ht.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ht.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ht.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HiringTeamOrderFieldCreatedAt orders HiringTeam by created_at.
	HiringTeamOrderFieldCreatedAt = &HiringTeamOrderField{
		field: hiringteam.FieldCreatedAt,
		toCursor: func(ht *HiringTeam) Cursor {
			return Cursor{
				ID:    ht.ID,
				Value: ht.CreatedAt,
			}
		},
	}
	// HiringTeamOrderFieldUpdatedAt orders HiringTeam by updated_at.
	HiringTeamOrderFieldUpdatedAt = &HiringTeamOrderField{
		field: hiringteam.FieldUpdatedAt,
		toCursor: func(ht *HiringTeam) Cursor {
			return Cursor{
				ID:    ht.ID,
				Value: ht.UpdatedAt,
			}
		},
	}
	// HiringTeamOrderFieldDeletedAt orders HiringTeam by deleted_at.
	HiringTeamOrderFieldDeletedAt = &HiringTeamOrderField{
		field: hiringteam.FieldDeletedAt,
		toCursor: func(ht *HiringTeam) Cursor {
			return Cursor{
				ID:    ht.ID,
				Value: ht.DeletedAt,
			}
		},
	}
	// HiringTeamOrderFieldSlug orders HiringTeam by slug.
	HiringTeamOrderFieldSlug = &HiringTeamOrderField{
		field: hiringteam.FieldSlug,
		toCursor: func(ht *HiringTeam) Cursor {
			return Cursor{
				ID:    ht.ID,
				Value: ht.Slug,
			}
		},
	}
	// HiringTeamOrderFieldName orders HiringTeam by name.
	HiringTeamOrderFieldName = &HiringTeamOrderField{
		field: hiringteam.FieldName,
		toCursor: func(ht *HiringTeam) Cursor {
			return Cursor{
				ID:    ht.ID,
				Value: ht.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HiringTeamOrderField) String() string {
	var str string
	switch f.field {
	case hiringteam.FieldCreatedAt:
		str = "created_at"
	case hiringteam.FieldUpdatedAt:
		str = "updated_at"
	case hiringteam.FieldDeletedAt:
		str = "deleted_at"
	case hiringteam.FieldSlug:
		str = "SLUG"
	case hiringteam.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HiringTeamOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HiringTeamOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HiringTeamOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *HiringTeamOrderFieldCreatedAt
	case "updated_at":
		*f = *HiringTeamOrderFieldUpdatedAt
	case "deleted_at":
		*f = *HiringTeamOrderFieldDeletedAt
	case "SLUG":
		*f = *HiringTeamOrderFieldSlug
	case "name":
		*f = *HiringTeamOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid HiringTeamOrderField", str)
	}
	return nil
}

// HiringTeamOrderField defines the ordering field of HiringTeam.
type HiringTeamOrderField struct {
	field    string
	toCursor func(*HiringTeam) Cursor
}

// HiringTeamOrder defines the ordering of HiringTeam.
type HiringTeamOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *HiringTeamOrderField `json:"field"`
}

// DefaultHiringTeamOrder is the default ordering of HiringTeam.
var DefaultHiringTeamOrder = &HiringTeamOrder{
	Direction: OrderDirectionAsc,
	Field: &HiringTeamOrderField{
		field: hiringteam.FieldID,
		toCursor: func(ht *HiringTeam) Cursor {
			return Cursor{ID: ht.ID}
		},
	},
}

// ToEdge converts HiringTeam into HiringTeamEdge.
func (ht *HiringTeam) ToEdge(order *HiringTeamOrder) *HiringTeamEdge {
	if order == nil {
		order = DefaultHiringTeamOrder
	}
	return &HiringTeamEdge{
		Node:   ht,
		Cursor: order.Field.toCursor(ht),
	}
}

// HiringTeamApproverEdge is the edge representation of HiringTeamApprover.
type HiringTeamApproverEdge struct {
	Node   *HiringTeamApprover `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// HiringTeamApproverConnection is the connection containing edges to HiringTeamApprover.
type HiringTeamApproverConnection struct {
	Edges      []*HiringTeamApproverEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *HiringTeamApproverConnection) build(nodes []*HiringTeamApprover, pager *hiringteamapproverPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HiringTeamApprover
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HiringTeamApprover {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HiringTeamApprover {
			return nodes[i]
		}
	}
	c.Edges = make([]*HiringTeamApproverEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HiringTeamApproverEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HiringTeamApproverPaginateOption enables pagination customization.
type HiringTeamApproverPaginateOption func(*hiringteamapproverPager) error

// WithHiringTeamApproverOrder configures pagination ordering.
func WithHiringTeamApproverOrder(order *HiringTeamApproverOrder) HiringTeamApproverPaginateOption {
	if order == nil {
		order = DefaultHiringTeamApproverOrder
	}
	o := *order
	return func(pager *hiringteamapproverPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHiringTeamApproverOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHiringTeamApproverFilter configures pagination filter.
func WithHiringTeamApproverFilter(filter func(*HiringTeamApproverQuery) (*HiringTeamApproverQuery, error)) HiringTeamApproverPaginateOption {
	return func(pager *hiringteamapproverPager) error {
		if filter == nil {
			return errors.New("HiringTeamApproverQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hiringteamapproverPager struct {
	order  *HiringTeamApproverOrder
	filter func(*HiringTeamApproverQuery) (*HiringTeamApproverQuery, error)
}

func newHiringTeamApproverPager(opts []HiringTeamApproverPaginateOption) (*hiringteamapproverPager, error) {
	pager := &hiringteamapproverPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHiringTeamApproverOrder
	}
	return pager, nil
}

func (p *hiringteamapproverPager) applyFilter(query *HiringTeamApproverQuery) (*HiringTeamApproverQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hiringteamapproverPager) toCursor(hta *HiringTeamApprover) Cursor {
	return p.order.Field.toCursor(hta)
}

func (p *hiringteamapproverPager) applyCursors(query *HiringTeamApproverQuery, after, before *Cursor) *HiringTeamApproverQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHiringTeamApproverOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hiringteamapproverPager) applyOrder(query *HiringTeamApproverQuery, reverse bool) *HiringTeamApproverQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHiringTeamApproverOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHiringTeamApproverOrder.Field.field))
	}
	return query
}

func (p *hiringteamapproverPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHiringTeamApproverOrder.Field {
			b.Comma().Ident(DefaultHiringTeamApproverOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HiringTeamApprover.
func (hta *HiringTeamApproverQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HiringTeamApproverPaginateOption,
) (*HiringTeamApproverConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHiringTeamApproverPager(opts)
	if err != nil {
		return nil, err
	}
	if hta, err = pager.applyFilter(hta); err != nil {
		return nil, err
	}
	conn := &HiringTeamApproverConnection{Edges: []*HiringTeamApproverEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hta.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	hta = pager.applyCursors(hta, after, before)
	hta = pager.applyOrder(hta, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		hta.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hta.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := hta.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HiringTeamApproverOrderFieldCreatedAt orders HiringTeamApprover by created_at.
	HiringTeamApproverOrderFieldCreatedAt = &HiringTeamApproverOrderField{
		field: hiringteamapprover.FieldCreatedAt,
		toCursor: func(hta *HiringTeamApprover) Cursor {
			return Cursor{
				ID:    hta.ID,
				Value: hta.CreatedAt,
			}
		},
	}
	// HiringTeamApproverOrderFieldUpdatedAt orders HiringTeamApprover by updated_at.
	HiringTeamApproverOrderFieldUpdatedAt = &HiringTeamApproverOrderField{
		field: hiringteamapprover.FieldUpdatedAt,
		toCursor: func(hta *HiringTeamApprover) Cursor {
			return Cursor{
				ID:    hta.ID,
				Value: hta.UpdatedAt,
			}
		},
	}
	// HiringTeamApproverOrderFieldDeletedAt orders HiringTeamApprover by deleted_at.
	HiringTeamApproverOrderFieldDeletedAt = &HiringTeamApproverOrderField{
		field: hiringteamapprover.FieldDeletedAt,
		toCursor: func(hta *HiringTeamApprover) Cursor {
			return Cursor{
				ID:    hta.ID,
				Value: hta.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HiringTeamApproverOrderField) String() string {
	var str string
	switch f.field {
	case hiringteamapprover.FieldCreatedAt:
		str = "created_at"
	case hiringteamapprover.FieldUpdatedAt:
		str = "updated_at"
	case hiringteamapprover.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HiringTeamApproverOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HiringTeamApproverOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HiringTeamApproverOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *HiringTeamApproverOrderFieldCreatedAt
	case "updated_at":
		*f = *HiringTeamApproverOrderFieldUpdatedAt
	case "deleted_at":
		*f = *HiringTeamApproverOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid HiringTeamApproverOrderField", str)
	}
	return nil
}

// HiringTeamApproverOrderField defines the ordering field of HiringTeamApprover.
type HiringTeamApproverOrderField struct {
	field    string
	toCursor func(*HiringTeamApprover) Cursor
}

// HiringTeamApproverOrder defines the ordering of HiringTeamApprover.
type HiringTeamApproverOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *HiringTeamApproverOrderField `json:"field"`
}

// DefaultHiringTeamApproverOrder is the default ordering of HiringTeamApprover.
var DefaultHiringTeamApproverOrder = &HiringTeamApproverOrder{
	Direction: OrderDirectionAsc,
	Field: &HiringTeamApproverOrderField{
		field: hiringteamapprover.FieldID,
		toCursor: func(hta *HiringTeamApprover) Cursor {
			return Cursor{ID: hta.ID}
		},
	},
}

// ToEdge converts HiringTeamApprover into HiringTeamApproverEdge.
func (hta *HiringTeamApprover) ToEdge(order *HiringTeamApproverOrder) *HiringTeamApproverEdge {
	if order == nil {
		order = DefaultHiringTeamApproverOrder
	}
	return &HiringTeamApproverEdge{
		Node:   hta,
		Cursor: order.Field.toCursor(hta),
	}
}

// HiringTeamManagerEdge is the edge representation of HiringTeamManager.
type HiringTeamManagerEdge struct {
	Node   *HiringTeamManager `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// HiringTeamManagerConnection is the connection containing edges to HiringTeamManager.
type HiringTeamManagerConnection struct {
	Edges      []*HiringTeamManagerEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *HiringTeamManagerConnection) build(nodes []*HiringTeamManager, pager *hiringteammanagerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HiringTeamManager
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HiringTeamManager {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HiringTeamManager {
			return nodes[i]
		}
	}
	c.Edges = make([]*HiringTeamManagerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HiringTeamManagerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HiringTeamManagerPaginateOption enables pagination customization.
type HiringTeamManagerPaginateOption func(*hiringteammanagerPager) error

// WithHiringTeamManagerOrder configures pagination ordering.
func WithHiringTeamManagerOrder(order *HiringTeamManagerOrder) HiringTeamManagerPaginateOption {
	if order == nil {
		order = DefaultHiringTeamManagerOrder
	}
	o := *order
	return func(pager *hiringteammanagerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHiringTeamManagerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHiringTeamManagerFilter configures pagination filter.
func WithHiringTeamManagerFilter(filter func(*HiringTeamManagerQuery) (*HiringTeamManagerQuery, error)) HiringTeamManagerPaginateOption {
	return func(pager *hiringteammanagerPager) error {
		if filter == nil {
			return errors.New("HiringTeamManagerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hiringteammanagerPager struct {
	order  *HiringTeamManagerOrder
	filter func(*HiringTeamManagerQuery) (*HiringTeamManagerQuery, error)
}

func newHiringTeamManagerPager(opts []HiringTeamManagerPaginateOption) (*hiringteammanagerPager, error) {
	pager := &hiringteammanagerPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHiringTeamManagerOrder
	}
	return pager, nil
}

func (p *hiringteammanagerPager) applyFilter(query *HiringTeamManagerQuery) (*HiringTeamManagerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hiringteammanagerPager) toCursor(htm *HiringTeamManager) Cursor {
	return p.order.Field.toCursor(htm)
}

func (p *hiringteammanagerPager) applyCursors(query *HiringTeamManagerQuery, after, before *Cursor) *HiringTeamManagerQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultHiringTeamManagerOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *hiringteammanagerPager) applyOrder(query *HiringTeamManagerQuery, reverse bool) *HiringTeamManagerQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultHiringTeamManagerOrder.Field {
		query = query.Order(direction.orderFunc(DefaultHiringTeamManagerOrder.Field.field))
	}
	return query
}

func (p *hiringteammanagerPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHiringTeamManagerOrder.Field {
			b.Comma().Ident(DefaultHiringTeamManagerOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HiringTeamManager.
func (htm *HiringTeamManagerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HiringTeamManagerPaginateOption,
) (*HiringTeamManagerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHiringTeamManagerPager(opts)
	if err != nil {
		return nil, err
	}
	if htm, err = pager.applyFilter(htm); err != nil {
		return nil, err
	}
	conn := &HiringTeamManagerConnection{Edges: []*HiringTeamManagerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = htm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	htm = pager.applyCursors(htm, after, before)
	htm = pager.applyOrder(htm, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		htm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := htm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := htm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HiringTeamManagerOrderFieldCreatedAt orders HiringTeamManager by created_at.
	HiringTeamManagerOrderFieldCreatedAt = &HiringTeamManagerOrderField{
		field: hiringteammanager.FieldCreatedAt,
		toCursor: func(htm *HiringTeamManager) Cursor {
			return Cursor{
				ID:    htm.ID,
				Value: htm.CreatedAt,
			}
		},
	}
	// HiringTeamManagerOrderFieldUpdatedAt orders HiringTeamManager by updated_at.
	HiringTeamManagerOrderFieldUpdatedAt = &HiringTeamManagerOrderField{
		field: hiringteammanager.FieldUpdatedAt,
		toCursor: func(htm *HiringTeamManager) Cursor {
			return Cursor{
				ID:    htm.ID,
				Value: htm.UpdatedAt,
			}
		},
	}
	// HiringTeamManagerOrderFieldDeletedAt orders HiringTeamManager by deleted_at.
	HiringTeamManagerOrderFieldDeletedAt = &HiringTeamManagerOrderField{
		field: hiringteammanager.FieldDeletedAt,
		toCursor: func(htm *HiringTeamManager) Cursor {
			return Cursor{
				ID:    htm.ID,
				Value: htm.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HiringTeamManagerOrderField) String() string {
	var str string
	switch f.field {
	case hiringteammanager.FieldCreatedAt:
		str = "created_at"
	case hiringteammanager.FieldUpdatedAt:
		str = "updated_at"
	case hiringteammanager.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HiringTeamManagerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HiringTeamManagerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HiringTeamManagerOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *HiringTeamManagerOrderFieldCreatedAt
	case "updated_at":
		*f = *HiringTeamManagerOrderFieldUpdatedAt
	case "deleted_at":
		*f = *HiringTeamManagerOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid HiringTeamManagerOrderField", str)
	}
	return nil
}

// HiringTeamManagerOrderField defines the ordering field of HiringTeamManager.
type HiringTeamManagerOrderField struct {
	field    string
	toCursor func(*HiringTeamManager) Cursor
}

// HiringTeamManagerOrder defines the ordering of HiringTeamManager.
type HiringTeamManagerOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *HiringTeamManagerOrderField `json:"field"`
}

// DefaultHiringTeamManagerOrder is the default ordering of HiringTeamManager.
var DefaultHiringTeamManagerOrder = &HiringTeamManagerOrder{
	Direction: OrderDirectionAsc,
	Field: &HiringTeamManagerOrderField{
		field: hiringteammanager.FieldID,
		toCursor: func(htm *HiringTeamManager) Cursor {
			return Cursor{ID: htm.ID}
		},
	},
}

// ToEdge converts HiringTeamManager into HiringTeamManagerEdge.
func (htm *HiringTeamManager) ToEdge(order *HiringTeamManagerOrder) *HiringTeamManagerEdge {
	if order == nil {
		order = DefaultHiringTeamManagerOrder
	}
	return &HiringTeamManagerEdge{
		Node:   htm,
		Cursor: order.Field.toCursor(htm),
	}
}

// JobPositionEdge is the edge representation of JobPosition.
type JobPositionEdge struct {
	Node   *JobPosition `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobPositionConnection is the connection containing edges to JobPosition.
type JobPositionConnection struct {
	Edges      []*JobPositionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobPositionConnection) build(nodes []*JobPosition, pager *jobpositionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobPosition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobPosition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobPosition {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobPositionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobPositionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobPositionPaginateOption enables pagination customization.
type JobPositionPaginateOption func(*jobpositionPager) error

// WithJobPositionOrder configures pagination ordering.
func WithJobPositionOrder(order *JobPositionOrder) JobPositionPaginateOption {
	if order == nil {
		order = DefaultJobPositionOrder
	}
	o := *order
	return func(pager *jobpositionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobPositionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobPositionFilter configures pagination filter.
func WithJobPositionFilter(filter func(*JobPositionQuery) (*JobPositionQuery, error)) JobPositionPaginateOption {
	return func(pager *jobpositionPager) error {
		if filter == nil {
			return errors.New("JobPositionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobpositionPager struct {
	order  *JobPositionOrder
	filter func(*JobPositionQuery) (*JobPositionQuery, error)
}

func newJobPositionPager(opts []JobPositionPaginateOption) (*jobpositionPager, error) {
	pager := &jobpositionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobPositionOrder
	}
	return pager, nil
}

func (p *jobpositionPager) applyFilter(query *JobPositionQuery) (*JobPositionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobpositionPager) toCursor(jp *JobPosition) Cursor {
	return p.order.Field.toCursor(jp)
}

func (p *jobpositionPager) applyCursors(query *JobPositionQuery, after, before *Cursor) *JobPositionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultJobPositionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *jobpositionPager) applyOrder(query *JobPositionQuery, reverse bool) *JobPositionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultJobPositionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultJobPositionOrder.Field.field))
	}
	return query
}

func (p *jobpositionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobPositionOrder.Field {
			b.Comma().Ident(DefaultJobPositionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobPosition.
func (jp *JobPositionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobPositionPaginateOption,
) (*JobPositionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobPositionPager(opts)
	if err != nil {
		return nil, err
	}
	if jp, err = pager.applyFilter(jp); err != nil {
		return nil, err
	}
	conn := &JobPositionConnection{Edges: []*JobPositionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = jp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	jp = pager.applyCursors(jp, after, before)
	jp = pager.applyOrder(jp, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		jp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := jp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobPositionOrderFieldCreatedAt orders JobPosition by created_at.
	JobPositionOrderFieldCreatedAt = &JobPositionOrderField{
		field: jobposition.FieldCreatedAt,
		toCursor: func(jp *JobPosition) Cursor {
			return Cursor{
				ID:    jp.ID,
				Value: jp.CreatedAt,
			}
		},
	}
	// JobPositionOrderFieldUpdatedAt orders JobPosition by updated_at.
	JobPositionOrderFieldUpdatedAt = &JobPositionOrderField{
		field: jobposition.FieldUpdatedAt,
		toCursor: func(jp *JobPosition) Cursor {
			return Cursor{
				ID:    jp.ID,
				Value: jp.UpdatedAt,
			}
		},
	}
	// JobPositionOrderFieldDeletedAt orders JobPosition by deleted_at.
	JobPositionOrderFieldDeletedAt = &JobPositionOrderField{
		field: jobposition.FieldDeletedAt,
		toCursor: func(jp *JobPosition) Cursor {
			return Cursor{
				ID:    jp.ID,
				Value: jp.DeletedAt,
			}
		},
	}
	// JobPositionOrderFieldName orders JobPosition by name.
	JobPositionOrderFieldName = &JobPositionOrderField{
		field: jobposition.FieldName,
		toCursor: func(jp *JobPosition) Cursor {
			return Cursor{
				ID:    jp.ID,
				Value: jp.Name,
			}
		},
	}
	// JobPositionOrderFieldDescription orders JobPosition by description.
	JobPositionOrderFieldDescription = &JobPositionOrderField{
		field: jobposition.FieldDescription,
		toCursor: func(jp *JobPosition) Cursor {
			return Cursor{
				ID:    jp.ID,
				Value: jp.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobPositionOrderField) String() string {
	var str string
	switch f.field {
	case jobposition.FieldCreatedAt:
		str = "created_at"
	case jobposition.FieldUpdatedAt:
		str = "updated_at"
	case jobposition.FieldDeletedAt:
		str = "deleted_at"
	case jobposition.FieldName:
		str = "name"
	case jobposition.FieldDescription:
		str = "description"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobPositionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobPositionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobPositionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *JobPositionOrderFieldCreatedAt
	case "updated_at":
		*f = *JobPositionOrderFieldUpdatedAt
	case "deleted_at":
		*f = *JobPositionOrderFieldDeletedAt
	case "name":
		*f = *JobPositionOrderFieldName
	case "description":
		*f = *JobPositionOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid JobPositionOrderField", str)
	}
	return nil
}

// JobPositionOrderField defines the ordering field of JobPosition.
type JobPositionOrderField struct {
	field    string
	toCursor func(*JobPosition) Cursor
}

// JobPositionOrder defines the ordering of JobPosition.
type JobPositionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobPositionOrderField `json:"field"`
}

// DefaultJobPositionOrder is the default ordering of JobPosition.
var DefaultJobPositionOrder = &JobPositionOrder{
	Direction: OrderDirectionAsc,
	Field: &JobPositionOrderField{
		field: jobposition.FieldID,
		toCursor: func(jp *JobPosition) Cursor {
			return Cursor{ID: jp.ID}
		},
	},
}

// ToEdge converts JobPosition into JobPositionEdge.
func (jp *JobPosition) ToEdge(order *JobPositionOrder) *JobPositionEdge {
	if order == nil {
		order = DefaultJobPositionOrder
	}
	return &JobPositionEdge{
		Node:   jp,
		Cursor: order.Field.toCursor(jp),
	}
}

// OutgoingEmailEdge is the edge representation of OutgoingEmail.
type OutgoingEmailEdge struct {
	Node   *OutgoingEmail `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// OutgoingEmailConnection is the connection containing edges to OutgoingEmail.
type OutgoingEmailConnection struct {
	Edges      []*OutgoingEmailEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *OutgoingEmailConnection) build(nodes []*OutgoingEmail, pager *outgoingemailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OutgoingEmail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OutgoingEmail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OutgoingEmail {
			return nodes[i]
		}
	}
	c.Edges = make([]*OutgoingEmailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OutgoingEmailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OutgoingEmailPaginateOption enables pagination customization.
type OutgoingEmailPaginateOption func(*outgoingemailPager) error

// WithOutgoingEmailOrder configures pagination ordering.
func WithOutgoingEmailOrder(order *OutgoingEmailOrder) OutgoingEmailPaginateOption {
	if order == nil {
		order = DefaultOutgoingEmailOrder
	}
	o := *order
	return func(pager *outgoingemailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOutgoingEmailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOutgoingEmailFilter configures pagination filter.
func WithOutgoingEmailFilter(filter func(*OutgoingEmailQuery) (*OutgoingEmailQuery, error)) OutgoingEmailPaginateOption {
	return func(pager *outgoingemailPager) error {
		if filter == nil {
			return errors.New("OutgoingEmailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type outgoingemailPager struct {
	order  *OutgoingEmailOrder
	filter func(*OutgoingEmailQuery) (*OutgoingEmailQuery, error)
}

func newOutgoingEmailPager(opts []OutgoingEmailPaginateOption) (*outgoingemailPager, error) {
	pager := &outgoingemailPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOutgoingEmailOrder
	}
	return pager, nil
}

func (p *outgoingemailPager) applyFilter(query *OutgoingEmailQuery) (*OutgoingEmailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *outgoingemailPager) toCursor(oe *OutgoingEmail) Cursor {
	return p.order.Field.toCursor(oe)
}

func (p *outgoingemailPager) applyCursors(query *OutgoingEmailQuery, after, before *Cursor) *OutgoingEmailQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultOutgoingEmailOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *outgoingemailPager) applyOrder(query *OutgoingEmailQuery, reverse bool) *OutgoingEmailQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultOutgoingEmailOrder.Field {
		query = query.Order(direction.orderFunc(DefaultOutgoingEmailOrder.Field.field))
	}
	return query
}

func (p *outgoingemailPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOutgoingEmailOrder.Field {
			b.Comma().Ident(DefaultOutgoingEmailOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OutgoingEmail.
func (oe *OutgoingEmailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OutgoingEmailPaginateOption,
) (*OutgoingEmailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOutgoingEmailPager(opts)
	if err != nil {
		return nil, err
	}
	if oe, err = pager.applyFilter(oe); err != nil {
		return nil, err
	}
	conn := &OutgoingEmailConnection{Edges: []*OutgoingEmailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = oe.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	oe = pager.applyCursors(oe, after, before)
	oe = pager.applyOrder(oe, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		oe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := oe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := oe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OutgoingEmailOrderFieldCreatedAt orders OutgoingEmail by created_at.
	OutgoingEmailOrderFieldCreatedAt = &OutgoingEmailOrderField{
		field: outgoingemail.FieldCreatedAt,
		toCursor: func(oe *OutgoingEmail) Cursor {
			return Cursor{
				ID:    oe.ID,
				Value: oe.CreatedAt,
			}
		},
	}
	// OutgoingEmailOrderFieldUpdatedAt orders OutgoingEmail by updated_at.
	OutgoingEmailOrderFieldUpdatedAt = &OutgoingEmailOrderField{
		field: outgoingemail.FieldUpdatedAt,
		toCursor: func(oe *OutgoingEmail) Cursor {
			return Cursor{
				ID:    oe.ID,
				Value: oe.UpdatedAt,
			}
		},
	}
	// OutgoingEmailOrderFieldDeletedAt orders OutgoingEmail by deleted_at.
	OutgoingEmailOrderFieldDeletedAt = &OutgoingEmailOrderField{
		field: outgoingemail.FieldDeletedAt,
		toCursor: func(oe *OutgoingEmail) Cursor {
			return Cursor{
				ID:    oe.ID,
				Value: oe.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OutgoingEmailOrderField) String() string {
	var str string
	switch f.field {
	case outgoingemail.FieldCreatedAt:
		str = "created_at"
	case outgoingemail.FieldUpdatedAt:
		str = "updated_at"
	case outgoingemail.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OutgoingEmailOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OutgoingEmailOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OutgoingEmailOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *OutgoingEmailOrderFieldCreatedAt
	case "updated_at":
		*f = *OutgoingEmailOrderFieldUpdatedAt
	case "deleted_at":
		*f = *OutgoingEmailOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid OutgoingEmailOrderField", str)
	}
	return nil
}

// OutgoingEmailOrderField defines the ordering field of OutgoingEmail.
type OutgoingEmailOrderField struct {
	field    string
	toCursor func(*OutgoingEmail) Cursor
}

// OutgoingEmailOrder defines the ordering of OutgoingEmail.
type OutgoingEmailOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *OutgoingEmailOrderField `json:"field"`
}

// DefaultOutgoingEmailOrder is the default ordering of OutgoingEmail.
var DefaultOutgoingEmailOrder = &OutgoingEmailOrder{
	Direction: OrderDirectionAsc,
	Field: &OutgoingEmailOrderField{
		field: outgoingemail.FieldID,
		toCursor: func(oe *OutgoingEmail) Cursor {
			return Cursor{ID: oe.ID}
		},
	},
}

// ToEdge converts OutgoingEmail into OutgoingEmailEdge.
func (oe *OutgoingEmail) ToEdge(order *OutgoingEmailOrder) *OutgoingEmailEdge {
	if order == nil {
		order = DefaultOutgoingEmailOrder
	}
	return &OutgoingEmailEdge{
		Node:   oe,
		Cursor: order.Field.toCursor(oe),
	}
}

// PermissionEdge is the edge representation of Permission.
type PermissionEdge struct {
	Node   *Permission `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// PermissionConnection is the connection containing edges to Permission.
type PermissionConnection struct {
	Edges      []*PermissionEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *PermissionConnection) build(nodes []*Permission, pager *permissionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Permission
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Permission {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Permission {
			return nodes[i]
		}
	}
	c.Edges = make([]*PermissionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PermissionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PermissionPaginateOption enables pagination customization.
type PermissionPaginateOption func(*permissionPager) error

// WithPermissionOrder configures pagination ordering.
func WithPermissionOrder(order *PermissionOrder) PermissionPaginateOption {
	if order == nil {
		order = DefaultPermissionOrder
	}
	o := *order
	return func(pager *permissionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPermissionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPermissionFilter configures pagination filter.
func WithPermissionFilter(filter func(*PermissionQuery) (*PermissionQuery, error)) PermissionPaginateOption {
	return func(pager *permissionPager) error {
		if filter == nil {
			return errors.New("PermissionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type permissionPager struct {
	order  *PermissionOrder
	filter func(*PermissionQuery) (*PermissionQuery, error)
}

func newPermissionPager(opts []PermissionPaginateOption) (*permissionPager, error) {
	pager := &permissionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPermissionOrder
	}
	return pager, nil
}

func (p *permissionPager) applyFilter(query *PermissionQuery) (*PermissionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *permissionPager) toCursor(pe *Permission) Cursor {
	return p.order.Field.toCursor(pe)
}

func (p *permissionPager) applyCursors(query *PermissionQuery, after, before *Cursor) *PermissionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPermissionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *permissionPager) applyOrder(query *PermissionQuery, reverse bool) *PermissionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPermissionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPermissionOrder.Field.field))
	}
	return query
}

func (p *permissionPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPermissionOrder.Field {
			b.Comma().Ident(DefaultPermissionOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Permission.
func (pe *PermissionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PermissionPaginateOption,
) (*PermissionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPermissionPager(opts)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PermissionConnection{Edges: []*PermissionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pe.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	pe = pager.applyCursors(pe, after, before)
	pe = pager.applyOrder(pe, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PermissionOrderFieldCreatedAt orders Permission by created_at.
	PermissionOrderFieldCreatedAt = &PermissionOrderField{
		field: permission.FieldCreatedAt,
		toCursor: func(pe *Permission) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.CreatedAt,
			}
		},
	}
	// PermissionOrderFieldUpdatedAt orders Permission by updated_at.
	PermissionOrderFieldUpdatedAt = &PermissionOrderField{
		field: permission.FieldUpdatedAt,
		toCursor: func(pe *Permission) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.UpdatedAt,
			}
		},
	}
	// PermissionOrderFieldDeletedAt orders Permission by deleted_at.
	PermissionOrderFieldDeletedAt = &PermissionOrderField{
		field: permission.FieldDeletedAt,
		toCursor: func(pe *Permission) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.DeletedAt,
			}
		},
	}
	// PermissionOrderFieldTitle orders Permission by title.
	PermissionOrderFieldTitle = &PermissionOrderField{
		field: permission.FieldTitle,
		toCursor: func(pe *Permission) Cursor {
			return Cursor{
				ID:    pe.ID,
				Value: pe.Title,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PermissionOrderField) String() string {
	var str string
	switch f.field {
	case permission.FieldCreatedAt:
		str = "created_at"
	case permission.FieldUpdatedAt:
		str = "updated_at"
	case permission.FieldDeletedAt:
		str = "deleted_at"
	case permission.FieldTitle:
		str = "title"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PermissionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PermissionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PermissionOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *PermissionOrderFieldCreatedAt
	case "updated_at":
		*f = *PermissionOrderFieldUpdatedAt
	case "deleted_at":
		*f = *PermissionOrderFieldDeletedAt
	case "title":
		*f = *PermissionOrderFieldTitle
	default:
		return fmt.Errorf("%s is not a valid PermissionOrderField", str)
	}
	return nil
}

// PermissionOrderField defines the ordering field of Permission.
type PermissionOrderField struct {
	field    string
	toCursor func(*Permission) Cursor
}

// PermissionOrder defines the ordering of Permission.
type PermissionOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *PermissionOrderField `json:"field"`
}

// DefaultPermissionOrder is the default ordering of Permission.
var DefaultPermissionOrder = &PermissionOrder{
	Direction: OrderDirectionAsc,
	Field: &PermissionOrderField{
		field: permission.FieldID,
		toCursor: func(pe *Permission) Cursor {
			return Cursor{ID: pe.ID}
		},
	},
}

// ToEdge converts Permission into PermissionEdge.
func (pe *Permission) ToEdge(order *PermissionOrder) *PermissionEdge {
	if order == nil {
		order = DefaultPermissionOrder
	}
	return &PermissionEdge{
		Node:   pe,
		Cursor: order.Field.toCursor(pe),
	}
}

// PermissionGroupEdge is the edge representation of PermissionGroup.
type PermissionGroupEdge struct {
	Node   *PermissionGroup `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// PermissionGroupConnection is the connection containing edges to PermissionGroup.
type PermissionGroupConnection struct {
	Edges      []*PermissionGroupEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *PermissionGroupConnection) build(nodes []*PermissionGroup, pager *permissiongroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PermissionGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PermissionGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PermissionGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*PermissionGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PermissionGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PermissionGroupPaginateOption enables pagination customization.
type PermissionGroupPaginateOption func(*permissiongroupPager) error

// WithPermissionGroupOrder configures pagination ordering.
func WithPermissionGroupOrder(order *PermissionGroupOrder) PermissionGroupPaginateOption {
	if order == nil {
		order = DefaultPermissionGroupOrder
	}
	o := *order
	return func(pager *permissiongroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPermissionGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPermissionGroupFilter configures pagination filter.
func WithPermissionGroupFilter(filter func(*PermissionGroupQuery) (*PermissionGroupQuery, error)) PermissionGroupPaginateOption {
	return func(pager *permissiongroupPager) error {
		if filter == nil {
			return errors.New("PermissionGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type permissiongroupPager struct {
	order  *PermissionGroupOrder
	filter func(*PermissionGroupQuery) (*PermissionGroupQuery, error)
}

func newPermissionGroupPager(opts []PermissionGroupPaginateOption) (*permissiongroupPager, error) {
	pager := &permissiongroupPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPermissionGroupOrder
	}
	return pager, nil
}

func (p *permissiongroupPager) applyFilter(query *PermissionGroupQuery) (*PermissionGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *permissiongroupPager) toCursor(pg *PermissionGroup) Cursor {
	return p.order.Field.toCursor(pg)
}

func (p *permissiongroupPager) applyCursors(query *PermissionGroupQuery, after, before *Cursor) *PermissionGroupQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPermissionGroupOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *permissiongroupPager) applyOrder(query *PermissionGroupQuery, reverse bool) *PermissionGroupQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPermissionGroupOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPermissionGroupOrder.Field.field))
	}
	return query
}

func (p *permissiongroupPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPermissionGroupOrder.Field {
			b.Comma().Ident(DefaultPermissionGroupOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PermissionGroup.
func (pg *PermissionGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PermissionGroupPaginateOption,
) (*PermissionGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPermissionGroupPager(opts)
	if err != nil {
		return nil, err
	}
	if pg, err = pager.applyFilter(pg); err != nil {
		return nil, err
	}
	conn := &PermissionGroupConnection{Edges: []*PermissionGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pg.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	pg = pager.applyCursors(pg, after, before)
	pg = pager.applyOrder(pg, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		pg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pg.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PermissionGroupOrderFieldCreatedAt orders PermissionGroup by created_at.
	PermissionGroupOrderFieldCreatedAt = &PermissionGroupOrderField{
		field: permissiongroup.FieldCreatedAt,
		toCursor: func(pg *PermissionGroup) Cursor {
			return Cursor{
				ID:    pg.ID,
				Value: pg.CreatedAt,
			}
		},
	}
	// PermissionGroupOrderFieldUpdatedAt orders PermissionGroup by updated_at.
	PermissionGroupOrderFieldUpdatedAt = &PermissionGroupOrderField{
		field: permissiongroup.FieldUpdatedAt,
		toCursor: func(pg *PermissionGroup) Cursor {
			return Cursor{
				ID:    pg.ID,
				Value: pg.UpdatedAt,
			}
		},
	}
	// PermissionGroupOrderFieldDeletedAt orders PermissionGroup by deleted_at.
	PermissionGroupOrderFieldDeletedAt = &PermissionGroupOrderField{
		field: permissiongroup.FieldDeletedAt,
		toCursor: func(pg *PermissionGroup) Cursor {
			return Cursor{
				ID:    pg.ID,
				Value: pg.DeletedAt,
			}
		},
	}
	// PermissionGroupOrderFieldTitle orders PermissionGroup by title.
	PermissionGroupOrderFieldTitle = &PermissionGroupOrderField{
		field: permissiongroup.FieldTitle,
		toCursor: func(pg *PermissionGroup) Cursor {
			return Cursor{
				ID:    pg.ID,
				Value: pg.Title,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PermissionGroupOrderField) String() string {
	var str string
	switch f.field {
	case permissiongroup.FieldCreatedAt:
		str = "created_at"
	case permissiongroup.FieldUpdatedAt:
		str = "updated_at"
	case permissiongroup.FieldDeletedAt:
		str = "deleted_at"
	case permissiongroup.FieldTitle:
		str = "title"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PermissionGroupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PermissionGroupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PermissionGroupOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *PermissionGroupOrderFieldCreatedAt
	case "updated_at":
		*f = *PermissionGroupOrderFieldUpdatedAt
	case "deleted_at":
		*f = *PermissionGroupOrderFieldDeletedAt
	case "title":
		*f = *PermissionGroupOrderFieldTitle
	default:
		return fmt.Errorf("%s is not a valid PermissionGroupOrderField", str)
	}
	return nil
}

// PermissionGroupOrderField defines the ordering field of PermissionGroup.
type PermissionGroupOrderField struct {
	field    string
	toCursor func(*PermissionGroup) Cursor
}

// PermissionGroupOrder defines the ordering of PermissionGroup.
type PermissionGroupOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *PermissionGroupOrderField `json:"field"`
}

// DefaultPermissionGroupOrder is the default ordering of PermissionGroup.
var DefaultPermissionGroupOrder = &PermissionGroupOrder{
	Direction: OrderDirectionAsc,
	Field: &PermissionGroupOrderField{
		field: permissiongroup.FieldID,
		toCursor: func(pg *PermissionGroup) Cursor {
			return Cursor{ID: pg.ID}
		},
	},
}

// ToEdge converts PermissionGroup into PermissionGroupEdge.
func (pg *PermissionGroup) ToEdge(order *PermissionGroupOrder) *PermissionGroupEdge {
	if order == nil {
		order = DefaultPermissionGroupOrder
	}
	return &PermissionGroupEdge{
		Node:   pg,
		Cursor: order.Field.toCursor(pg),
	}
}

// RecTeamEdge is the edge representation of RecTeam.
type RecTeamEdge struct {
	Node   *RecTeam `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// RecTeamConnection is the connection containing edges to RecTeam.
type RecTeamConnection struct {
	Edges      []*RecTeamEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *RecTeamConnection) build(nodes []*RecTeam, pager *recteamPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RecTeam
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RecTeam {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RecTeam {
			return nodes[i]
		}
	}
	c.Edges = make([]*RecTeamEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RecTeamEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RecTeamPaginateOption enables pagination customization.
type RecTeamPaginateOption func(*recteamPager) error

// WithRecTeamOrder configures pagination ordering.
func WithRecTeamOrder(order *RecTeamOrder) RecTeamPaginateOption {
	if order == nil {
		order = DefaultRecTeamOrder
	}
	o := *order
	return func(pager *recteamPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRecTeamOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRecTeamFilter configures pagination filter.
func WithRecTeamFilter(filter func(*RecTeamQuery) (*RecTeamQuery, error)) RecTeamPaginateOption {
	return func(pager *recteamPager) error {
		if filter == nil {
			return errors.New("RecTeamQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type recteamPager struct {
	order  *RecTeamOrder
	filter func(*RecTeamQuery) (*RecTeamQuery, error)
}

func newRecTeamPager(opts []RecTeamPaginateOption) (*recteamPager, error) {
	pager := &recteamPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRecTeamOrder
	}
	return pager, nil
}

func (p *recteamPager) applyFilter(query *RecTeamQuery) (*RecTeamQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *recteamPager) toCursor(rt *RecTeam) Cursor {
	return p.order.Field.toCursor(rt)
}

func (p *recteamPager) applyCursors(query *RecTeamQuery, after, before *Cursor) *RecTeamQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRecTeamOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *recteamPager) applyOrder(query *RecTeamQuery, reverse bool) *RecTeamQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRecTeamOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRecTeamOrder.Field.field))
	}
	return query
}

func (p *recteamPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRecTeamOrder.Field {
			b.Comma().Ident(DefaultRecTeamOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RecTeam.
func (rt *RecTeamQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RecTeamPaginateOption,
) (*RecTeamConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRecTeamPager(opts)
	if err != nil {
		return nil, err
	}
	if rt, err = pager.applyFilter(rt); err != nil {
		return nil, err
	}
	conn := &RecTeamConnection{Edges: []*RecTeamEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = rt.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	rt = pager.applyCursors(rt, after, before)
	rt = pager.applyOrder(rt, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		rt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rt.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := rt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RecTeamOrderFieldCreatedAt orders RecTeam by created_at.
	RecTeamOrderFieldCreatedAt = &RecTeamOrderField{
		field: recteam.FieldCreatedAt,
		toCursor: func(rt *RecTeam) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.CreatedAt,
			}
		},
	}
	// RecTeamOrderFieldUpdatedAt orders RecTeam by updated_at.
	RecTeamOrderFieldUpdatedAt = &RecTeamOrderField{
		field: recteam.FieldUpdatedAt,
		toCursor: func(rt *RecTeam) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.UpdatedAt,
			}
		},
	}
	// RecTeamOrderFieldDeletedAt orders RecTeam by deleted_at.
	RecTeamOrderFieldDeletedAt = &RecTeamOrderField{
		field: recteam.FieldDeletedAt,
		toCursor: func(rt *RecTeam) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.DeletedAt,
			}
		},
	}
	// RecTeamOrderFieldName orders RecTeam by name.
	RecTeamOrderFieldName = &RecTeamOrderField{
		field: recteam.FieldName,
		toCursor: func(rt *RecTeam) Cursor {
			return Cursor{
				ID:    rt.ID,
				Value: rt.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RecTeamOrderField) String() string {
	var str string
	switch f.field {
	case recteam.FieldCreatedAt:
		str = "created_at"
	case recteam.FieldUpdatedAt:
		str = "updated_at"
	case recteam.FieldDeletedAt:
		str = "deleted_at"
	case recteam.FieldName:
		str = "name"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RecTeamOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RecTeamOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RecTeamOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *RecTeamOrderFieldCreatedAt
	case "updated_at":
		*f = *RecTeamOrderFieldUpdatedAt
	case "deleted_at":
		*f = *RecTeamOrderFieldDeletedAt
	case "name":
		*f = *RecTeamOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid RecTeamOrderField", str)
	}
	return nil
}

// RecTeamOrderField defines the ordering field of RecTeam.
type RecTeamOrderField struct {
	field    string
	toCursor func(*RecTeam) Cursor
}

// RecTeamOrder defines the ordering of RecTeam.
type RecTeamOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *RecTeamOrderField `json:"field"`
}

// DefaultRecTeamOrder is the default ordering of RecTeam.
var DefaultRecTeamOrder = &RecTeamOrder{
	Direction: OrderDirectionAsc,
	Field: &RecTeamOrderField{
		field: recteam.FieldID,
		toCursor: func(rt *RecTeam) Cursor {
			return Cursor{ID: rt.ID}
		},
	},
}

// ToEdge converts RecTeam into RecTeamEdge.
func (rt *RecTeam) ToEdge(order *RecTeamOrder) *RecTeamEdge {
	if order == nil {
		order = DefaultRecTeamOrder
	}
	return &RecTeamEdge{
		Node:   rt,
		Cursor: order.Field.toCursor(rt),
	}
}

// RoleEdge is the edge representation of Role.
type RoleEdge struct {
	Node   *Role  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RoleConnection is the connection containing edges to Role.
type RoleConnection struct {
	Edges      []*RoleEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *RoleConnection) build(nodes []*Role, pager *rolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Role
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Role {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Role {
			return nodes[i]
		}
	}
	c.Edges = make([]*RoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RolePaginateOption enables pagination customization.
type RolePaginateOption func(*rolePager) error

// WithRoleOrder configures pagination ordering.
func WithRoleOrder(order *RoleOrder) RolePaginateOption {
	if order == nil {
		order = DefaultRoleOrder
	}
	o := *order
	return func(pager *rolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRoleFilter configures pagination filter.
func WithRoleFilter(filter func(*RoleQuery) (*RoleQuery, error)) RolePaginateOption {
	return func(pager *rolePager) error {
		if filter == nil {
			return errors.New("RoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type rolePager struct {
	order  *RoleOrder
	filter func(*RoleQuery) (*RoleQuery, error)
}

func newRolePager(opts []RolePaginateOption) (*rolePager, error) {
	pager := &rolePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRoleOrder
	}
	return pager, nil
}

func (p *rolePager) applyFilter(query *RoleQuery) (*RoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *rolePager) toCursor(r *Role) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *rolePager) applyCursors(query *RoleQuery, after, before *Cursor) *RoleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRoleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *rolePager) applyOrder(query *RoleQuery, reverse bool) *RoleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRoleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRoleOrder.Field.field))
	}
	return query
}

func (p *rolePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRoleOrder.Field {
			b.Comma().Ident(DefaultRoleOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Role.
func (r *RoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RolePaginateOption,
) (*RoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRolePager(opts)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RoleConnection{Edges: []*RoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = r.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// RoleOrderFieldCreatedAt orders Role by created_at.
	RoleOrderFieldCreatedAt = &RoleOrderField{
		field: role.FieldCreatedAt,
		toCursor: func(r *Role) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
	// RoleOrderFieldUpdatedAt orders Role by updated_at.
	RoleOrderFieldUpdatedAt = &RoleOrderField{
		field: role.FieldUpdatedAt,
		toCursor: func(r *Role) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.UpdatedAt,
			}
		},
	}
	// RoleOrderFieldDeletedAt orders Role by deleted_at.
	RoleOrderFieldDeletedAt = &RoleOrderField{
		field: role.FieldDeletedAt,
		toCursor: func(r *Role) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.DeletedAt,
			}
		},
	}
	// RoleOrderFieldName orders Role by name.
	RoleOrderFieldName = &RoleOrderField{
		field: role.FieldName,
		toCursor: func(r *Role) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Name,
			}
		},
	}
	// RoleOrderFieldDescription orders Role by description.
	RoleOrderFieldDescription = &RoleOrderField{
		field: role.FieldDescription,
		toCursor: func(r *Role) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RoleOrderField) String() string {
	var str string
	switch f.field {
	case role.FieldCreatedAt:
		str = "created_at"
	case role.FieldUpdatedAt:
		str = "updated_at"
	case role.FieldDeletedAt:
		str = "deleted_at"
	case role.FieldName:
		str = "name"
	case role.FieldDescription:
		str = "DESCRIPTION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RoleOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *RoleOrderFieldCreatedAt
	case "updated_at":
		*f = *RoleOrderFieldUpdatedAt
	case "deleted_at":
		*f = *RoleOrderFieldDeletedAt
	case "name":
		*f = *RoleOrderFieldName
	case "DESCRIPTION":
		*f = *RoleOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid RoleOrderField", str)
	}
	return nil
}

// RoleOrderField defines the ordering field of Role.
type RoleOrderField struct {
	field    string
	toCursor func(*Role) Cursor
}

// RoleOrder defines the ordering of Role.
type RoleOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *RoleOrderField `json:"field"`
}

// DefaultRoleOrder is the default ordering of Role.
var DefaultRoleOrder = &RoleOrder{
	Direction: OrderDirectionAsc,
	Field: &RoleOrderField{
		field: role.FieldID,
		toCursor: func(r *Role) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Role into RoleEdge.
func (r *Role) ToEdge(order *RoleOrder) *RoleEdge {
	if order == nil {
		order = DefaultRoleOrder
	}
	return &RoleEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SkillEdge is the edge representation of Skill.
type SkillEdge struct {
	Node   *Skill `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// SkillConnection is the connection containing edges to Skill.
type SkillConnection struct {
	Edges      []*SkillEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *SkillConnection) build(nodes []*Skill, pager *skillPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Skill
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Skill {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Skill {
			return nodes[i]
		}
	}
	c.Edges = make([]*SkillEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SkillEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SkillPaginateOption enables pagination customization.
type SkillPaginateOption func(*skillPager) error

// WithSkillOrder configures pagination ordering.
func WithSkillOrder(order *SkillOrder) SkillPaginateOption {
	if order == nil {
		order = DefaultSkillOrder
	}
	o := *order
	return func(pager *skillPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSkillOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSkillFilter configures pagination filter.
func WithSkillFilter(filter func(*SkillQuery) (*SkillQuery, error)) SkillPaginateOption {
	return func(pager *skillPager) error {
		if filter == nil {
			return errors.New("SkillQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type skillPager struct {
	order  *SkillOrder
	filter func(*SkillQuery) (*SkillQuery, error)
}

func newSkillPager(opts []SkillPaginateOption) (*skillPager, error) {
	pager := &skillPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSkillOrder
	}
	return pager, nil
}

func (p *skillPager) applyFilter(query *SkillQuery) (*SkillQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *skillPager) toCursor(s *Skill) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *skillPager) applyCursors(query *SkillQuery, after, before *Cursor) *SkillQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSkillOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *skillPager) applyOrder(query *SkillQuery, reverse bool) *SkillQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSkillOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSkillOrder.Field.field))
	}
	return query
}

func (p *skillPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSkillOrder.Field {
			b.Comma().Ident(DefaultSkillOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Skill.
func (s *SkillQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SkillPaginateOption,
) (*SkillConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSkillPager(opts)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SkillConnection{Edges: []*SkillEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SkillOrderFieldCreatedAt orders Skill by created_at.
	SkillOrderFieldCreatedAt = &SkillOrderField{
		field: skill.FieldCreatedAt,
		toCursor: func(s *Skill) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SkillOrderFieldUpdatedAt orders Skill by updated_at.
	SkillOrderFieldUpdatedAt = &SkillOrderField{
		field: skill.FieldUpdatedAt,
		toCursor: func(s *Skill) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SkillOrderFieldDeletedAt orders Skill by deleted_at.
	SkillOrderFieldDeletedAt = &SkillOrderField{
		field: skill.FieldDeletedAt,
		toCursor: func(s *Skill) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.DeletedAt,
			}
		},
	}
	// SkillOrderFieldName orders Skill by name.
	SkillOrderFieldName = &SkillOrderField{
		field: skill.FieldName,
		toCursor: func(s *Skill) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Name,
			}
		},
	}
	// SkillOrderFieldDescription orders Skill by description.
	SkillOrderFieldDescription = &SkillOrderField{
		field: skill.FieldDescription,
		toCursor: func(s *Skill) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SkillOrderField) String() string {
	var str string
	switch f.field {
	case skill.FieldCreatedAt:
		str = "created_at"
	case skill.FieldUpdatedAt:
		str = "updated_at"
	case skill.FieldDeletedAt:
		str = "deleted_at"
	case skill.FieldName:
		str = "name"
	case skill.FieldDescription:
		str = "description"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SkillOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SkillOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SkillOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SkillOrderFieldCreatedAt
	case "updated_at":
		*f = *SkillOrderFieldUpdatedAt
	case "deleted_at":
		*f = *SkillOrderFieldDeletedAt
	case "name":
		*f = *SkillOrderFieldName
	case "description":
		*f = *SkillOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid SkillOrderField", str)
	}
	return nil
}

// SkillOrderField defines the ordering field of Skill.
type SkillOrderField struct {
	field    string
	toCursor func(*Skill) Cursor
}

// SkillOrder defines the ordering of Skill.
type SkillOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *SkillOrderField `json:"field"`
}

// DefaultSkillOrder is the default ordering of Skill.
var DefaultSkillOrder = &SkillOrder{
	Direction: OrderDirectionAsc,
	Field: &SkillOrderField{
		field: skill.FieldID,
		toCursor: func(s *Skill) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Skill into SkillEdge.
func (s *Skill) ToEdge(order *SkillOrder) *SkillEdge {
	if order == nil {
		order = DefaultSkillOrder
	}
	return &SkillEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SkillTypeEdge is the edge representation of SkillType.
type SkillTypeEdge struct {
	Node   *SkillType `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// SkillTypeConnection is the connection containing edges to SkillType.
type SkillTypeConnection struct {
	Edges      []*SkillTypeEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *SkillTypeConnection) build(nodes []*SkillType, pager *skilltypePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SkillType
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SkillType {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SkillType {
			return nodes[i]
		}
	}
	c.Edges = make([]*SkillTypeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SkillTypeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SkillTypePaginateOption enables pagination customization.
type SkillTypePaginateOption func(*skilltypePager) error

// WithSkillTypeOrder configures pagination ordering.
func WithSkillTypeOrder(order *SkillTypeOrder) SkillTypePaginateOption {
	if order == nil {
		order = DefaultSkillTypeOrder
	}
	o := *order
	return func(pager *skilltypePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSkillTypeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSkillTypeFilter configures pagination filter.
func WithSkillTypeFilter(filter func(*SkillTypeQuery) (*SkillTypeQuery, error)) SkillTypePaginateOption {
	return func(pager *skilltypePager) error {
		if filter == nil {
			return errors.New("SkillTypeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type skilltypePager struct {
	order  *SkillTypeOrder
	filter func(*SkillTypeQuery) (*SkillTypeQuery, error)
}

func newSkillTypePager(opts []SkillTypePaginateOption) (*skilltypePager, error) {
	pager := &skilltypePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSkillTypeOrder
	}
	return pager, nil
}

func (p *skilltypePager) applyFilter(query *SkillTypeQuery) (*SkillTypeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *skilltypePager) toCursor(st *SkillType) Cursor {
	return p.order.Field.toCursor(st)
}

func (p *skilltypePager) applyCursors(query *SkillTypeQuery, after, before *Cursor) *SkillTypeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSkillTypeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *skilltypePager) applyOrder(query *SkillTypeQuery, reverse bool) *SkillTypeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSkillTypeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSkillTypeOrder.Field.field))
	}
	return query
}

func (p *skilltypePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSkillTypeOrder.Field {
			b.Comma().Ident(DefaultSkillTypeOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SkillType.
func (st *SkillTypeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SkillTypePaginateOption,
) (*SkillTypeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSkillTypePager(opts)
	if err != nil {
		return nil, err
	}
	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}
	conn := &SkillTypeConnection{Edges: []*SkillTypeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = st.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	st = pager.applyCursors(st, after, before)
	st = pager.applyOrder(st, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		st.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := st.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := st.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SkillTypeOrderFieldCreatedAt orders SkillType by created_at.
	SkillTypeOrderFieldCreatedAt = &SkillTypeOrderField{
		field: skilltype.FieldCreatedAt,
		toCursor: func(st *SkillType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.CreatedAt,
			}
		},
	}
	// SkillTypeOrderFieldUpdatedAt orders SkillType by updated_at.
	SkillTypeOrderFieldUpdatedAt = &SkillTypeOrderField{
		field: skilltype.FieldUpdatedAt,
		toCursor: func(st *SkillType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.UpdatedAt,
			}
		},
	}
	// SkillTypeOrderFieldDeletedAt orders SkillType by deleted_at.
	SkillTypeOrderFieldDeletedAt = &SkillTypeOrderField{
		field: skilltype.FieldDeletedAt,
		toCursor: func(st *SkillType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.DeletedAt,
			}
		},
	}
	// SkillTypeOrderFieldName orders SkillType by name.
	SkillTypeOrderFieldName = &SkillTypeOrderField{
		field: skilltype.FieldName,
		toCursor: func(st *SkillType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.Name,
			}
		},
	}
	// SkillTypeOrderFieldDescription orders SkillType by description.
	SkillTypeOrderFieldDescription = &SkillTypeOrderField{
		field: skilltype.FieldDescription,
		toCursor: func(st *SkillType) Cursor {
			return Cursor{
				ID:    st.ID,
				Value: st.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SkillTypeOrderField) String() string {
	var str string
	switch f.field {
	case skilltype.FieldCreatedAt:
		str = "created_at"
	case skilltype.FieldUpdatedAt:
		str = "updated_at"
	case skilltype.FieldDeletedAt:
		str = "deleted_at"
	case skilltype.FieldName:
		str = "name"
	case skilltype.FieldDescription:
		str = "description"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SkillTypeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SkillTypeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SkillTypeOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *SkillTypeOrderFieldCreatedAt
	case "updated_at":
		*f = *SkillTypeOrderFieldUpdatedAt
	case "deleted_at":
		*f = *SkillTypeOrderFieldDeletedAt
	case "name":
		*f = *SkillTypeOrderFieldName
	case "description":
		*f = *SkillTypeOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid SkillTypeOrderField", str)
	}
	return nil
}

// SkillTypeOrderField defines the ordering field of SkillType.
type SkillTypeOrderField struct {
	field    string
	toCursor func(*SkillType) Cursor
}

// SkillTypeOrder defines the ordering of SkillType.
type SkillTypeOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *SkillTypeOrderField `json:"field"`
}

// DefaultSkillTypeOrder is the default ordering of SkillType.
var DefaultSkillTypeOrder = &SkillTypeOrder{
	Direction: OrderDirectionAsc,
	Field: &SkillTypeOrderField{
		field: skilltype.FieldID,
		toCursor: func(st *SkillType) Cursor {
			return Cursor{ID: st.ID}
		},
	},
}

// ToEdge converts SkillType into SkillTypeEdge.
func (st *SkillType) ToEdge(order *SkillTypeOrder) *SkillTypeEdge {
	if order == nil {
		order = DefaultSkillTypeOrder
	}
	return &SkillTypeEdge{
		Node:   st,
		Cursor: order.Field.toCursor(st),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

func (p *userPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		field: user.FieldCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		field: user.FieldUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
	// UserOrderFieldDeletedAt orders User by deleted_at.
	UserOrderFieldDeletedAt = &UserOrderField{
		field: user.FieldDeletedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.DeletedAt,
			}
		},
	}
	// UserOrderFieldName orders User by name.
	UserOrderFieldName = &UserOrderField{
		field: user.FieldName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Name,
			}
		},
	}
	// UserOrderFieldWorkEmail orders User by work_email.
	UserOrderFieldWorkEmail = &UserOrderField{
		field: user.FieldWorkEmail,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.WorkEmail,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.field {
	case user.FieldCreatedAt:
		str = "created_at"
	case user.FieldUpdatedAt:
		str = "updated_at"
	case user.FieldDeletedAt:
		str = "deleted_at"
	case user.FieldName:
		str = "name"
	case user.FieldWorkEmail:
		str = "work_email"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserOrderFieldCreatedAt
	case "updated_at":
		*f = *UserOrderFieldUpdatedAt
	case "deleted_at":
		*f = *UserOrderFieldDeletedAt
	case "name":
		*f = *UserOrderFieldName
	case "work_email":
		*f = *UserOrderFieldWorkEmail
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserRoleEdge is the edge representation of UserRole.
type UserRoleEdge struct {
	Node   *UserRole `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UserRoleConnection is the connection containing edges to UserRole.
type UserRoleConnection struct {
	Edges      []*UserRoleEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UserRoleConnection) build(nodes []*UserRole, pager *userrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserRolePaginateOption enables pagination customization.
type UserRolePaginateOption func(*userrolePager) error

// WithUserRoleOrder configures pagination ordering.
func WithUserRoleOrder(order *UserRoleOrder) UserRolePaginateOption {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	o := *order
	return func(pager *userrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserRoleFilter configures pagination filter.
func WithUserRoleFilter(filter func(*UserRoleQuery) (*UserRoleQuery, error)) UserRolePaginateOption {
	return func(pager *userrolePager) error {
		if filter == nil {
			return errors.New("UserRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userrolePager struct {
	order  *UserRoleOrder
	filter func(*UserRoleQuery) (*UserRoleQuery, error)
}

func newUserRolePager(opts []UserRolePaginateOption) (*userrolePager, error) {
	pager := &userrolePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserRoleOrder
	}
	return pager, nil
}

func (p *userrolePager) applyFilter(query *UserRoleQuery) (*UserRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userrolePager) toCursor(ur *UserRole) Cursor {
	return p.order.Field.toCursor(ur)
}

func (p *userrolePager) applyCursors(query *UserRoleQuery, after, before *Cursor) *UserRoleQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserRoleOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userrolePager) applyOrder(query *UserRoleQuery, reverse bool) *UserRoleQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserRoleOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserRoleOrder.Field.field))
	}
	return query
}

func (p *userrolePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserRoleOrder.Field {
			b.Comma().Ident(DefaultUserRoleOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserRole.
func (ur *UserRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserRolePaginateOption,
) (*UserRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserRolePager(opts)
	if err != nil {
		return nil, err
	}
	if ur, err = pager.applyFilter(ur); err != nil {
		return nil, err
	}
	conn := &UserRoleConnection{Edges: []*UserRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ur.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ur = pager.applyCursors(ur, after, before)
	ur = pager.applyOrder(ur, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ur.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ur.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ur.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserRoleOrderFieldCreatedAt orders UserRole by created_at.
	UserRoleOrderFieldCreatedAt = &UserRoleOrderField{
		field: userrole.FieldCreatedAt,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{
				ID:    ur.ID,
				Value: ur.CreatedAt,
			}
		},
	}
	// UserRoleOrderFieldUpdatedAt orders UserRole by updated_at.
	UserRoleOrderFieldUpdatedAt = &UserRoleOrderField{
		field: userrole.FieldUpdatedAt,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{
				ID:    ur.ID,
				Value: ur.UpdatedAt,
			}
		},
	}
	// UserRoleOrderFieldDeletedAt orders UserRole by deleted_at.
	UserRoleOrderFieldDeletedAt = &UserRoleOrderField{
		field: userrole.FieldDeletedAt,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{
				ID:    ur.ID,
				Value: ur.DeletedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserRoleOrderField) String() string {
	var str string
	switch f.field {
	case userrole.FieldCreatedAt:
		str = "created_at"
	case userrole.FieldUpdatedAt:
		str = "updated_at"
	case userrole.FieldDeletedAt:
		str = "deleted_at"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserRoleOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserRoleOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserRoleOrderField %T must be a string", v)
	}
	switch str {
	case "created_at":
		*f = *UserRoleOrderFieldCreatedAt
	case "updated_at":
		*f = *UserRoleOrderFieldUpdatedAt
	case "deleted_at":
		*f = *UserRoleOrderFieldDeletedAt
	default:
		return fmt.Errorf("%s is not a valid UserRoleOrderField", str)
	}
	return nil
}

// UserRoleOrderField defines the ordering field of UserRole.
type UserRoleOrderField struct {
	field    string
	toCursor func(*UserRole) Cursor
}

// UserRoleOrder defines the ordering of UserRole.
type UserRoleOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UserRoleOrderField `json:"field"`
}

// DefaultUserRoleOrder is the default ordering of UserRole.
var DefaultUserRoleOrder = &UserRoleOrder{
	Direction: OrderDirectionAsc,
	Field: &UserRoleOrderField{
		field: userrole.FieldID,
		toCursor: func(ur *UserRole) Cursor {
			return Cursor{ID: ur.ID}
		},
	},
}

// ToEdge converts UserRole into UserRoleEdge.
func (ur *UserRole) ToEdge(order *UserRoleOrder) *UserRoleEdge {
	if order == nil {
		order = DefaultUserRoleOrder
	}
	return &UserRoleEdge{
		Node:   ur,
		Cursor: order.Field.toCursor(ur),
	}
}
