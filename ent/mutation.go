// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"trec/ent/attachment"
	"trec/ent/audittrail"
	"trec/ent/candidate"
	"trec/ent/candidateinterview"
	"trec/ent/candidateinterviewer"
	"trec/ent/candidatejob"
	"trec/ent/candidatejobfeedback"
	"trec/ent/candidatejobstep"
	"trec/ent/hiringjob"
	"trec/ent/predicate"
	"trec/ent/team"
	"trec/ent/teammanager"
	"trec/ent/user"

	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment           = "Attachment"
	TypeAuditTrail           = "AuditTrail"
	TypeCandidate            = "Candidate"
	TypeCandidateInterview   = "CandidateInterview"
	TypeCandidateInterviewer = "CandidateInterviewer"
	TypeCandidateJob         = "CandidateJob"
	TypeCandidateJobFeedback = "CandidateJobFeedback"
	TypeCandidateJobStep     = "CandidateJobStep"
	TypeHiringJob            = "HiringJob"
	TypeTeam                 = "Team"
	TypeTeamManager          = "TeamManager"
	TypeUser                 = "User"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	document_id                   *uuid.UUID
	document_name                 *string
	relation_type                 *attachment.RelationType
	clearedFields                 map[string]struct{}
	candidate_job                 *uuid.UUID
	clearedcandidate_job          bool
	candidate_job_feedback        *uuid.UUID
	clearedcandidate_job_feedback bool
	candidate_interview           *uuid.UUID
	clearedcandidate_interview    bool
	done                          bool
	oldValue                      func(context.Context) (*Attachment, error)
	predicates                    []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AttachmentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[attachment.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AttachmentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, attachment.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attachment.FieldDeletedAt)
}

// SetDocumentID sets the "document_id" field.
func (m *AttachmentMutation) SetDocumentID(u uuid.UUID) {
	m.document_id = &u
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *AttachmentMutation) DocumentID() (r uuid.UUID, exists bool) {
	v := m.document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDocumentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *AttachmentMutation) ResetDocumentID() {
	m.document_id = nil
}

// SetDocumentName sets the "document_name" field.
func (m *AttachmentMutation) SetDocumentName(s string) {
	m.document_name = &s
}

// DocumentName returns the value of the "document_name" field in the mutation.
func (m *AttachmentMutation) DocumentName() (r string, exists bool) {
	v := m.document_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentName returns the old "document_name" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDocumentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentName: %w", err)
	}
	return oldValue.DocumentName, nil
}

// ResetDocumentName resets all changes to the "document_name" field.
func (m *AttachmentMutation) ResetDocumentName() {
	m.document_name = nil
}

// SetRelationType sets the "relation_type" field.
func (m *AttachmentMutation) SetRelationType(at attachment.RelationType) {
	m.relation_type = &at
}

// RelationType returns the value of the "relation_type" field in the mutation.
func (m *AttachmentMutation) RelationType() (r attachment.RelationType, exists bool) {
	v := m.relation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationType returns the old "relation_type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldRelationType(ctx context.Context) (v attachment.RelationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationType: %w", err)
	}
	return oldValue.RelationType, nil
}

// ResetRelationType resets all changes to the "relation_type" field.
func (m *AttachmentMutation) ResetRelationType() {
	m.relation_type = nil
}

// SetRelationID sets the "relation_id" field.
func (m *AttachmentMutation) SetRelationID(u uuid.UUID) {
	m.candidate_job_feedback = &u
}

// RelationID returns the value of the "relation_id" field in the mutation.
func (m *AttachmentMutation) RelationID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationID returns the old "relation_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldRelationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationID: %w", err)
	}
	return oldValue.RelationID, nil
}

// ClearRelationID clears the value of the "relation_id" field.
func (m *AttachmentMutation) ClearRelationID() {
	m.candidate_job_feedback = nil
	m.clearedFields[attachment.FieldRelationID] = struct{}{}
}

// RelationIDCleared returns if the "relation_id" field was cleared in this mutation.
func (m *AttachmentMutation) RelationIDCleared() bool {
	_, ok := m.clearedFields[attachment.FieldRelationID]
	return ok
}

// ResetRelationID resets all changes to the "relation_id" field.
func (m *AttachmentMutation) ResetRelationID() {
	m.candidate_job_feedback = nil
	delete(m.clearedFields, attachment.FieldRelationID)
}

// SetCandidateJobID sets the "candidate_job" edge to the CandidateJob entity by id.
func (m *AttachmentMutation) SetCandidateJobID(id uuid.UUID) {
	m.candidate_job = &id
}

// ClearCandidateJob clears the "candidate_job" edge to the CandidateJob entity.
func (m *AttachmentMutation) ClearCandidateJob() {
	m.clearedcandidate_job = true
}

// CandidateJobCleared reports if the "candidate_job" edge to the CandidateJob entity was cleared.
func (m *AttachmentMutation) CandidateJobCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_job
}

// CandidateJobID returns the "candidate_job" edge ID in the mutation.
func (m *AttachmentMutation) CandidateJobID() (id uuid.UUID, exists bool) {
	if m.candidate_job != nil {
		return *m.candidate_job, true
	}
	return
}

// CandidateJobIDs returns the "candidate_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateJobIDs() (ids []uuid.UUID) {
	if id := m.candidate_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJob resets all changes to the "candidate_job" edge.
func (m *AttachmentMutation) ResetCandidateJob() {
	m.candidate_job = nil
	m.clearedcandidate_job = false
}

// SetCandidateJobFeedbackID sets the "candidate_job_feedback" edge to the CandidateJobFeedback entity by id.
func (m *AttachmentMutation) SetCandidateJobFeedbackID(id uuid.UUID) {
	m.candidate_job_feedback = &id
}

// ClearCandidateJobFeedback clears the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *AttachmentMutation) ClearCandidateJobFeedback() {
	m.clearedcandidate_job_feedback = true
}

// CandidateJobFeedbackCleared reports if the "candidate_job_feedback" edge to the CandidateJobFeedback entity was cleared.
func (m *AttachmentMutation) CandidateJobFeedbackCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_job_feedback
}

// CandidateJobFeedbackID returns the "candidate_job_feedback" edge ID in the mutation.
func (m *AttachmentMutation) CandidateJobFeedbackID() (id uuid.UUID, exists bool) {
	if m.candidate_job_feedback != nil {
		return *m.candidate_job_feedback, true
	}
	return
}

// CandidateJobFeedbackIDs returns the "candidate_job_feedback" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobFeedbackID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateJobFeedbackIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_feedback; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobFeedback resets all changes to the "candidate_job_feedback" edge.
func (m *AttachmentMutation) ResetCandidateJobFeedback() {
	m.candidate_job_feedback = nil
	m.clearedcandidate_job_feedback = false
}

// SetCandidateInterviewID sets the "candidate_interview" edge to the CandidateInterview entity by id.
func (m *AttachmentMutation) SetCandidateInterviewID(id uuid.UUID) {
	m.candidate_interview = &id
}

// ClearCandidateInterview clears the "candidate_interview" edge to the CandidateInterview entity.
func (m *AttachmentMutation) ClearCandidateInterview() {
	m.clearedcandidate_interview = true
}

// CandidateInterviewCleared reports if the "candidate_interview" edge to the CandidateInterview entity was cleared.
func (m *AttachmentMutation) CandidateInterviewCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_interview
}

// CandidateInterviewID returns the "candidate_interview" edge ID in the mutation.
func (m *AttachmentMutation) CandidateInterviewID() (id uuid.UUID, exists bool) {
	if m.candidate_interview != nil {
		return *m.candidate_interview, true
	}
	return
}

// CandidateInterviewIDs returns the "candidate_interview" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateInterviewID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateInterviewIDs() (ids []uuid.UUID) {
	if id := m.candidate_interview; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateInterview resets all changes to the "candidate_interview" edge.
func (m *AttachmentMutation) ResetCandidateInterview() {
	m.candidate_interview = nil
	m.clearedcandidate_interview = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.document_id != nil {
		fields = append(fields, attachment.FieldDocumentID)
	}
	if m.document_name != nil {
		fields = append(fields, attachment.FieldDocumentName)
	}
	if m.relation_type != nil {
		fields = append(fields, attachment.FieldRelationType)
	}
	if m.candidate_job_feedback != nil {
		fields = append(fields, attachment.FieldRelationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldDeletedAt:
		return m.DeletedAt()
	case attachment.FieldDocumentID:
		return m.DocumentID()
	case attachment.FieldDocumentName:
		return m.DocumentName()
	case attachment.FieldRelationType:
		return m.RelationType()
	case attachment.FieldRelationID:
		return m.RelationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attachment.FieldDocumentID:
		return m.OldDocumentID(ctx)
	case attachment.FieldDocumentName:
		return m.OldDocumentName(ctx)
	case attachment.FieldRelationType:
		return m.OldRelationType(ctx)
	case attachment.FieldRelationID:
		return m.OldRelationID(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attachment.FieldDocumentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	case attachment.FieldDocumentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentName(v)
		return nil
	case attachment.FieldRelationType:
		v, ok := value.(attachment.RelationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationType(v)
		return nil
	case attachment.FieldRelationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationID(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldUpdatedAt) {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.FieldCleared(attachment.FieldDeletedAt) {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.FieldCleared(attachment.FieldRelationID) {
		fields = append(fields, attachment.FieldRelationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attachment.FieldRelationID:
		m.ClearRelationID()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attachment.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	case attachment.FieldDocumentName:
		m.ResetDocumentName()
		return nil
	case attachment.FieldRelationType:
		m.ResetRelationType()
		return nil
	case attachment.FieldRelationID:
		m.ResetRelationID()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.candidate_job != nil {
		edges = append(edges, attachment.EdgeCandidateJob)
	}
	if m.candidate_job_feedback != nil {
		edges = append(edges, attachment.EdgeCandidateJobFeedback)
	}
	if m.candidate_interview != nil {
		edges = append(edges, attachment.EdgeCandidateInterview)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeCandidateJob:
		if id := m.candidate_job; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeCandidateJobFeedback:
		if id := m.candidate_job_feedback; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeCandidateInterview:
		if id := m.candidate_interview; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcandidate_job {
		edges = append(edges, attachment.EdgeCandidateJob)
	}
	if m.clearedcandidate_job_feedback {
		edges = append(edges, attachment.EdgeCandidateJobFeedback)
	}
	if m.clearedcandidate_interview {
		edges = append(edges, attachment.EdgeCandidateInterview)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeCandidateJob:
		return m.clearedcandidate_job
	case attachment.EdgeCandidateJobFeedback:
		return m.clearedcandidate_job_feedback
	case attachment.EdgeCandidateInterview:
		return m.clearedcandidate_interview
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeCandidateJob:
		m.ClearCandidateJob()
		return nil
	case attachment.EdgeCandidateJobFeedback:
		m.ClearCandidateJobFeedback()
		return nil
	case attachment.EdgeCandidateInterview:
		m.ClearCandidateInterview()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeCandidateJob:
		m.ResetCandidateJob()
		return nil
	case attachment.EdgeCandidateJobFeedback:
		m.ResetCandidateJobFeedback()
		return nil
	case attachment.EdgeCandidateInterview:
		m.ResetCandidateInterview()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// AuditTrailMutation represents an operation that mutates the AuditTrail nodes in the graph.
type AuditTrailMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	recordId         *uuid.UUID
	module           *audittrail.Module
	actionType       *audittrail.ActionType
	note             *string
	record_changes   *string
	clearedFields    map[string]struct{}
	user_edge        *uuid.UUID
	cleareduser_edge bool
	done             bool
	oldValue         func(context.Context) (*AuditTrail, error)
	predicates       []predicate.AuditTrail
}

var _ ent.Mutation = (*AuditTrailMutation)(nil)

// audittrailOption allows management of the mutation configuration using functional options.
type audittrailOption func(*AuditTrailMutation)

// newAuditTrailMutation creates new mutation for the AuditTrail entity.
func newAuditTrailMutation(c config, op Op, opts ...audittrailOption) *AuditTrailMutation {
	m := &AuditTrailMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditTrail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditTrailID sets the ID field of the mutation.
func withAuditTrailID(id uuid.UUID) audittrailOption {
	return func(m *AuditTrailMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditTrail
		)
		m.oldValue = func(ctx context.Context) (*AuditTrail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditTrail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditTrail sets the old AuditTrail of the mutation.
func withAuditTrail(node *AuditTrail) audittrailOption {
	return func(m *AuditTrailMutation) {
		m.oldValue = func(context.Context) (*AuditTrail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditTrailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditTrailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditTrail entities.
func (m *AuditTrailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditTrailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditTrailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditTrail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditTrailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditTrailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditTrailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuditTrailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuditTrailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AuditTrailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[audittrail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AuditTrailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuditTrailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, audittrail.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuditTrailMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuditTrailMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuditTrailMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[audittrail.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuditTrailMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuditTrailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, audittrail.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AuditTrailMutation) SetCreatedBy(u uuid.UUID) {
	m.user_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AuditTrailMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AuditTrailMutation) ClearCreatedBy() {
	m.user_edge = nil
	m.clearedFields[audittrail.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AuditTrailMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AuditTrailMutation) ResetCreatedBy() {
	m.user_edge = nil
	delete(m.clearedFields, audittrail.FieldCreatedBy)
}

// SetRecordId sets the "recordId" field.
func (m *AuditTrailMutation) SetRecordId(u uuid.UUID) {
	m.recordId = &u
}

// RecordId returns the value of the "recordId" field in the mutation.
func (m *AuditTrailMutation) RecordId() (r uuid.UUID, exists bool) {
	v := m.recordId
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordId returns the old "recordId" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldRecordId(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordId: %w", err)
	}
	return oldValue.RecordId, nil
}

// ResetRecordId resets all changes to the "recordId" field.
func (m *AuditTrailMutation) ResetRecordId() {
	m.recordId = nil
}

// SetModule sets the "module" field.
func (m *AuditTrailMutation) SetModule(a audittrail.Module) {
	m.module = &a
}

// Module returns the value of the "module" field in the mutation.
func (m *AuditTrailMutation) Module() (r audittrail.Module, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldModule(ctx context.Context) (v audittrail.Module, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *AuditTrailMutation) ResetModule() {
	m.module = nil
}

// SetActionType sets the "actionType" field.
func (m *AuditTrailMutation) SetActionType(at audittrail.ActionType) {
	m.actionType = &at
}

// ActionType returns the value of the "actionType" field in the mutation.
func (m *AuditTrailMutation) ActionType() (r audittrail.ActionType, exists bool) {
	v := m.actionType
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "actionType" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldActionType(ctx context.Context) (v audittrail.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ClearActionType clears the value of the "actionType" field.
func (m *AuditTrailMutation) ClearActionType() {
	m.actionType = nil
	m.clearedFields[audittrail.FieldActionType] = struct{}{}
}

// ActionTypeCleared returns if the "actionType" field was cleared in this mutation.
func (m *AuditTrailMutation) ActionTypeCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldActionType]
	return ok
}

// ResetActionType resets all changes to the "actionType" field.
func (m *AuditTrailMutation) ResetActionType() {
	m.actionType = nil
	delete(m.clearedFields, audittrail.FieldActionType)
}

// SetNote sets the "note" field.
func (m *AuditTrailMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *AuditTrailMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *AuditTrailMutation) ClearNote() {
	m.note = nil
	m.clearedFields[audittrail.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *AuditTrailMutation) NoteCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *AuditTrailMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, audittrail.FieldNote)
}

// SetRecordChanges sets the "record_changes" field.
func (m *AuditTrailMutation) SetRecordChanges(s string) {
	m.record_changes = &s
}

// RecordChanges returns the value of the "record_changes" field in the mutation.
func (m *AuditTrailMutation) RecordChanges() (r string, exists bool) {
	v := m.record_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordChanges returns the old "record_changes" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldRecordChanges(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordChanges: %w", err)
	}
	return oldValue.RecordChanges, nil
}

// ClearRecordChanges clears the value of the "record_changes" field.
func (m *AuditTrailMutation) ClearRecordChanges() {
	m.record_changes = nil
	m.clearedFields[audittrail.FieldRecordChanges] = struct{}{}
}

// RecordChangesCleared returns if the "record_changes" field was cleared in this mutation.
func (m *AuditTrailMutation) RecordChangesCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldRecordChanges]
	return ok
}

// ResetRecordChanges resets all changes to the "record_changes" field.
func (m *AuditTrailMutation) ResetRecordChanges() {
	m.record_changes = nil
	delete(m.clearedFields, audittrail.FieldRecordChanges)
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *AuditTrailMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *AuditTrailMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *AuditTrailMutation) UserEdgeCleared() bool {
	return m.CreatedByCleared() || m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *AuditTrailMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *AuditTrailMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *AuditTrailMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// Where appends a list predicates to the AuditTrailMutation builder.
func (m *AuditTrailMutation) Where(ps ...predicate.AuditTrail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuditTrailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuditTrail).
func (m *AuditTrailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditTrailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, audittrail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, audittrail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, audittrail.FieldDeletedAt)
	}
	if m.user_edge != nil {
		fields = append(fields, audittrail.FieldCreatedBy)
	}
	if m.recordId != nil {
		fields = append(fields, audittrail.FieldRecordId)
	}
	if m.module != nil {
		fields = append(fields, audittrail.FieldModule)
	}
	if m.actionType != nil {
		fields = append(fields, audittrail.FieldActionType)
	}
	if m.note != nil {
		fields = append(fields, audittrail.FieldNote)
	}
	if m.record_changes != nil {
		fields = append(fields, audittrail.FieldRecordChanges)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditTrailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case audittrail.FieldCreatedAt:
		return m.CreatedAt()
	case audittrail.FieldUpdatedAt:
		return m.UpdatedAt()
	case audittrail.FieldDeletedAt:
		return m.DeletedAt()
	case audittrail.FieldCreatedBy:
		return m.CreatedBy()
	case audittrail.FieldRecordId:
		return m.RecordId()
	case audittrail.FieldModule:
		return m.Module()
	case audittrail.FieldActionType:
		return m.ActionType()
	case audittrail.FieldNote:
		return m.Note()
	case audittrail.FieldRecordChanges:
		return m.RecordChanges()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditTrailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case audittrail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case audittrail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case audittrail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case audittrail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case audittrail.FieldRecordId:
		return m.OldRecordId(ctx)
	case audittrail.FieldModule:
		return m.OldModule(ctx)
	case audittrail.FieldActionType:
		return m.OldActionType(ctx)
	case audittrail.FieldNote:
		return m.OldNote(ctx)
	case audittrail.FieldRecordChanges:
		return m.OldRecordChanges(ctx)
	}
	return nil, fmt.Errorf("unknown AuditTrail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditTrailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case audittrail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case audittrail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case audittrail.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case audittrail.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case audittrail.FieldRecordId:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordId(v)
		return nil
	case audittrail.FieldModule:
		v, ok := value.(audittrail.Module)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case audittrail.FieldActionType:
		v, ok := value.(audittrail.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case audittrail.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case audittrail.FieldRecordChanges:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordChanges(v)
		return nil
	}
	return fmt.Errorf("unknown AuditTrail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditTrailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditTrailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditTrailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditTrail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditTrailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(audittrail.FieldUpdatedAt) {
		fields = append(fields, audittrail.FieldUpdatedAt)
	}
	if m.FieldCleared(audittrail.FieldDeletedAt) {
		fields = append(fields, audittrail.FieldDeletedAt)
	}
	if m.FieldCleared(audittrail.FieldCreatedBy) {
		fields = append(fields, audittrail.FieldCreatedBy)
	}
	if m.FieldCleared(audittrail.FieldActionType) {
		fields = append(fields, audittrail.FieldActionType)
	}
	if m.FieldCleared(audittrail.FieldNote) {
		fields = append(fields, audittrail.FieldNote)
	}
	if m.FieldCleared(audittrail.FieldRecordChanges) {
		fields = append(fields, audittrail.FieldRecordChanges)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditTrailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditTrailMutation) ClearField(name string) error {
	switch name {
	case audittrail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case audittrail.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case audittrail.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case audittrail.FieldActionType:
		m.ClearActionType()
		return nil
	case audittrail.FieldNote:
		m.ClearNote()
		return nil
	case audittrail.FieldRecordChanges:
		m.ClearRecordChanges()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditTrailMutation) ResetField(name string) error {
	switch name {
	case audittrail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case audittrail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case audittrail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case audittrail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case audittrail.FieldRecordId:
		m.ResetRecordId()
		return nil
	case audittrail.FieldModule:
		m.ResetModule()
		return nil
	case audittrail.FieldActionType:
		m.ResetActionType()
		return nil
	case audittrail.FieldNote:
		m.ResetNote()
		return nil
	case audittrail.FieldRecordChanges:
		m.ResetRecordChanges()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditTrailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_edge != nil {
		edges = append(edges, audittrail.EdgeUserEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditTrailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case audittrail.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditTrailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditTrailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditTrailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_edge {
		edges = append(edges, audittrail.EdgeUserEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditTrailMutation) EdgeCleared(name string) bool {
	switch name {
	case audittrail.EdgeUserEdge:
		return m.cleareduser_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditTrailMutation) ClearEdge(name string) error {
	switch name {
	case audittrail.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditTrailMutation) ResetEdge(name string) error {
	switch name {
	case audittrail.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail edge %s", name)
}

// CandidateMutation represents an operation that mutates the Candidate nodes in the graph.
type CandidateMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	name                       *string
	email                      *string
	phone                      *string
	dob                        *time.Time
	is_blacklist               *bool
	last_apply_date            *time.Time
	clearedFields              map[string]struct{}
	candidate_job_edges        map[uuid.UUID]struct{}
	removedcandidate_job_edges map[uuid.UUID]struct{}
	clearedcandidate_job_edges bool
	done                       bool
	oldValue                   func(context.Context) (*Candidate, error)
	predicates                 []predicate.Candidate
}

var _ ent.Mutation = (*CandidateMutation)(nil)

// candidateOption allows management of the mutation configuration using functional options.
type candidateOption func(*CandidateMutation)

// newCandidateMutation creates new mutation for the Candidate entity.
func newCandidateMutation(c config, op Op, opts ...candidateOption) *CandidateMutation {
	m := &CandidateMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateID sets the ID field of the mutation.
func withCandidateID(id uuid.UUID) candidateOption {
	return func(m *CandidateMutation) {
		var (
			err   error
			once  sync.Once
			value *Candidate
		)
		m.oldValue = func(ctx context.Context) (*Candidate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Candidate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidate sets the old Candidate of the mutation.
func withCandidate(node *Candidate) candidateOption {
	return func(m *CandidateMutation) {
		m.oldValue = func(context.Context) (*Candidate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Candidate entities.
func (m *CandidateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Candidate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidate.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidate.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidate.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidate.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CandidateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CandidateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CandidateMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *CandidateMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CandidateMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CandidateMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *CandidateMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CandidateMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CandidateMutation) ResetPhone() {
	m.phone = nil
}

// SetDob sets the "dob" field.
func (m *CandidateMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *CandidateMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ClearDob clears the value of the "dob" field.
func (m *CandidateMutation) ClearDob() {
	m.dob = nil
	m.clearedFields[candidate.FieldDob] = struct{}{}
}

// DobCleared returns if the "dob" field was cleared in this mutation.
func (m *CandidateMutation) DobCleared() bool {
	_, ok := m.clearedFields[candidate.FieldDob]
	return ok
}

// ResetDob resets all changes to the "dob" field.
func (m *CandidateMutation) ResetDob() {
	m.dob = nil
	delete(m.clearedFields, candidate.FieldDob)
}

// SetIsBlacklist sets the "is_blacklist" field.
func (m *CandidateMutation) SetIsBlacklist(b bool) {
	m.is_blacklist = &b
}

// IsBlacklist returns the value of the "is_blacklist" field in the mutation.
func (m *CandidateMutation) IsBlacklist() (r bool, exists bool) {
	v := m.is_blacklist
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBlacklist returns the old "is_blacklist" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldIsBlacklist(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBlacklist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBlacklist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBlacklist: %w", err)
	}
	return oldValue.IsBlacklist, nil
}

// ResetIsBlacklist resets all changes to the "is_blacklist" field.
func (m *CandidateMutation) ResetIsBlacklist() {
	m.is_blacklist = nil
}

// SetLastApplyDate sets the "last_apply_date" field.
func (m *CandidateMutation) SetLastApplyDate(t time.Time) {
	m.last_apply_date = &t
}

// LastApplyDate returns the value of the "last_apply_date" field in the mutation.
func (m *CandidateMutation) LastApplyDate() (r time.Time, exists bool) {
	v := m.last_apply_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastApplyDate returns the old "last_apply_date" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldLastApplyDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastApplyDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastApplyDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastApplyDate: %w", err)
	}
	return oldValue.LastApplyDate, nil
}

// ClearLastApplyDate clears the value of the "last_apply_date" field.
func (m *CandidateMutation) ClearLastApplyDate() {
	m.last_apply_date = nil
	m.clearedFields[candidate.FieldLastApplyDate] = struct{}{}
}

// LastApplyDateCleared returns if the "last_apply_date" field was cleared in this mutation.
func (m *CandidateMutation) LastApplyDateCleared() bool {
	_, ok := m.clearedFields[candidate.FieldLastApplyDate]
	return ok
}

// ResetLastApplyDate resets all changes to the "last_apply_date" field.
func (m *CandidateMutation) ResetLastApplyDate() {
	m.last_apply_date = nil
	delete(m.clearedFields, candidate.FieldLastApplyDate)
}

// AddCandidateJobEdgeIDs adds the "candidate_job_edges" edge to the CandidateJob entity by ids.
func (m *CandidateMutation) AddCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_job_edges == nil {
		m.candidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobEdges clears the "candidate_job_edges" edge to the CandidateJob entity.
func (m *CandidateMutation) ClearCandidateJobEdges() {
	m.clearedcandidate_job_edges = true
}

// CandidateJobEdgesCleared reports if the "candidate_job_edges" edge to the CandidateJob entity was cleared.
func (m *CandidateMutation) CandidateJobEdgesCleared() bool {
	return m.clearedcandidate_job_edges
}

// RemoveCandidateJobEdgeIDs removes the "candidate_job_edges" edge to the CandidateJob entity by IDs.
func (m *CandidateMutation) RemoveCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_edges == nil {
		m.removedcandidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_edges, ids[i])
		m.removedcandidate_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobEdges returns the removed IDs of the "candidate_job_edges" edge to the CandidateJob entity.
func (m *CandidateMutation) RemovedCandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateJobEdgesIDs returns the "candidate_job_edges" edge IDs in the mutation.
func (m *CandidateMutation) CandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobEdges resets all changes to the "candidate_job_edges" edge.
func (m *CandidateMutation) ResetCandidateJobEdges() {
	m.candidate_job_edges = nil
	m.clearedcandidate_job_edges = false
	m.removedcandidate_job_edges = nil
}

// Where appends a list predicates to the CandidateMutation builder.
func (m *CandidateMutation) Where(ps ...predicate.Candidate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Candidate).
func (m *CandidateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, candidate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidate.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, candidate.FieldName)
	}
	if m.email != nil {
		fields = append(fields, candidate.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, candidate.FieldPhone)
	}
	if m.dob != nil {
		fields = append(fields, candidate.FieldDob)
	}
	if m.is_blacklist != nil {
		fields = append(fields, candidate.FieldIsBlacklist)
	}
	if m.last_apply_date != nil {
		fields = append(fields, candidate.FieldLastApplyDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidate.FieldCreatedAt:
		return m.CreatedAt()
	case candidate.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidate.FieldDeletedAt:
		return m.DeletedAt()
	case candidate.FieldName:
		return m.Name()
	case candidate.FieldEmail:
		return m.Email()
	case candidate.FieldPhone:
		return m.Phone()
	case candidate.FieldDob:
		return m.Dob()
	case candidate.FieldIsBlacklist:
		return m.IsBlacklist()
	case candidate.FieldLastApplyDate:
		return m.LastApplyDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidate.FieldName:
		return m.OldName(ctx)
	case candidate.FieldEmail:
		return m.OldEmail(ctx)
	case candidate.FieldPhone:
		return m.OldPhone(ctx)
	case candidate.FieldDob:
		return m.OldDob(ctx)
	case candidate.FieldIsBlacklist:
		return m.OldIsBlacklist(ctx)
	case candidate.FieldLastApplyDate:
		return m.OldLastApplyDate(ctx)
	}
	return nil, fmt.Errorf("unknown Candidate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case candidate.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case candidate.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case candidate.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case candidate.FieldIsBlacklist:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBlacklist(v)
		return nil
	case candidate.FieldLastApplyDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastApplyDate(v)
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Candidate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidate.FieldUpdatedAt) {
		fields = append(fields, candidate.FieldUpdatedAt)
	}
	if m.FieldCleared(candidate.FieldDeletedAt) {
		fields = append(fields, candidate.FieldDeletedAt)
	}
	if m.FieldCleared(candidate.FieldDob) {
		fields = append(fields, candidate.FieldDob)
	}
	if m.FieldCleared(candidate.FieldLastApplyDate) {
		fields = append(fields, candidate.FieldLastApplyDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateMutation) ClearField(name string) error {
	switch name {
	case candidate.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidate.FieldDob:
		m.ClearDob()
		return nil
	case candidate.FieldLastApplyDate:
		m.ClearLastApplyDate()
		return nil
	}
	return fmt.Errorf("unknown Candidate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateMutation) ResetField(name string) error {
	switch name {
	case candidate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidate.FieldName:
		m.ResetName()
		return nil
	case candidate.FieldEmail:
		m.ResetEmail()
		return nil
	case candidate.FieldPhone:
		m.ResetPhone()
		return nil
	case candidate.FieldDob:
		m.ResetDob()
		return nil
	case candidate.FieldIsBlacklist:
		m.ResetIsBlacklist()
		return nil
	case candidate.FieldLastApplyDate:
		m.ResetLastApplyDate()
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.candidate_job_edges != nil {
		edges = append(edges, candidate.EdgeCandidateJobEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.candidate_job_edges))
		for id := range m.candidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcandidate_job_edges != nil {
		edges = append(edges, candidate.EdgeCandidateJobEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_edges))
		for id := range m.removedcandidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcandidate_job_edges {
		edges = append(edges, candidate.EdgeCandidateJobEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateMutation) EdgeCleared(name string) bool {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		return m.clearedcandidate_job_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Candidate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateMutation) ResetEdge(name string) error {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		m.ResetCandidateJobEdges()
		return nil
	}
	return fmt.Errorf("unknown Candidate edge %s", name)
}

// CandidateInterviewMutation represents an operation that mutates the CandidateInterview nodes in the graph.
type CandidateInterviewMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	title                     *string
	candidate_job_status      *candidateinterview.CandidateJobStatus
	interview_date            *time.Time
	start_from                *time.Time
	end_at                    *time.Time
	description               *string
	clearedFields             map[string]struct{}
	candidate_job_edge        *uuid.UUID
	clearedcandidate_job_edge bool
	attachment_edges          map[uuid.UUID]struct{}
	removedattachment_edges   map[uuid.UUID]struct{}
	clearedattachment_edges   bool
	interviewer_edges         map[uuid.UUID]struct{}
	removedinterviewer_edges  map[uuid.UUID]struct{}
	clearedinterviewer_edges  bool
	created_by_edge           *uuid.UUID
	clearedcreated_by_edge    bool
	user_interviewers         map[uuid.UUID]struct{}
	removeduser_interviewers  map[uuid.UUID]struct{}
	cleareduser_interviewers  bool
	done                      bool
	oldValue                  func(context.Context) (*CandidateInterview, error)
	predicates                []predicate.CandidateInterview
}

var _ ent.Mutation = (*CandidateInterviewMutation)(nil)

// candidateinterviewOption allows management of the mutation configuration using functional options.
type candidateinterviewOption func(*CandidateInterviewMutation)

// newCandidateInterviewMutation creates new mutation for the CandidateInterview entity.
func newCandidateInterviewMutation(c config, op Op, opts ...candidateinterviewOption) *CandidateInterviewMutation {
	m := &CandidateInterviewMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateInterview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateInterviewID sets the ID field of the mutation.
func withCandidateInterviewID(id uuid.UUID) candidateinterviewOption {
	return func(m *CandidateInterviewMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateInterview
		)
		m.oldValue = func(ctx context.Context) (*CandidateInterview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateInterview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateInterview sets the old CandidateInterview of the mutation.
func withCandidateInterview(node *CandidateInterview) candidateinterviewOption {
	return func(m *CandidateInterviewMutation) {
		m.oldValue = func(context.Context) (*CandidateInterview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateInterviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateInterviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateInterview entities.
func (m *CandidateInterviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateInterviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateInterviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateInterview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateInterviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateInterviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateInterviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateInterviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateInterviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateInterviewMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidateinterview.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateInterviewMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateInterviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidateinterview.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateInterviewMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateInterviewMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateInterviewMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidateinterview.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateInterviewMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateInterviewMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidateinterview.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *CandidateInterviewMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CandidateInterviewMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CandidateInterviewMutation) ResetTitle() {
	m.title = nil
}

// SetCandidateJobStatus sets the "candidate_job_status" field.
func (m *CandidateInterviewMutation) SetCandidateJobStatus(cjs candidateinterview.CandidateJobStatus) {
	m.candidate_job_status = &cjs
}

// CandidateJobStatus returns the value of the "candidate_job_status" field in the mutation.
func (m *CandidateInterviewMutation) CandidateJobStatus() (r candidateinterview.CandidateJobStatus, exists bool) {
	v := m.candidate_job_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobStatus returns the old "candidate_job_status" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCandidateJobStatus(ctx context.Context) (v candidateinterview.CandidateJobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobStatus: %w", err)
	}
	return oldValue.CandidateJobStatus, nil
}

// ResetCandidateJobStatus resets all changes to the "candidate_job_status" field.
func (m *CandidateInterviewMutation) ResetCandidateJobStatus() {
	m.candidate_job_status = nil
}

// SetCandidateJobID sets the "candidate_job_id" field.
func (m *CandidateInterviewMutation) SetCandidateJobID(u uuid.UUID) {
	m.candidate_job_edge = &u
}

// CandidateJobID returns the value of the "candidate_job_id" field in the mutation.
func (m *CandidateInterviewMutation) CandidateJobID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobID returns the old "candidate_job_id" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCandidateJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobID: %w", err)
	}
	return oldValue.CandidateJobID, nil
}

// ClearCandidateJobID clears the value of the "candidate_job_id" field.
func (m *CandidateInterviewMutation) ClearCandidateJobID() {
	m.candidate_job_edge = nil
	m.clearedFields[candidateinterview.FieldCandidateJobID] = struct{}{}
}

// CandidateJobIDCleared returns if the "candidate_job_id" field was cleared in this mutation.
func (m *CandidateInterviewMutation) CandidateJobIDCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldCandidateJobID]
	return ok
}

// ResetCandidateJobID resets all changes to the "candidate_job_id" field.
func (m *CandidateInterviewMutation) ResetCandidateJobID() {
	m.candidate_job_edge = nil
	delete(m.clearedFields, candidateinterview.FieldCandidateJobID)
}

// SetInterviewDate sets the "interview_date" field.
func (m *CandidateInterviewMutation) SetInterviewDate(t time.Time) {
	m.interview_date = &t
}

// InterviewDate returns the value of the "interview_date" field in the mutation.
func (m *CandidateInterviewMutation) InterviewDate() (r time.Time, exists bool) {
	v := m.interview_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewDate returns the old "interview_date" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldInterviewDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewDate: %w", err)
	}
	return oldValue.InterviewDate, nil
}

// ClearInterviewDate clears the value of the "interview_date" field.
func (m *CandidateInterviewMutation) ClearInterviewDate() {
	m.interview_date = nil
	m.clearedFields[candidateinterview.FieldInterviewDate] = struct{}{}
}

// InterviewDateCleared returns if the "interview_date" field was cleared in this mutation.
func (m *CandidateInterviewMutation) InterviewDateCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldInterviewDate]
	return ok
}

// ResetInterviewDate resets all changes to the "interview_date" field.
func (m *CandidateInterviewMutation) ResetInterviewDate() {
	m.interview_date = nil
	delete(m.clearedFields, candidateinterview.FieldInterviewDate)
}

// SetStartFrom sets the "start_from" field.
func (m *CandidateInterviewMutation) SetStartFrom(t time.Time) {
	m.start_from = &t
}

// StartFrom returns the value of the "start_from" field in the mutation.
func (m *CandidateInterviewMutation) StartFrom() (r time.Time, exists bool) {
	v := m.start_from
	if v == nil {
		return
	}
	return *v, true
}

// OldStartFrom returns the old "start_from" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldStartFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartFrom: %w", err)
	}
	return oldValue.StartFrom, nil
}

// ClearStartFrom clears the value of the "start_from" field.
func (m *CandidateInterviewMutation) ClearStartFrom() {
	m.start_from = nil
	m.clearedFields[candidateinterview.FieldStartFrom] = struct{}{}
}

// StartFromCleared returns if the "start_from" field was cleared in this mutation.
func (m *CandidateInterviewMutation) StartFromCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldStartFrom]
	return ok
}

// ResetStartFrom resets all changes to the "start_from" field.
func (m *CandidateInterviewMutation) ResetStartFrom() {
	m.start_from = nil
	delete(m.clearedFields, candidateinterview.FieldStartFrom)
}

// SetEndAt sets the "end_at" field.
func (m *CandidateInterviewMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *CandidateInterviewMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *CandidateInterviewMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[candidateinterview.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *CandidateInterviewMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *CandidateInterviewMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, candidateinterview.FieldEndAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *CandidateInterviewMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CandidateInterviewMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CandidateInterviewMutation) ClearCreatedBy() {
	m.created_by_edge = nil
	m.clearedFields[candidateinterview.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CandidateInterviewMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CandidateInterviewMutation) ResetCreatedBy() {
	m.created_by_edge = nil
	delete(m.clearedFields, candidateinterview.FieldCreatedBy)
}

// SetDescription sets the "description" field.
func (m *CandidateInterviewMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CandidateInterviewMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CandidateInterviewMutation) ResetDescription() {
	m.description = nil
}

// SetCandidateJobEdgeID sets the "candidate_job_edge" edge to the CandidateJob entity by id.
func (m *CandidateInterviewMutation) SetCandidateJobEdgeID(id uuid.UUID) {
	m.candidate_job_edge = &id
}

// ClearCandidateJobEdge clears the "candidate_job_edge" edge to the CandidateJob entity.
func (m *CandidateInterviewMutation) ClearCandidateJobEdge() {
	m.clearedcandidate_job_edge = true
}

// CandidateJobEdgeCleared reports if the "candidate_job_edge" edge to the CandidateJob entity was cleared.
func (m *CandidateInterviewMutation) CandidateJobEdgeCleared() bool {
	return m.CandidateJobIDCleared() || m.clearedcandidate_job_edge
}

// CandidateJobEdgeID returns the "candidate_job_edge" edge ID in the mutation.
func (m *CandidateInterviewMutation) CandidateJobEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_edge != nil {
		return *m.candidate_job_edge, true
	}
	return
}

// CandidateJobEdgeIDs returns the "candidate_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewMutation) CandidateJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobEdge resets all changes to the "candidate_job_edge" edge.
func (m *CandidateInterviewMutation) ResetCandidateJobEdge() {
	m.candidate_job_edge = nil
	m.clearedcandidate_job_edge = false
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateInterviewMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateInterviewMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateInterviewMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateInterviewMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateInterviewMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateInterviewMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateInterviewMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// AddInterviewerEdgeIDs adds the "interviewer_edges" edge to the User entity by ids.
func (m *CandidateInterviewMutation) AddInterviewerEdgeIDs(ids ...uuid.UUID) {
	if m.interviewer_edges == nil {
		m.interviewer_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interviewer_edges[ids[i]] = struct{}{}
	}
}

// ClearInterviewerEdges clears the "interviewer_edges" edge to the User entity.
func (m *CandidateInterviewMutation) ClearInterviewerEdges() {
	m.clearedinterviewer_edges = true
}

// InterviewerEdgesCleared reports if the "interviewer_edges" edge to the User entity was cleared.
func (m *CandidateInterviewMutation) InterviewerEdgesCleared() bool {
	return m.clearedinterviewer_edges
}

// RemoveInterviewerEdgeIDs removes the "interviewer_edges" edge to the User entity by IDs.
func (m *CandidateInterviewMutation) RemoveInterviewerEdgeIDs(ids ...uuid.UUID) {
	if m.removedinterviewer_edges == nil {
		m.removedinterviewer_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interviewer_edges, ids[i])
		m.removedinterviewer_edges[ids[i]] = struct{}{}
	}
}

// RemovedInterviewerEdges returns the removed IDs of the "interviewer_edges" edge to the User entity.
func (m *CandidateInterviewMutation) RemovedInterviewerEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedinterviewer_edges {
		ids = append(ids, id)
	}
	return
}

// InterviewerEdgesIDs returns the "interviewer_edges" edge IDs in the mutation.
func (m *CandidateInterviewMutation) InterviewerEdgesIDs() (ids []uuid.UUID) {
	for id := range m.interviewer_edges {
		ids = append(ids, id)
	}
	return
}

// ResetInterviewerEdges resets all changes to the "interviewer_edges" edge.
func (m *CandidateInterviewMutation) ResetInterviewerEdges() {
	m.interviewer_edges = nil
	m.clearedinterviewer_edges = false
	m.removedinterviewer_edges = nil
}

// SetCreatedByEdgeID sets the "created_by_edge" edge to the User entity by id.
func (m *CandidateInterviewMutation) SetCreatedByEdgeID(id uuid.UUID) {
	m.created_by_edge = &id
}

// ClearCreatedByEdge clears the "created_by_edge" edge to the User entity.
func (m *CandidateInterviewMutation) ClearCreatedByEdge() {
	m.clearedcreated_by_edge = true
}

// CreatedByEdgeCleared reports if the "created_by_edge" edge to the User entity was cleared.
func (m *CandidateInterviewMutation) CreatedByEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_edge
}

// CreatedByEdgeID returns the "created_by_edge" edge ID in the mutation.
func (m *CandidateInterviewMutation) CreatedByEdgeID() (id uuid.UUID, exists bool) {
	if m.created_by_edge != nil {
		return *m.created_by_edge, true
	}
	return
}

// CreatedByEdgeIDs returns the "created_by_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewMutation) CreatedByEdgeIDs() (ids []uuid.UUID) {
	if id := m.created_by_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByEdge resets all changes to the "created_by_edge" edge.
func (m *CandidateInterviewMutation) ResetCreatedByEdge() {
	m.created_by_edge = nil
	m.clearedcreated_by_edge = false
}

// AddUserInterviewerIDs adds the "user_interviewers" edge to the CandidateInterviewer entity by ids.
func (m *CandidateInterviewMutation) AddUserInterviewerIDs(ids ...uuid.UUID) {
	if m.user_interviewers == nil {
		m.user_interviewers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_interviewers[ids[i]] = struct{}{}
	}
}

// ClearUserInterviewers clears the "user_interviewers" edge to the CandidateInterviewer entity.
func (m *CandidateInterviewMutation) ClearUserInterviewers() {
	m.cleareduser_interviewers = true
}

// UserInterviewersCleared reports if the "user_interviewers" edge to the CandidateInterviewer entity was cleared.
func (m *CandidateInterviewMutation) UserInterviewersCleared() bool {
	return m.cleareduser_interviewers
}

// RemoveUserInterviewerIDs removes the "user_interviewers" edge to the CandidateInterviewer entity by IDs.
func (m *CandidateInterviewMutation) RemoveUserInterviewerIDs(ids ...uuid.UUID) {
	if m.removeduser_interviewers == nil {
		m.removeduser_interviewers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_interviewers, ids[i])
		m.removeduser_interviewers[ids[i]] = struct{}{}
	}
}

// RemovedUserInterviewers returns the removed IDs of the "user_interviewers" edge to the CandidateInterviewer entity.
func (m *CandidateInterviewMutation) RemovedUserInterviewersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_interviewers {
		ids = append(ids, id)
	}
	return
}

// UserInterviewersIDs returns the "user_interviewers" edge IDs in the mutation.
func (m *CandidateInterviewMutation) UserInterviewersIDs() (ids []uuid.UUID) {
	for id := range m.user_interviewers {
		ids = append(ids, id)
	}
	return
}

// ResetUserInterviewers resets all changes to the "user_interviewers" edge.
func (m *CandidateInterviewMutation) ResetUserInterviewers() {
	m.user_interviewers = nil
	m.cleareduser_interviewers = false
	m.removeduser_interviewers = nil
}

// Where appends a list predicates to the CandidateInterviewMutation builder.
func (m *CandidateInterviewMutation) Where(ps ...predicate.CandidateInterview) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateInterviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateInterview).
func (m *CandidateInterviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateInterviewMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, candidateinterview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidateinterview.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidateinterview.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, candidateinterview.FieldTitle)
	}
	if m.candidate_job_status != nil {
		fields = append(fields, candidateinterview.FieldCandidateJobStatus)
	}
	if m.candidate_job_edge != nil {
		fields = append(fields, candidateinterview.FieldCandidateJobID)
	}
	if m.interview_date != nil {
		fields = append(fields, candidateinterview.FieldInterviewDate)
	}
	if m.start_from != nil {
		fields = append(fields, candidateinterview.FieldStartFrom)
	}
	if m.end_at != nil {
		fields = append(fields, candidateinterview.FieldEndAt)
	}
	if m.created_by_edge != nil {
		fields = append(fields, candidateinterview.FieldCreatedBy)
	}
	if m.description != nil {
		fields = append(fields, candidateinterview.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateInterviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidateinterview.FieldCreatedAt:
		return m.CreatedAt()
	case candidateinterview.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidateinterview.FieldDeletedAt:
		return m.DeletedAt()
	case candidateinterview.FieldTitle:
		return m.Title()
	case candidateinterview.FieldCandidateJobStatus:
		return m.CandidateJobStatus()
	case candidateinterview.FieldCandidateJobID:
		return m.CandidateJobID()
	case candidateinterview.FieldInterviewDate:
		return m.InterviewDate()
	case candidateinterview.FieldStartFrom:
		return m.StartFrom()
	case candidateinterview.FieldEndAt:
		return m.EndAt()
	case candidateinterview.FieldCreatedBy:
		return m.CreatedBy()
	case candidateinterview.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateInterviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidateinterview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidateinterview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidateinterview.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidateinterview.FieldTitle:
		return m.OldTitle(ctx)
	case candidateinterview.FieldCandidateJobStatus:
		return m.OldCandidateJobStatus(ctx)
	case candidateinterview.FieldCandidateJobID:
		return m.OldCandidateJobID(ctx)
	case candidateinterview.FieldInterviewDate:
		return m.OldInterviewDate(ctx)
	case candidateinterview.FieldStartFrom:
		return m.OldStartFrom(ctx)
	case candidateinterview.FieldEndAt:
		return m.OldEndAt(ctx)
	case candidateinterview.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case candidateinterview.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateInterview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidateinterview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidateinterview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidateinterview.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidateinterview.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case candidateinterview.FieldCandidateJobStatus:
		v, ok := value.(candidateinterview.CandidateJobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobStatus(v)
		return nil
	case candidateinterview.FieldCandidateJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobID(v)
		return nil
	case candidateinterview.FieldInterviewDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewDate(v)
		return nil
	case candidateinterview.FieldStartFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartFrom(v)
		return nil
	case candidateinterview.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case candidateinterview.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case candidateinterview.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateInterviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateInterviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateInterview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateInterviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidateinterview.FieldUpdatedAt) {
		fields = append(fields, candidateinterview.FieldUpdatedAt)
	}
	if m.FieldCleared(candidateinterview.FieldDeletedAt) {
		fields = append(fields, candidateinterview.FieldDeletedAt)
	}
	if m.FieldCleared(candidateinterview.FieldCandidateJobID) {
		fields = append(fields, candidateinterview.FieldCandidateJobID)
	}
	if m.FieldCleared(candidateinterview.FieldInterviewDate) {
		fields = append(fields, candidateinterview.FieldInterviewDate)
	}
	if m.FieldCleared(candidateinterview.FieldStartFrom) {
		fields = append(fields, candidateinterview.FieldStartFrom)
	}
	if m.FieldCleared(candidateinterview.FieldEndAt) {
		fields = append(fields, candidateinterview.FieldEndAt)
	}
	if m.FieldCleared(candidateinterview.FieldCreatedBy) {
		fields = append(fields, candidateinterview.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateInterviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateInterviewMutation) ClearField(name string) error {
	switch name {
	case candidateinterview.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidateinterview.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidateinterview.FieldCandidateJobID:
		m.ClearCandidateJobID()
		return nil
	case candidateinterview.FieldInterviewDate:
		m.ClearInterviewDate()
		return nil
	case candidateinterview.FieldStartFrom:
		m.ClearStartFrom()
		return nil
	case candidateinterview.FieldEndAt:
		m.ClearEndAt()
		return nil
	case candidateinterview.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateInterviewMutation) ResetField(name string) error {
	switch name {
	case candidateinterview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidateinterview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidateinterview.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidateinterview.FieldTitle:
		m.ResetTitle()
		return nil
	case candidateinterview.FieldCandidateJobStatus:
		m.ResetCandidateJobStatus()
		return nil
	case candidateinterview.FieldCandidateJobID:
		m.ResetCandidateJobID()
		return nil
	case candidateinterview.FieldInterviewDate:
		m.ResetInterviewDate()
		return nil
	case candidateinterview.FieldStartFrom:
		m.ResetStartFrom()
		return nil
	case candidateinterview.FieldEndAt:
		m.ResetEndAt()
		return nil
	case candidateinterview.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case candidateinterview.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateInterviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.candidate_job_edge != nil {
		edges = append(edges, candidateinterview.EdgeCandidateJobEdge)
	}
	if m.attachment_edges != nil {
		edges = append(edges, candidateinterview.EdgeAttachmentEdges)
	}
	if m.interviewer_edges != nil {
		edges = append(edges, candidateinterview.EdgeInterviewerEdges)
	}
	if m.created_by_edge != nil {
		edges = append(edges, candidateinterview.EdgeCreatedByEdge)
	}
	if m.user_interviewers != nil {
		edges = append(edges, candidateinterview.EdgeUserInterviewers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateInterviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		if id := m.candidate_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidateinterview.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeInterviewerEdges:
		ids := make([]ent.Value, 0, len(m.interviewer_edges))
		for id := range m.interviewer_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeCreatedByEdge:
		if id := m.created_by_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidateinterview.EdgeUserInterviewers:
		ids := make([]ent.Value, 0, len(m.user_interviewers))
		for id := range m.user_interviewers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateInterviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedattachment_edges != nil {
		edges = append(edges, candidateinterview.EdgeAttachmentEdges)
	}
	if m.removedinterviewer_edges != nil {
		edges = append(edges, candidateinterview.EdgeInterviewerEdges)
	}
	if m.removeduser_interviewers != nil {
		edges = append(edges, candidateinterview.EdgeUserInterviewers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateInterviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidateinterview.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeInterviewerEdges:
		ids := make([]ent.Value, 0, len(m.removedinterviewer_edges))
		for id := range m.removedinterviewer_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeUserInterviewers:
		ids := make([]ent.Value, 0, len(m.removeduser_interviewers))
		for id := range m.removeduser_interviewers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateInterviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcandidate_job_edge {
		edges = append(edges, candidateinterview.EdgeCandidateJobEdge)
	}
	if m.clearedattachment_edges {
		edges = append(edges, candidateinterview.EdgeAttachmentEdges)
	}
	if m.clearedinterviewer_edges {
		edges = append(edges, candidateinterview.EdgeInterviewerEdges)
	}
	if m.clearedcreated_by_edge {
		edges = append(edges, candidateinterview.EdgeCreatedByEdge)
	}
	if m.cleareduser_interviewers {
		edges = append(edges, candidateinterview.EdgeUserInterviewers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateInterviewMutation) EdgeCleared(name string) bool {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		return m.clearedcandidate_job_edge
	case candidateinterview.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	case candidateinterview.EdgeInterviewerEdges:
		return m.clearedinterviewer_edges
	case candidateinterview.EdgeCreatedByEdge:
		return m.clearedcreated_by_edge
	case candidateinterview.EdgeUserInterviewers:
		return m.cleareduser_interviewers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateInterviewMutation) ClearEdge(name string) error {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		m.ClearCandidateJobEdge()
		return nil
	case candidateinterview.EdgeCreatedByEdge:
		m.ClearCreatedByEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateInterviewMutation) ResetEdge(name string) error {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		m.ResetCandidateJobEdge()
		return nil
	case candidateinterview.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	case candidateinterview.EdgeInterviewerEdges:
		m.ResetInterviewerEdges()
		return nil
	case candidateinterview.EdgeCreatedByEdge:
		m.ResetCreatedByEdge()
		return nil
	case candidateinterview.EdgeUserInterviewers:
		m.ResetUserInterviewers()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview edge %s", name)
}

// CandidateInterviewerMutation represents an operation that mutates the CandidateInterviewer nodes in the graph.
type CandidateInterviewerMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	user_edge             *uuid.UUID
	cleareduser_edge      bool
	interview_edge        *uuid.UUID
	clearedinterview_edge bool
	done                  bool
	oldValue              func(context.Context) (*CandidateInterviewer, error)
	predicates            []predicate.CandidateInterviewer
}

var _ ent.Mutation = (*CandidateInterviewerMutation)(nil)

// candidateinterviewerOption allows management of the mutation configuration using functional options.
type candidateinterviewerOption func(*CandidateInterviewerMutation)

// newCandidateInterviewerMutation creates new mutation for the CandidateInterviewer entity.
func newCandidateInterviewerMutation(c config, op Op, opts ...candidateinterviewerOption) *CandidateInterviewerMutation {
	m := &CandidateInterviewerMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateInterviewer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateInterviewerID sets the ID field of the mutation.
func withCandidateInterviewerID(id uuid.UUID) candidateinterviewerOption {
	return func(m *CandidateInterviewerMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateInterviewer
		)
		m.oldValue = func(ctx context.Context) (*CandidateInterviewer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateInterviewer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateInterviewer sets the old CandidateInterviewer of the mutation.
func withCandidateInterviewer(node *CandidateInterviewer) candidateinterviewerOption {
	return func(m *CandidateInterviewerMutation) {
		m.oldValue = func(context.Context) (*CandidateInterviewer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateInterviewerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateInterviewerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateInterviewer entities.
func (m *CandidateInterviewerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateInterviewerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateInterviewerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateInterviewer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateInterviewerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateInterviewerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateInterviewerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateInterviewerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateInterviewerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateInterviewerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidateinterviewer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateInterviewerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterviewer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateInterviewerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidateinterviewer.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateInterviewerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateInterviewerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateInterviewerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidateinterviewer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateInterviewerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterviewer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateInterviewerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidateinterviewer.FieldDeletedAt)
}

// SetCandidateInterviewID sets the "candidate_interview_id" field.
func (m *CandidateInterviewerMutation) SetCandidateInterviewID(u uuid.UUID) {
	m.interview_edge = &u
}

// CandidateInterviewID returns the value of the "candidate_interview_id" field in the mutation.
func (m *CandidateInterviewerMutation) CandidateInterviewID() (r uuid.UUID, exists bool) {
	v := m.interview_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateInterviewID returns the old "candidate_interview_id" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldCandidateInterviewID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateInterviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateInterviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateInterviewID: %w", err)
	}
	return oldValue.CandidateInterviewID, nil
}

// ResetCandidateInterviewID resets all changes to the "candidate_interview_id" field.
func (m *CandidateInterviewerMutation) ResetCandidateInterviewID() {
	m.interview_edge = nil
}

// SetUserID sets the "user_id" field.
func (m *CandidateInterviewerMutation) SetUserID(u uuid.UUID) {
	m.user_edge = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CandidateInterviewerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CandidateInterviewerMutation) ResetUserID() {
	m.user_edge = nil
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *CandidateInterviewerMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *CandidateInterviewerMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *CandidateInterviewerMutation) UserEdgeCleared() bool {
	return m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *CandidateInterviewerMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewerMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *CandidateInterviewerMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetInterviewEdgeID sets the "interview_edge" edge to the CandidateInterview entity by id.
func (m *CandidateInterviewerMutation) SetInterviewEdgeID(id uuid.UUID) {
	m.interview_edge = &id
}

// ClearInterviewEdge clears the "interview_edge" edge to the CandidateInterview entity.
func (m *CandidateInterviewerMutation) ClearInterviewEdge() {
	m.clearedinterview_edge = true
}

// InterviewEdgeCleared reports if the "interview_edge" edge to the CandidateInterview entity was cleared.
func (m *CandidateInterviewerMutation) InterviewEdgeCleared() bool {
	return m.clearedinterview_edge
}

// InterviewEdgeID returns the "interview_edge" edge ID in the mutation.
func (m *CandidateInterviewerMutation) InterviewEdgeID() (id uuid.UUID, exists bool) {
	if m.interview_edge != nil {
		return *m.interview_edge, true
	}
	return
}

// InterviewEdgeIDs returns the "interview_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InterviewEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewerMutation) InterviewEdgeIDs() (ids []uuid.UUID) {
	if id := m.interview_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInterviewEdge resets all changes to the "interview_edge" edge.
func (m *CandidateInterviewerMutation) ResetInterviewEdge() {
	m.interview_edge = nil
	m.clearedinterview_edge = false
}

// Where appends a list predicates to the CandidateInterviewerMutation builder.
func (m *CandidateInterviewerMutation) Where(ps ...predicate.CandidateInterviewer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateInterviewerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateInterviewer).
func (m *CandidateInterviewerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateInterviewerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, candidateinterviewer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidateinterviewer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidateinterviewer.FieldDeletedAt)
	}
	if m.interview_edge != nil {
		fields = append(fields, candidateinterviewer.FieldCandidateInterviewID)
	}
	if m.user_edge != nil {
		fields = append(fields, candidateinterviewer.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateInterviewerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		return m.CreatedAt()
	case candidateinterviewer.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidateinterviewer.FieldDeletedAt:
		return m.DeletedAt()
	case candidateinterviewer.FieldCandidateInterviewID:
		return m.CandidateInterviewID()
	case candidateinterviewer.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateInterviewerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidateinterviewer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidateinterviewer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidateinterviewer.FieldCandidateInterviewID:
		return m.OldCandidateInterviewID(ctx)
	case candidateinterviewer.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateInterviewer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidateinterviewer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidateinterviewer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidateinterviewer.FieldCandidateInterviewID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateInterviewID(v)
		return nil
	case candidateinterviewer.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateInterviewerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateInterviewerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateInterviewer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateInterviewerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidateinterviewer.FieldUpdatedAt) {
		fields = append(fields, candidateinterviewer.FieldUpdatedAt)
	}
	if m.FieldCleared(candidateinterviewer.FieldDeletedAt) {
		fields = append(fields, candidateinterviewer.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateInterviewerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateInterviewerMutation) ClearField(name string) error {
	switch name {
	case candidateinterviewer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidateinterviewer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateInterviewerMutation) ResetField(name string) error {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidateinterviewer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidateinterviewer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidateinterviewer.FieldCandidateInterviewID:
		m.ResetCandidateInterviewID()
		return nil
	case candidateinterviewer.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateInterviewerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_edge != nil {
		edges = append(edges, candidateinterviewer.EdgeUserEdge)
	}
	if m.interview_edge != nil {
		edges = append(edges, candidateinterviewer.EdgeInterviewEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateInterviewerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidateinterviewer.EdgeInterviewEdge:
		if id := m.interview_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateInterviewerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateInterviewerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateInterviewerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_edge {
		edges = append(edges, candidateinterviewer.EdgeUserEdge)
	}
	if m.clearedinterview_edge {
		edges = append(edges, candidateinterviewer.EdgeInterviewEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateInterviewerMutation) EdgeCleared(name string) bool {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		return m.cleareduser_edge
	case candidateinterviewer.EdgeInterviewEdge:
		return m.clearedinterview_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateInterviewerMutation) ClearEdge(name string) error {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case candidateinterviewer.EdgeInterviewEdge:
		m.ClearInterviewEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateInterviewerMutation) ResetEdge(name string) error {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case candidateinterviewer.EdgeInterviewEdge:
		m.ResetInterviewEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer edge %s", name)
}

// CandidateJobMutation represents an operation that mutates the CandidateJob nodes in the graph.
type CandidateJobMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	status                         *candidatejob.Status
	failed_reason                  *[]string
	appendfailed_reason            []string
	clearedFields                  map[string]struct{}
	attachment_edges               map[uuid.UUID]struct{}
	removedattachment_edges        map[uuid.UUID]struct{}
	clearedattachment_edges        bool
	hiring_job_edge                *uuid.UUID
	clearedhiring_job_edge         bool
	candidate_job_feedback         map[uuid.UUID]struct{}
	removedcandidate_job_feedback  map[uuid.UUID]struct{}
	clearedcandidate_job_feedback  bool
	candidate_edge                 *uuid.UUID
	clearedcandidate_edge          bool
	candidate_job_interview        map[uuid.UUID]struct{}
	removedcandidate_job_interview map[uuid.UUID]struct{}
	clearedcandidate_job_interview bool
	created_by_edge                *uuid.UUID
	clearedcreated_by_edge         bool
	candidate_job_step             map[uuid.UUID]struct{}
	removedcandidate_job_step      map[uuid.UUID]struct{}
	clearedcandidate_job_step      bool
	done                           bool
	oldValue                       func(context.Context) (*CandidateJob, error)
	predicates                     []predicate.CandidateJob
}

var _ ent.Mutation = (*CandidateJobMutation)(nil)

// candidatejobOption allows management of the mutation configuration using functional options.
type candidatejobOption func(*CandidateJobMutation)

// newCandidateJobMutation creates new mutation for the CandidateJob entity.
func newCandidateJobMutation(c config, op Op, opts ...candidatejobOption) *CandidateJobMutation {
	m := &CandidateJobMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateJobID sets the ID field of the mutation.
func withCandidateJobID(id uuid.UUID) candidatejobOption {
	return func(m *CandidateJobMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateJob
		)
		m.oldValue = func(ctx context.Context) (*CandidateJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateJob sets the old CandidateJob of the mutation.
func withCandidateJob(node *CandidateJob) candidatejobOption {
	return func(m *CandidateJobMutation) {
		m.oldValue = func(context.Context) (*CandidateJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateJob entities.
func (m *CandidateJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateJobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidatejob.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateJobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidatejob.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidatejob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidatejob.FieldDeletedAt)
}

// SetHiringJobID sets the "hiring_job_id" field.
func (m *CandidateJobMutation) SetHiringJobID(u uuid.UUID) {
	m.hiring_job_edge = &u
}

// HiringJobID returns the value of the "hiring_job_id" field in the mutation.
func (m *CandidateJobMutation) HiringJobID() (r uuid.UUID, exists bool) {
	v := m.hiring_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldHiringJobID returns the old "hiring_job_id" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldHiringJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHiringJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHiringJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiringJobID: %w", err)
	}
	return oldValue.HiringJobID, nil
}

// ClearHiringJobID clears the value of the "hiring_job_id" field.
func (m *CandidateJobMutation) ClearHiringJobID() {
	m.hiring_job_edge = nil
	m.clearedFields[candidatejob.FieldHiringJobID] = struct{}{}
}

// HiringJobIDCleared returns if the "hiring_job_id" field was cleared in this mutation.
func (m *CandidateJobMutation) HiringJobIDCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldHiringJobID]
	return ok
}

// ResetHiringJobID resets all changes to the "hiring_job_id" field.
func (m *CandidateJobMutation) ResetHiringJobID() {
	m.hiring_job_edge = nil
	delete(m.clearedFields, candidatejob.FieldHiringJobID)
}

// SetCandidateID sets the "candidate_id" field.
func (m *CandidateJobMutation) SetCandidateID(u uuid.UUID) {
	m.candidate_edge = &u
}

// CandidateID returns the value of the "candidate_id" field in the mutation.
func (m *CandidateJobMutation) CandidateID() (r uuid.UUID, exists bool) {
	v := m.candidate_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateID returns the old "candidate_id" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCandidateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateID: %w", err)
	}
	return oldValue.CandidateID, nil
}

// ClearCandidateID clears the value of the "candidate_id" field.
func (m *CandidateJobMutation) ClearCandidateID() {
	m.candidate_edge = nil
	m.clearedFields[candidatejob.FieldCandidateID] = struct{}{}
}

// CandidateIDCleared returns if the "candidate_id" field was cleared in this mutation.
func (m *CandidateJobMutation) CandidateIDCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldCandidateID]
	return ok
}

// ResetCandidateID resets all changes to the "candidate_id" field.
func (m *CandidateJobMutation) ResetCandidateID() {
	m.candidate_edge = nil
	delete(m.clearedFields, candidatejob.FieldCandidateID)
}

// SetCreatedBy sets the "created_by" field.
func (m *CandidateJobMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CandidateJobMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CandidateJobMutation) ClearCreatedBy() {
	m.created_by_edge = nil
	m.clearedFields[candidatejob.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CandidateJobMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CandidateJobMutation) ResetCreatedBy() {
	m.created_by_edge = nil
	delete(m.clearedFields, candidatejob.FieldCreatedBy)
}

// SetStatus sets the "status" field.
func (m *CandidateJobMutation) SetStatus(c candidatejob.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CandidateJobMutation) Status() (r candidatejob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldStatus(ctx context.Context) (v candidatejob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CandidateJobMutation) ResetStatus() {
	m.status = nil
}

// SetFailedReason sets the "failed_reason" field.
func (m *CandidateJobMutation) SetFailedReason(s []string) {
	m.failed_reason = &s
	m.appendfailed_reason = nil
}

// FailedReason returns the value of the "failed_reason" field in the mutation.
func (m *CandidateJobMutation) FailedReason() (r []string, exists bool) {
	v := m.failed_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedReason returns the old "failed_reason" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldFailedReason(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedReason: %w", err)
	}
	return oldValue.FailedReason, nil
}

// AppendFailedReason adds s to the "failed_reason" field.
func (m *CandidateJobMutation) AppendFailedReason(s []string) {
	m.appendfailed_reason = append(m.appendfailed_reason, s...)
}

// AppendedFailedReason returns the list of values that were appended to the "failed_reason" field in this mutation.
func (m *CandidateJobMutation) AppendedFailedReason() ([]string, bool) {
	if len(m.appendfailed_reason) == 0 {
		return nil, false
	}
	return m.appendfailed_reason, true
}

// ClearFailedReason clears the value of the "failed_reason" field.
func (m *CandidateJobMutation) ClearFailedReason() {
	m.failed_reason = nil
	m.appendfailed_reason = nil
	m.clearedFields[candidatejob.FieldFailedReason] = struct{}{}
}

// FailedReasonCleared returns if the "failed_reason" field was cleared in this mutation.
func (m *CandidateJobMutation) FailedReasonCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldFailedReason]
	return ok
}

// ResetFailedReason resets all changes to the "failed_reason" field.
func (m *CandidateJobMutation) ResetFailedReason() {
	m.failed_reason = nil
	m.appendfailed_reason = nil
	delete(m.clearedFields, candidatejob.FieldFailedReason)
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateJobMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateJobMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateJobMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateJobMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateJobMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// SetHiringJobEdgeID sets the "hiring_job_edge" edge to the HiringJob entity by id.
func (m *CandidateJobMutation) SetHiringJobEdgeID(id uuid.UUID) {
	m.hiring_job_edge = &id
}

// ClearHiringJobEdge clears the "hiring_job_edge" edge to the HiringJob entity.
func (m *CandidateJobMutation) ClearHiringJobEdge() {
	m.clearedhiring_job_edge = true
}

// HiringJobEdgeCleared reports if the "hiring_job_edge" edge to the HiringJob entity was cleared.
func (m *CandidateJobMutation) HiringJobEdgeCleared() bool {
	return m.HiringJobIDCleared() || m.clearedhiring_job_edge
}

// HiringJobEdgeID returns the "hiring_job_edge" edge ID in the mutation.
func (m *CandidateJobMutation) HiringJobEdgeID() (id uuid.UUID, exists bool) {
	if m.hiring_job_edge != nil {
		return *m.hiring_job_edge, true
	}
	return
}

// HiringJobEdgeIDs returns the "hiring_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HiringJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobMutation) HiringJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.hiring_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHiringJobEdge resets all changes to the "hiring_job_edge" edge.
func (m *CandidateJobMutation) ResetHiringJobEdge() {
	m.hiring_job_edge = nil
	m.clearedhiring_job_edge = false
}

// AddCandidateJobFeedbackIDs adds the "candidate_job_feedback" edge to the CandidateJobFeedback entity by ids.
func (m *CandidateJobMutation) AddCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.candidate_job_feedback == nil {
		m.candidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_feedback[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobFeedback clears the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *CandidateJobMutation) ClearCandidateJobFeedback() {
	m.clearedcandidate_job_feedback = true
}

// CandidateJobFeedbackCleared reports if the "candidate_job_feedback" edge to the CandidateJobFeedback entity was cleared.
func (m *CandidateJobMutation) CandidateJobFeedbackCleared() bool {
	return m.clearedcandidate_job_feedback
}

// RemoveCandidateJobFeedbackIDs removes the "candidate_job_feedback" edge to the CandidateJobFeedback entity by IDs.
func (m *CandidateJobMutation) RemoveCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_feedback == nil {
		m.removedcandidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_feedback, ids[i])
		m.removedcandidate_job_feedback[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobFeedback returns the removed IDs of the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *CandidateJobMutation) RemovedCandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// CandidateJobFeedbackIDs returns the "candidate_job_feedback" edge IDs in the mutation.
func (m *CandidateJobMutation) CandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobFeedback resets all changes to the "candidate_job_feedback" edge.
func (m *CandidateJobMutation) ResetCandidateJobFeedback() {
	m.candidate_job_feedback = nil
	m.clearedcandidate_job_feedback = false
	m.removedcandidate_job_feedback = nil
}

// SetCandidateEdgeID sets the "candidate_edge" edge to the Candidate entity by id.
func (m *CandidateJobMutation) SetCandidateEdgeID(id uuid.UUID) {
	m.candidate_edge = &id
}

// ClearCandidateEdge clears the "candidate_edge" edge to the Candidate entity.
func (m *CandidateJobMutation) ClearCandidateEdge() {
	m.clearedcandidate_edge = true
}

// CandidateEdgeCleared reports if the "candidate_edge" edge to the Candidate entity was cleared.
func (m *CandidateJobMutation) CandidateEdgeCleared() bool {
	return m.CandidateIDCleared() || m.clearedcandidate_edge
}

// CandidateEdgeID returns the "candidate_edge" edge ID in the mutation.
func (m *CandidateJobMutation) CandidateEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_edge != nil {
		return *m.candidate_edge, true
	}
	return
}

// CandidateEdgeIDs returns the "candidate_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobMutation) CandidateEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateEdge resets all changes to the "candidate_edge" edge.
func (m *CandidateJobMutation) ResetCandidateEdge() {
	m.candidate_edge = nil
	m.clearedcandidate_edge = false
}

// AddCandidateJobInterviewIDs adds the "candidate_job_interview" edge to the CandidateInterview entity by ids.
func (m *CandidateJobMutation) AddCandidateJobInterviewIDs(ids ...uuid.UUID) {
	if m.candidate_job_interview == nil {
		m.candidate_job_interview = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_interview[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobInterview clears the "candidate_job_interview" edge to the CandidateInterview entity.
func (m *CandidateJobMutation) ClearCandidateJobInterview() {
	m.clearedcandidate_job_interview = true
}

// CandidateJobInterviewCleared reports if the "candidate_job_interview" edge to the CandidateInterview entity was cleared.
func (m *CandidateJobMutation) CandidateJobInterviewCleared() bool {
	return m.clearedcandidate_job_interview
}

// RemoveCandidateJobInterviewIDs removes the "candidate_job_interview" edge to the CandidateInterview entity by IDs.
func (m *CandidateJobMutation) RemoveCandidateJobInterviewIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_interview == nil {
		m.removedcandidate_job_interview = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_interview, ids[i])
		m.removedcandidate_job_interview[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobInterview returns the removed IDs of the "candidate_job_interview" edge to the CandidateInterview entity.
func (m *CandidateJobMutation) RemovedCandidateJobInterviewIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_interview {
		ids = append(ids, id)
	}
	return
}

// CandidateJobInterviewIDs returns the "candidate_job_interview" edge IDs in the mutation.
func (m *CandidateJobMutation) CandidateJobInterviewIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_interview {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobInterview resets all changes to the "candidate_job_interview" edge.
func (m *CandidateJobMutation) ResetCandidateJobInterview() {
	m.candidate_job_interview = nil
	m.clearedcandidate_job_interview = false
	m.removedcandidate_job_interview = nil
}

// SetCreatedByEdgeID sets the "created_by_edge" edge to the User entity by id.
func (m *CandidateJobMutation) SetCreatedByEdgeID(id uuid.UUID) {
	m.created_by_edge = &id
}

// ClearCreatedByEdge clears the "created_by_edge" edge to the User entity.
func (m *CandidateJobMutation) ClearCreatedByEdge() {
	m.clearedcreated_by_edge = true
}

// CreatedByEdgeCleared reports if the "created_by_edge" edge to the User entity was cleared.
func (m *CandidateJobMutation) CreatedByEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_edge
}

// CreatedByEdgeID returns the "created_by_edge" edge ID in the mutation.
func (m *CandidateJobMutation) CreatedByEdgeID() (id uuid.UUID, exists bool) {
	if m.created_by_edge != nil {
		return *m.created_by_edge, true
	}
	return
}

// CreatedByEdgeIDs returns the "created_by_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobMutation) CreatedByEdgeIDs() (ids []uuid.UUID) {
	if id := m.created_by_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByEdge resets all changes to the "created_by_edge" edge.
func (m *CandidateJobMutation) ResetCreatedByEdge() {
	m.created_by_edge = nil
	m.clearedcreated_by_edge = false
}

// AddCandidateJobStepIDs adds the "candidate_job_step" edge to the CandidateJobStep entity by ids.
func (m *CandidateJobMutation) AddCandidateJobStepIDs(ids ...uuid.UUID) {
	if m.candidate_job_step == nil {
		m.candidate_job_step = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_step[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobStep clears the "candidate_job_step" edge to the CandidateJobStep entity.
func (m *CandidateJobMutation) ClearCandidateJobStep() {
	m.clearedcandidate_job_step = true
}

// CandidateJobStepCleared reports if the "candidate_job_step" edge to the CandidateJobStep entity was cleared.
func (m *CandidateJobMutation) CandidateJobStepCleared() bool {
	return m.clearedcandidate_job_step
}

// RemoveCandidateJobStepIDs removes the "candidate_job_step" edge to the CandidateJobStep entity by IDs.
func (m *CandidateJobMutation) RemoveCandidateJobStepIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_step == nil {
		m.removedcandidate_job_step = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_step, ids[i])
		m.removedcandidate_job_step[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobStep returns the removed IDs of the "candidate_job_step" edge to the CandidateJobStep entity.
func (m *CandidateJobMutation) RemovedCandidateJobStepIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_step {
		ids = append(ids, id)
	}
	return
}

// CandidateJobStepIDs returns the "candidate_job_step" edge IDs in the mutation.
func (m *CandidateJobMutation) CandidateJobStepIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_step {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobStep resets all changes to the "candidate_job_step" edge.
func (m *CandidateJobMutation) ResetCandidateJobStep() {
	m.candidate_job_step = nil
	m.clearedcandidate_job_step = false
	m.removedcandidate_job_step = nil
}

// Where appends a list predicates to the CandidateJobMutation builder.
func (m *CandidateJobMutation) Where(ps ...predicate.CandidateJob) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateJob).
func (m *CandidateJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateJobMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, candidatejob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidatejob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidatejob.FieldDeletedAt)
	}
	if m.hiring_job_edge != nil {
		fields = append(fields, candidatejob.FieldHiringJobID)
	}
	if m.candidate_edge != nil {
		fields = append(fields, candidatejob.FieldCandidateID)
	}
	if m.created_by_edge != nil {
		fields = append(fields, candidatejob.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, candidatejob.FieldStatus)
	}
	if m.failed_reason != nil {
		fields = append(fields, candidatejob.FieldFailedReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidatejob.FieldCreatedAt:
		return m.CreatedAt()
	case candidatejob.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidatejob.FieldDeletedAt:
		return m.DeletedAt()
	case candidatejob.FieldHiringJobID:
		return m.HiringJobID()
	case candidatejob.FieldCandidateID:
		return m.CandidateID()
	case candidatejob.FieldCreatedBy:
		return m.CreatedBy()
	case candidatejob.FieldStatus:
		return m.Status()
	case candidatejob.FieldFailedReason:
		return m.FailedReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidatejob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidatejob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidatejob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidatejob.FieldHiringJobID:
		return m.OldHiringJobID(ctx)
	case candidatejob.FieldCandidateID:
		return m.OldCandidateID(ctx)
	case candidatejob.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case candidatejob.FieldStatus:
		return m.OldStatus(ctx)
	case candidatejob.FieldFailedReason:
		return m.OldFailedReason(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidatejob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidatejob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidatejob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidatejob.FieldHiringJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiringJobID(v)
		return nil
	case candidatejob.FieldCandidateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateID(v)
		return nil
	case candidatejob.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case candidatejob.FieldStatus:
		v, ok := value.(candidatejob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case candidatejob.FieldFailedReason:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedReason(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidatejob.FieldUpdatedAt) {
		fields = append(fields, candidatejob.FieldUpdatedAt)
	}
	if m.FieldCleared(candidatejob.FieldDeletedAt) {
		fields = append(fields, candidatejob.FieldDeletedAt)
	}
	if m.FieldCleared(candidatejob.FieldHiringJobID) {
		fields = append(fields, candidatejob.FieldHiringJobID)
	}
	if m.FieldCleared(candidatejob.FieldCandidateID) {
		fields = append(fields, candidatejob.FieldCandidateID)
	}
	if m.FieldCleared(candidatejob.FieldCreatedBy) {
		fields = append(fields, candidatejob.FieldCreatedBy)
	}
	if m.FieldCleared(candidatejob.FieldFailedReason) {
		fields = append(fields, candidatejob.FieldFailedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateJobMutation) ClearField(name string) error {
	switch name {
	case candidatejob.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidatejob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidatejob.FieldHiringJobID:
		m.ClearHiringJobID()
		return nil
	case candidatejob.FieldCandidateID:
		m.ClearCandidateID()
		return nil
	case candidatejob.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case candidatejob.FieldFailedReason:
		m.ClearFailedReason()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateJobMutation) ResetField(name string) error {
	switch name {
	case candidatejob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidatejob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidatejob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidatejob.FieldHiringJobID:
		m.ResetHiringJobID()
		return nil
	case candidatejob.FieldCandidateID:
		m.ResetCandidateID()
		return nil
	case candidatejob.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case candidatejob.FieldStatus:
		m.ResetStatus()
		return nil
	case candidatejob.FieldFailedReason:
		m.ResetFailedReason()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.attachment_edges != nil {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.hiring_job_edge != nil {
		edges = append(edges, candidatejob.EdgeHiringJobEdge)
	}
	if m.candidate_job_feedback != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobFeedback)
	}
	if m.candidate_edge != nil {
		edges = append(edges, candidatejob.EdgeCandidateEdge)
	}
	if m.candidate_job_interview != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobInterview)
	}
	if m.created_by_edge != nil {
		edges = append(edges, candidatejob.EdgeCreatedByEdge)
	}
	if m.candidate_job_step != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobStep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeHiringJobEdge:
		if id := m.hiring_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejob.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.candidate_job_feedback))
		for id := range m.candidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateEdge:
		if id := m.candidate_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejob.EdgeCandidateJobInterview:
		ids := make([]ent.Value, 0, len(m.candidate_job_interview))
		for id := range m.candidate_job_interview {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCreatedByEdge:
		if id := m.created_by_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejob.EdgeCandidateJobStep:
		ids := make([]ent.Value, 0, len(m.candidate_job_step))
		for id := range m.candidate_job_step {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedattachment_edges != nil {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.removedcandidate_job_feedback != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobFeedback)
	}
	if m.removedcandidate_job_interview != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobInterview)
	}
	if m.removedcandidate_job_step != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobStep)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_feedback))
		for id := range m.removedcandidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateJobInterview:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_interview))
		for id := range m.removedcandidate_job_interview {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateJobStep:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_step))
		for id := range m.removedcandidate_job_step {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedattachment_edges {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.clearedhiring_job_edge {
		edges = append(edges, candidatejob.EdgeHiringJobEdge)
	}
	if m.clearedcandidate_job_feedback {
		edges = append(edges, candidatejob.EdgeCandidateJobFeedback)
	}
	if m.clearedcandidate_edge {
		edges = append(edges, candidatejob.EdgeCandidateEdge)
	}
	if m.clearedcandidate_job_interview {
		edges = append(edges, candidatejob.EdgeCandidateJobInterview)
	}
	if m.clearedcreated_by_edge {
		edges = append(edges, candidatejob.EdgeCreatedByEdge)
	}
	if m.clearedcandidate_job_step {
		edges = append(edges, candidatejob.EdgeCandidateJobStep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateJobMutation) EdgeCleared(name string) bool {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	case candidatejob.EdgeHiringJobEdge:
		return m.clearedhiring_job_edge
	case candidatejob.EdgeCandidateJobFeedback:
		return m.clearedcandidate_job_feedback
	case candidatejob.EdgeCandidateEdge:
		return m.clearedcandidate_edge
	case candidatejob.EdgeCandidateJobInterview:
		return m.clearedcandidate_job_interview
	case candidatejob.EdgeCreatedByEdge:
		return m.clearedcreated_by_edge
	case candidatejob.EdgeCandidateJobStep:
		return m.clearedcandidate_job_step
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateJobMutation) ClearEdge(name string) error {
	switch name {
	case candidatejob.EdgeHiringJobEdge:
		m.ClearHiringJobEdge()
		return nil
	case candidatejob.EdgeCandidateEdge:
		m.ClearCandidateEdge()
		return nil
	case candidatejob.EdgeCreatedByEdge:
		m.ClearCreatedByEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateJobMutation) ResetEdge(name string) error {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	case candidatejob.EdgeHiringJobEdge:
		m.ResetHiringJobEdge()
		return nil
	case candidatejob.EdgeCandidateJobFeedback:
		m.ResetCandidateJobFeedback()
		return nil
	case candidatejob.EdgeCandidateEdge:
		m.ResetCandidateEdge()
		return nil
	case candidatejob.EdgeCandidateJobInterview:
		m.ResetCandidateJobInterview()
		return nil
	case candidatejob.EdgeCreatedByEdge:
		m.ResetCreatedByEdge()
		return nil
	case candidatejob.EdgeCandidateJobStep:
		m.ResetCandidateJobStep()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob edge %s", name)
}

// CandidateJobFeedbackMutation represents an operation that mutates the CandidateJobFeedback nodes in the graph.
type CandidateJobFeedbackMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	candidate_job_status      *candidatejobfeedback.CandidateJobStatus
	feedback                  *string
	clearedFields             map[string]struct{}
	created_by_edge           *uuid.UUID
	clearedcreated_by_edge    bool
	candidate_job_edge        *uuid.UUID
	clearedcandidate_job_edge bool
	attachment_edges          map[uuid.UUID]struct{}
	removedattachment_edges   map[uuid.UUID]struct{}
	clearedattachment_edges   bool
	done                      bool
	oldValue                  func(context.Context) (*CandidateJobFeedback, error)
	predicates                []predicate.CandidateJobFeedback
}

var _ ent.Mutation = (*CandidateJobFeedbackMutation)(nil)

// candidatejobfeedbackOption allows management of the mutation configuration using functional options.
type candidatejobfeedbackOption func(*CandidateJobFeedbackMutation)

// newCandidateJobFeedbackMutation creates new mutation for the CandidateJobFeedback entity.
func newCandidateJobFeedbackMutation(c config, op Op, opts ...candidatejobfeedbackOption) *CandidateJobFeedbackMutation {
	m := &CandidateJobFeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateJobFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateJobFeedbackID sets the ID field of the mutation.
func withCandidateJobFeedbackID(id uuid.UUID) candidatejobfeedbackOption {
	return func(m *CandidateJobFeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateJobFeedback
		)
		m.oldValue = func(ctx context.Context) (*CandidateJobFeedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateJobFeedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateJobFeedback sets the old CandidateJobFeedback of the mutation.
func withCandidateJobFeedback(node *CandidateJobFeedback) candidatejobfeedbackOption {
	return func(m *CandidateJobFeedbackMutation) {
		m.oldValue = func(context.Context) (*CandidateJobFeedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateJobFeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateJobFeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateJobFeedback entities.
func (m *CandidateJobFeedbackMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateJobFeedbackMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateJobFeedbackMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateJobFeedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateJobFeedbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateJobFeedbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateJobFeedbackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateJobFeedbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateJobFeedbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateJobFeedbackMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidatejobfeedback.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateJobFeedbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidatejobfeedback.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateJobFeedbackMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateJobFeedbackMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateJobFeedbackMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidatejobfeedback.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateJobFeedbackMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidatejobfeedback.FieldDeletedAt)
}

// SetCandidateJobID sets the "candidate_job_id" field.
func (m *CandidateJobFeedbackMutation) SetCandidateJobID(u uuid.UUID) {
	m.candidate_job_edge = &u
}

// CandidateJobID returns the value of the "candidate_job_id" field in the mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobID returns the old "candidate_job_id" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCandidateJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobID: %w", err)
	}
	return oldValue.CandidateJobID, nil
}

// ClearCandidateJobID clears the value of the "candidate_job_id" field.
func (m *CandidateJobFeedbackMutation) ClearCandidateJobID() {
	m.candidate_job_edge = nil
	m.clearedFields[candidatejobfeedback.FieldCandidateJobID] = struct{}{}
}

// CandidateJobIDCleared returns if the "candidate_job_id" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobIDCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldCandidateJobID]
	return ok
}

// ResetCandidateJobID resets all changes to the "candidate_job_id" field.
func (m *CandidateJobFeedbackMutation) ResetCandidateJobID() {
	m.candidate_job_edge = nil
	delete(m.clearedFields, candidatejobfeedback.FieldCandidateJobID)
}

// SetCreatedBy sets the "created_by" field.
func (m *CandidateJobFeedbackMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CandidateJobFeedbackMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CandidateJobFeedbackMutation) ClearCreatedBy() {
	m.created_by_edge = nil
	m.clearedFields[candidatejobfeedback.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CandidateJobFeedbackMutation) ResetCreatedBy() {
	m.created_by_edge = nil
	delete(m.clearedFields, candidatejobfeedback.FieldCreatedBy)
}

// SetCandidateJobStatus sets the "candidate_job_status" field.
func (m *CandidateJobFeedbackMutation) SetCandidateJobStatus(cjs candidatejobfeedback.CandidateJobStatus) {
	m.candidate_job_status = &cjs
}

// CandidateJobStatus returns the value of the "candidate_job_status" field in the mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobStatus() (r candidatejobfeedback.CandidateJobStatus, exists bool) {
	v := m.candidate_job_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobStatus returns the old "candidate_job_status" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCandidateJobStatus(ctx context.Context) (v candidatejobfeedback.CandidateJobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobStatus: %w", err)
	}
	return oldValue.CandidateJobStatus, nil
}

// ResetCandidateJobStatus resets all changes to the "candidate_job_status" field.
func (m *CandidateJobFeedbackMutation) ResetCandidateJobStatus() {
	m.candidate_job_status = nil
}

// SetFeedback sets the "feedback" field.
func (m *CandidateJobFeedbackMutation) SetFeedback(s string) {
	m.feedback = &s
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *CandidateJobFeedbackMutation) Feedback() (r string, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *CandidateJobFeedbackMutation) ResetFeedback() {
	m.feedback = nil
}

// SetCreatedByEdgeID sets the "created_by_edge" edge to the User entity by id.
func (m *CandidateJobFeedbackMutation) SetCreatedByEdgeID(id uuid.UUID) {
	m.created_by_edge = &id
}

// ClearCreatedByEdge clears the "created_by_edge" edge to the User entity.
func (m *CandidateJobFeedbackMutation) ClearCreatedByEdge() {
	m.clearedcreated_by_edge = true
}

// CreatedByEdgeCleared reports if the "created_by_edge" edge to the User entity was cleared.
func (m *CandidateJobFeedbackMutation) CreatedByEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_edge
}

// CreatedByEdgeID returns the "created_by_edge" edge ID in the mutation.
func (m *CandidateJobFeedbackMutation) CreatedByEdgeID() (id uuid.UUID, exists bool) {
	if m.created_by_edge != nil {
		return *m.created_by_edge, true
	}
	return
}

// CreatedByEdgeIDs returns the "created_by_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobFeedbackMutation) CreatedByEdgeIDs() (ids []uuid.UUID) {
	if id := m.created_by_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByEdge resets all changes to the "created_by_edge" edge.
func (m *CandidateJobFeedbackMutation) ResetCreatedByEdge() {
	m.created_by_edge = nil
	m.clearedcreated_by_edge = false
}

// SetCandidateJobEdgeID sets the "candidate_job_edge" edge to the CandidateJob entity by id.
func (m *CandidateJobFeedbackMutation) SetCandidateJobEdgeID(id uuid.UUID) {
	m.candidate_job_edge = &id
}

// ClearCandidateJobEdge clears the "candidate_job_edge" edge to the CandidateJob entity.
func (m *CandidateJobFeedbackMutation) ClearCandidateJobEdge() {
	m.clearedcandidate_job_edge = true
}

// CandidateJobEdgeCleared reports if the "candidate_job_edge" edge to the CandidateJob entity was cleared.
func (m *CandidateJobFeedbackMutation) CandidateJobEdgeCleared() bool {
	return m.CandidateJobIDCleared() || m.clearedcandidate_job_edge
}

// CandidateJobEdgeID returns the "candidate_job_edge" edge ID in the mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_edge != nil {
		return *m.candidate_job_edge, true
	}
	return
}

// CandidateJobEdgeIDs returns the "candidate_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobFeedbackMutation) CandidateJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobEdge resets all changes to the "candidate_job_edge" edge.
func (m *CandidateJobFeedbackMutation) ResetCandidateJobEdge() {
	m.candidate_job_edge = nil
	m.clearedcandidate_job_edge = false
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateJobFeedbackMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobFeedbackMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateJobFeedbackMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateJobFeedbackMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobFeedbackMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateJobFeedbackMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateJobFeedbackMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// Where appends a list predicates to the CandidateJobFeedbackMutation builder.
func (m *CandidateJobFeedbackMutation) Where(ps ...predicate.CandidateJobFeedback) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateJobFeedbackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateJobFeedback).
func (m *CandidateJobFeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateJobFeedbackMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, candidatejobfeedback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidatejobfeedback.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidatejobfeedback.FieldDeletedAt)
	}
	if m.candidate_job_edge != nil {
		fields = append(fields, candidatejobfeedback.FieldCandidateJobID)
	}
	if m.created_by_edge != nil {
		fields = append(fields, candidatejobfeedback.FieldCreatedBy)
	}
	if m.candidate_job_status != nil {
		fields = append(fields, candidatejobfeedback.FieldCandidateJobStatus)
	}
	if m.feedback != nil {
		fields = append(fields, candidatejobfeedback.FieldFeedback)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateJobFeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		return m.CreatedAt()
	case candidatejobfeedback.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidatejobfeedback.FieldDeletedAt:
		return m.DeletedAt()
	case candidatejobfeedback.FieldCandidateJobID:
		return m.CandidateJobID()
	case candidatejobfeedback.FieldCreatedBy:
		return m.CreatedBy()
	case candidatejobfeedback.FieldCandidateJobStatus:
		return m.CandidateJobStatus()
	case candidatejobfeedback.FieldFeedback:
		return m.Feedback()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateJobFeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidatejobfeedback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidatejobfeedback.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidatejobfeedback.FieldCandidateJobID:
		return m.OldCandidateJobID(ctx)
	case candidatejobfeedback.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case candidatejobfeedback.FieldCandidateJobStatus:
		return m.OldCandidateJobStatus(ctx)
	case candidatejobfeedback.FieldFeedback:
		return m.OldFeedback(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateJobFeedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobFeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidatejobfeedback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidatejobfeedback.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidatejobfeedback.FieldCandidateJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobID(v)
		return nil
	case candidatejobfeedback.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case candidatejobfeedback.FieldCandidateJobStatus:
		v, ok := value.(candidatejobfeedback.CandidateJobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobStatus(v)
		return nil
	case candidatejobfeedback.FieldFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateJobFeedbackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateJobFeedbackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobFeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateJobFeedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateJobFeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidatejobfeedback.FieldUpdatedAt) {
		fields = append(fields, candidatejobfeedback.FieldUpdatedAt)
	}
	if m.FieldCleared(candidatejobfeedback.FieldDeletedAt) {
		fields = append(fields, candidatejobfeedback.FieldDeletedAt)
	}
	if m.FieldCleared(candidatejobfeedback.FieldCandidateJobID) {
		fields = append(fields, candidatejobfeedback.FieldCandidateJobID)
	}
	if m.FieldCleared(candidatejobfeedback.FieldCreatedBy) {
		fields = append(fields, candidatejobfeedback.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateJobFeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ClearField(name string) error {
	switch name {
	case candidatejobfeedback.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidatejobfeedback.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidatejobfeedback.FieldCandidateJobID:
		m.ClearCandidateJobID()
		return nil
	case candidatejobfeedback.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ResetField(name string) error {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidatejobfeedback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidatejobfeedback.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidatejobfeedback.FieldCandidateJobID:
		m.ResetCandidateJobID()
		return nil
	case candidatejobfeedback.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case candidatejobfeedback.FieldCandidateJobStatus:
		m.ResetCandidateJobStatus()
		return nil
	case candidatejobfeedback.FieldFeedback:
		m.ResetFeedback()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateJobFeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.created_by_edge != nil {
		edges = append(edges, candidatejobfeedback.EdgeCreatedByEdge)
	}
	if m.candidate_job_edge != nil {
		edges = append(edges, candidatejobfeedback.EdgeCandidateJobEdge)
	}
	if m.attachment_edges != nil {
		edges = append(edges, candidatejobfeedback.EdgeAttachmentEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateJobFeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		if id := m.created_by_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejobfeedback.EdgeCandidateJobEdge:
		if id := m.candidate_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejobfeedback.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateJobFeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedattachment_edges != nil {
		edges = append(edges, candidatejobfeedback.EdgeAttachmentEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateJobFeedbackMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidatejobfeedback.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateJobFeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreated_by_edge {
		edges = append(edges, candidatejobfeedback.EdgeCreatedByEdge)
	}
	if m.clearedcandidate_job_edge {
		edges = append(edges, candidatejobfeedback.EdgeCandidateJobEdge)
	}
	if m.clearedattachment_edges {
		edges = append(edges, candidatejobfeedback.EdgeAttachmentEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		return m.clearedcreated_by_edge
	case candidatejobfeedback.EdgeCandidateJobEdge:
		return m.clearedcandidate_job_edge
	case candidatejobfeedback.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ClearEdge(name string) error {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		m.ClearCreatedByEdge()
		return nil
	case candidatejobfeedback.EdgeCandidateJobEdge:
		m.ClearCandidateJobEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ResetEdge(name string) error {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		m.ResetCreatedByEdge()
		return nil
	case candidatejobfeedback.EdgeCandidateJobEdge:
		m.ResetCandidateJobEdge()
		return nil
	case candidatejobfeedback.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback edge %s", name)
}

// CandidateJobStepMutation represents an operation that mutates the CandidateJobStep nodes in the graph.
type CandidateJobStepMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	candidate_job_status      *candidatejobstep.CandidateJobStatus
	clearedFields             map[string]struct{}
	candidate_job_edge        *uuid.UUID
	clearedcandidate_job_edge bool
	done                      bool
	oldValue                  func(context.Context) (*CandidateJobStep, error)
	predicates                []predicate.CandidateJobStep
}

var _ ent.Mutation = (*CandidateJobStepMutation)(nil)

// candidatejobstepOption allows management of the mutation configuration using functional options.
type candidatejobstepOption func(*CandidateJobStepMutation)

// newCandidateJobStepMutation creates new mutation for the CandidateJobStep entity.
func newCandidateJobStepMutation(c config, op Op, opts ...candidatejobstepOption) *CandidateJobStepMutation {
	m := &CandidateJobStepMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateJobStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateJobStepID sets the ID field of the mutation.
func withCandidateJobStepID(id uuid.UUID) candidatejobstepOption {
	return func(m *CandidateJobStepMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateJobStep
		)
		m.oldValue = func(ctx context.Context) (*CandidateJobStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateJobStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateJobStep sets the old CandidateJobStep of the mutation.
func withCandidateJobStep(node *CandidateJobStep) candidatejobstepOption {
	return func(m *CandidateJobStepMutation) {
		m.oldValue = func(context.Context) (*CandidateJobStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateJobStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateJobStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateJobStep entities.
func (m *CandidateJobStepMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateJobStepMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateJobStepMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateJobStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateJobStepMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateJobStepMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateJobStepMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateJobStepMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateJobStepMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateJobStepMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidatejobstep.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateJobStepMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobstep.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateJobStepMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidatejobstep.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateJobStepMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateJobStepMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateJobStepMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidatejobstep.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateJobStepMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobstep.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateJobStepMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidatejobstep.FieldDeletedAt)
}

// SetCandidateJobStatus sets the "candidate_job_status" field.
func (m *CandidateJobStepMutation) SetCandidateJobStatus(cjs candidatejobstep.CandidateJobStatus) {
	m.candidate_job_status = &cjs
}

// CandidateJobStatus returns the value of the "candidate_job_status" field in the mutation.
func (m *CandidateJobStepMutation) CandidateJobStatus() (r candidatejobstep.CandidateJobStatus, exists bool) {
	v := m.candidate_job_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobStatus returns the old "candidate_job_status" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldCandidateJobStatus(ctx context.Context) (v candidatejobstep.CandidateJobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobStatus: %w", err)
	}
	return oldValue.CandidateJobStatus, nil
}

// ResetCandidateJobStatus resets all changes to the "candidate_job_status" field.
func (m *CandidateJobStepMutation) ResetCandidateJobStatus() {
	m.candidate_job_status = nil
}

// SetCandidateJobID sets the "candidate_job_id" field.
func (m *CandidateJobStepMutation) SetCandidateJobID(u uuid.UUID) {
	m.candidate_job_edge = &u
}

// CandidateJobID returns the value of the "candidate_job_id" field in the mutation.
func (m *CandidateJobStepMutation) CandidateJobID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobID returns the old "candidate_job_id" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldCandidateJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobID: %w", err)
	}
	return oldValue.CandidateJobID, nil
}

// ClearCandidateJobID clears the value of the "candidate_job_id" field.
func (m *CandidateJobStepMutation) ClearCandidateJobID() {
	m.candidate_job_edge = nil
	m.clearedFields[candidatejobstep.FieldCandidateJobID] = struct{}{}
}

// CandidateJobIDCleared returns if the "candidate_job_id" field was cleared in this mutation.
func (m *CandidateJobStepMutation) CandidateJobIDCleared() bool {
	_, ok := m.clearedFields[candidatejobstep.FieldCandidateJobID]
	return ok
}

// ResetCandidateJobID resets all changes to the "candidate_job_id" field.
func (m *CandidateJobStepMutation) ResetCandidateJobID() {
	m.candidate_job_edge = nil
	delete(m.clearedFields, candidatejobstep.FieldCandidateJobID)
}

// SetCandidateJobEdgeID sets the "candidate_job_edge" edge to the CandidateJob entity by id.
func (m *CandidateJobStepMutation) SetCandidateJobEdgeID(id uuid.UUID) {
	m.candidate_job_edge = &id
}

// ClearCandidateJobEdge clears the "candidate_job_edge" edge to the CandidateJob entity.
func (m *CandidateJobStepMutation) ClearCandidateJobEdge() {
	m.clearedcandidate_job_edge = true
}

// CandidateJobEdgeCleared reports if the "candidate_job_edge" edge to the CandidateJob entity was cleared.
func (m *CandidateJobStepMutation) CandidateJobEdgeCleared() bool {
	return m.CandidateJobIDCleared() || m.clearedcandidate_job_edge
}

// CandidateJobEdgeID returns the "candidate_job_edge" edge ID in the mutation.
func (m *CandidateJobStepMutation) CandidateJobEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_edge != nil {
		return *m.candidate_job_edge, true
	}
	return
}

// CandidateJobEdgeIDs returns the "candidate_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobStepMutation) CandidateJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobEdge resets all changes to the "candidate_job_edge" edge.
func (m *CandidateJobStepMutation) ResetCandidateJobEdge() {
	m.candidate_job_edge = nil
	m.clearedcandidate_job_edge = false
}

// Where appends a list predicates to the CandidateJobStepMutation builder.
func (m *CandidateJobStepMutation) Where(ps ...predicate.CandidateJobStep) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateJobStepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateJobStep).
func (m *CandidateJobStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateJobStepMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, candidatejobstep.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidatejobstep.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidatejobstep.FieldDeletedAt)
	}
	if m.candidate_job_status != nil {
		fields = append(fields, candidatejobstep.FieldCandidateJobStatus)
	}
	if m.candidate_job_edge != nil {
		fields = append(fields, candidatejobstep.FieldCandidateJobID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateJobStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		return m.CreatedAt()
	case candidatejobstep.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidatejobstep.FieldDeletedAt:
		return m.DeletedAt()
	case candidatejobstep.FieldCandidateJobStatus:
		return m.CandidateJobStatus()
	case candidatejobstep.FieldCandidateJobID:
		return m.CandidateJobID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateJobStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidatejobstep.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidatejobstep.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidatejobstep.FieldCandidateJobStatus:
		return m.OldCandidateJobStatus(ctx)
	case candidatejobstep.FieldCandidateJobID:
		return m.OldCandidateJobID(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateJobStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidatejobstep.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidatejobstep.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidatejobstep.FieldCandidateJobStatus:
		v, ok := value.(candidatejobstep.CandidateJobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobStatus(v)
		return nil
	case candidatejobstep.FieldCandidateJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobID(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateJobStepMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateJobStepMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateJobStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateJobStepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidatejobstep.FieldUpdatedAt) {
		fields = append(fields, candidatejobstep.FieldUpdatedAt)
	}
	if m.FieldCleared(candidatejobstep.FieldDeletedAt) {
		fields = append(fields, candidatejobstep.FieldDeletedAt)
	}
	if m.FieldCleared(candidatejobstep.FieldCandidateJobID) {
		fields = append(fields, candidatejobstep.FieldCandidateJobID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateJobStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateJobStepMutation) ClearField(name string) error {
	switch name {
	case candidatejobstep.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidatejobstep.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidatejobstep.FieldCandidateJobID:
		m.ClearCandidateJobID()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateJobStepMutation) ResetField(name string) error {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidatejobstep.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidatejobstep.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidatejobstep.FieldCandidateJobStatus:
		m.ResetCandidateJobStatus()
		return nil
	case candidatejobstep.FieldCandidateJobID:
		m.ResetCandidateJobID()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateJobStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.candidate_job_edge != nil {
		edges = append(edges, candidatejobstep.EdgeCandidateJobEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateJobStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		if id := m.candidate_job_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateJobStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateJobStepMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateJobStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcandidate_job_edge {
		edges = append(edges, candidatejobstep.EdgeCandidateJobEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateJobStepMutation) EdgeCleared(name string) bool {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		return m.clearedcandidate_job_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateJobStepMutation) ClearEdge(name string) error {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		m.ClearCandidateJobEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateJobStepMutation) ResetEdge(name string) error {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		m.ResetCandidateJobEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep edge %s", name)
}

// HiringJobMutation represents an operation that mutates the HiringJob nodes in the graph.
type HiringJobMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	slug                       *string
	name                       *string
	description                *string
	amount                     *int
	addamount                  *int
	status                     *hiringjob.Status
	location                   *hiringjob.Location
	salary_type                *hiringjob.SalaryType
	salary_from                *int
	addsalary_from             *int
	salary_to                  *int
	addsalary_to               *int
	currency                   *hiringjob.Currency
	last_apply_date            *time.Time
	priority                   *int
	addpriority                *int
	clearedFields              map[string]struct{}
	owner_edge                 *uuid.UUID
	clearedowner_edge          bool
	team_edge                  *uuid.UUID
	clearedteam_edge           bool
	candidate_job_edges        map[uuid.UUID]struct{}
	removedcandidate_job_edges map[uuid.UUID]struct{}
	clearedcandidate_job_edges bool
	done                       bool
	oldValue                   func(context.Context) (*HiringJob, error)
	predicates                 []predicate.HiringJob
}

var _ ent.Mutation = (*HiringJobMutation)(nil)

// hiringjobOption allows management of the mutation configuration using functional options.
type hiringjobOption func(*HiringJobMutation)

// newHiringJobMutation creates new mutation for the HiringJob entity.
func newHiringJobMutation(c config, op Op, opts ...hiringjobOption) *HiringJobMutation {
	m := &HiringJobMutation{
		config:        c,
		op:            op,
		typ:           TypeHiringJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHiringJobID sets the ID field of the mutation.
func withHiringJobID(id uuid.UUID) hiringjobOption {
	return func(m *HiringJobMutation) {
		var (
			err   error
			once  sync.Once
			value *HiringJob
		)
		m.oldValue = func(ctx context.Context) (*HiringJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HiringJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHiringJob sets the old HiringJob of the mutation.
func withHiringJob(node *HiringJob) hiringjobOption {
	return func(m *HiringJobMutation) {
		m.oldValue = func(context.Context) (*HiringJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HiringJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HiringJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HiringJob entities.
func (m *HiringJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HiringJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HiringJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HiringJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HiringJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HiringJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HiringJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HiringJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HiringJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HiringJobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hiringjob.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HiringJobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HiringJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hiringjob.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HiringJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HiringJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HiringJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hiringjob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HiringJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HiringJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hiringjob.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *HiringJobMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *HiringJobMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *HiringJobMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *HiringJobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HiringJobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HiringJobMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HiringJobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HiringJobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HiringJobMutation) ResetDescription() {
	m.description = nil
}

// SetAmount sets the "amount" field.
func (m *HiringJobMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *HiringJobMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *HiringJobMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *HiringJobMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *HiringJobMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *HiringJobMutation) SetStatus(h hiringjob.Status) {
	m.status = &h
}

// Status returns the value of the "status" field in the mutation.
func (m *HiringJobMutation) Status() (r hiringjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldStatus(ctx context.Context) (v hiringjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HiringJobMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *HiringJobMutation) SetCreatedBy(u uuid.UUID) {
	m.owner_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HiringJobMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.owner_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HiringJobMutation) ClearCreatedBy() {
	m.owner_edge = nil
	m.clearedFields[hiringjob.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HiringJobMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HiringJobMutation) ResetCreatedBy() {
	m.owner_edge = nil
	delete(m.clearedFields, hiringjob.FieldCreatedBy)
}

// SetTeamID sets the "team_id" field.
func (m *HiringJobMutation) SetTeamID(u uuid.UUID) {
	m.team_edge = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HiringJobMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *HiringJobMutation) ClearTeamID() {
	m.team_edge = nil
	m.clearedFields[hiringjob.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *HiringJobMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HiringJobMutation) ResetTeamID() {
	m.team_edge = nil
	delete(m.clearedFields, hiringjob.FieldTeamID)
}

// SetLocation sets the "location" field.
func (m *HiringJobMutation) SetLocation(h hiringjob.Location) {
	m.location = &h
}

// Location returns the value of the "location" field in the mutation.
func (m *HiringJobMutation) Location() (r hiringjob.Location, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldLocation(ctx context.Context) (v hiringjob.Location, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *HiringJobMutation) ResetLocation() {
	m.location = nil
}

// SetSalaryType sets the "salary_type" field.
func (m *HiringJobMutation) SetSalaryType(ht hiringjob.SalaryType) {
	m.salary_type = &ht
}

// SalaryType returns the value of the "salary_type" field in the mutation.
func (m *HiringJobMutation) SalaryType() (r hiringjob.SalaryType, exists bool) {
	v := m.salary_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryType returns the old "salary_type" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryType(ctx context.Context) (v hiringjob.SalaryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryType: %w", err)
	}
	return oldValue.SalaryType, nil
}

// ResetSalaryType resets all changes to the "salary_type" field.
func (m *HiringJobMutation) ResetSalaryType() {
	m.salary_type = nil
}

// SetSalaryFrom sets the "salary_from" field.
func (m *HiringJobMutation) SetSalaryFrom(i int) {
	m.salary_from = &i
	m.addsalary_from = nil
}

// SalaryFrom returns the value of the "salary_from" field in the mutation.
func (m *HiringJobMutation) SalaryFrom() (r int, exists bool) {
	v := m.salary_from
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryFrom returns the old "salary_from" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryFrom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryFrom: %w", err)
	}
	return oldValue.SalaryFrom, nil
}

// AddSalaryFrom adds i to the "salary_from" field.
func (m *HiringJobMutation) AddSalaryFrom(i int) {
	if m.addsalary_from != nil {
		*m.addsalary_from += i
	} else {
		m.addsalary_from = &i
	}
}

// AddedSalaryFrom returns the value that was added to the "salary_from" field in this mutation.
func (m *HiringJobMutation) AddedSalaryFrom() (r int, exists bool) {
	v := m.addsalary_from
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalaryFrom resets all changes to the "salary_from" field.
func (m *HiringJobMutation) ResetSalaryFrom() {
	m.salary_from = nil
	m.addsalary_from = nil
}

// SetSalaryTo sets the "salary_to" field.
func (m *HiringJobMutation) SetSalaryTo(i int) {
	m.salary_to = &i
	m.addsalary_to = nil
}

// SalaryTo returns the value of the "salary_to" field in the mutation.
func (m *HiringJobMutation) SalaryTo() (r int, exists bool) {
	v := m.salary_to
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryTo returns the old "salary_to" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryTo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryTo: %w", err)
	}
	return oldValue.SalaryTo, nil
}

// AddSalaryTo adds i to the "salary_to" field.
func (m *HiringJobMutation) AddSalaryTo(i int) {
	if m.addsalary_to != nil {
		*m.addsalary_to += i
	} else {
		m.addsalary_to = &i
	}
}

// AddedSalaryTo returns the value that was added to the "salary_to" field in this mutation.
func (m *HiringJobMutation) AddedSalaryTo() (r int, exists bool) {
	v := m.addsalary_to
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalaryTo resets all changes to the "salary_to" field.
func (m *HiringJobMutation) ResetSalaryTo() {
	m.salary_to = nil
	m.addsalary_to = nil
}

// SetCurrency sets the "currency" field.
func (m *HiringJobMutation) SetCurrency(h hiringjob.Currency) {
	m.currency = &h
}

// Currency returns the value of the "currency" field in the mutation.
func (m *HiringJobMutation) Currency() (r hiringjob.Currency, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCurrency(ctx context.Context) (v hiringjob.Currency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *HiringJobMutation) ResetCurrency() {
	m.currency = nil
}

// SetLastApplyDate sets the "last_apply_date" field.
func (m *HiringJobMutation) SetLastApplyDate(t time.Time) {
	m.last_apply_date = &t
}

// LastApplyDate returns the value of the "last_apply_date" field in the mutation.
func (m *HiringJobMutation) LastApplyDate() (r time.Time, exists bool) {
	v := m.last_apply_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastApplyDate returns the old "last_apply_date" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldLastApplyDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastApplyDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastApplyDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastApplyDate: %w", err)
	}
	return oldValue.LastApplyDate, nil
}

// ClearLastApplyDate clears the value of the "last_apply_date" field.
func (m *HiringJobMutation) ClearLastApplyDate() {
	m.last_apply_date = nil
	m.clearedFields[hiringjob.FieldLastApplyDate] = struct{}{}
}

// LastApplyDateCleared returns if the "last_apply_date" field was cleared in this mutation.
func (m *HiringJobMutation) LastApplyDateCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldLastApplyDate]
	return ok
}

// ResetLastApplyDate resets all changes to the "last_apply_date" field.
func (m *HiringJobMutation) ResetLastApplyDate() {
	m.last_apply_date = nil
	delete(m.clearedFields, hiringjob.FieldLastApplyDate)
}

// SetPriority sets the "priority" field.
func (m *HiringJobMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *HiringJobMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *HiringJobMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *HiringJobMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *HiringJobMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetOwnerEdgeID sets the "owner_edge" edge to the User entity by id.
func (m *HiringJobMutation) SetOwnerEdgeID(id uuid.UUID) {
	m.owner_edge = &id
}

// ClearOwnerEdge clears the "owner_edge" edge to the User entity.
func (m *HiringJobMutation) ClearOwnerEdge() {
	m.clearedowner_edge = true
}

// OwnerEdgeCleared reports if the "owner_edge" edge to the User entity was cleared.
func (m *HiringJobMutation) OwnerEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedowner_edge
}

// OwnerEdgeID returns the "owner_edge" edge ID in the mutation.
func (m *HiringJobMutation) OwnerEdgeID() (id uuid.UUID, exists bool) {
	if m.owner_edge != nil {
		return *m.owner_edge, true
	}
	return
}

// OwnerEdgeIDs returns the "owner_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringJobMutation) OwnerEdgeIDs() (ids []uuid.UUID) {
	if id := m.owner_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerEdge resets all changes to the "owner_edge" edge.
func (m *HiringJobMutation) ResetOwnerEdge() {
	m.owner_edge = nil
	m.clearedowner_edge = false
}

// SetTeamEdgeID sets the "team_edge" edge to the Team entity by id.
func (m *HiringJobMutation) SetTeamEdgeID(id uuid.UUID) {
	m.team_edge = &id
}

// ClearTeamEdge clears the "team_edge" edge to the Team entity.
func (m *HiringJobMutation) ClearTeamEdge() {
	m.clearedteam_edge = true
}

// TeamEdgeCleared reports if the "team_edge" edge to the Team entity was cleared.
func (m *HiringJobMutation) TeamEdgeCleared() bool {
	return m.TeamIDCleared() || m.clearedteam_edge
}

// TeamEdgeID returns the "team_edge" edge ID in the mutation.
func (m *HiringJobMutation) TeamEdgeID() (id uuid.UUID, exists bool) {
	if m.team_edge != nil {
		return *m.team_edge, true
	}
	return
}

// TeamEdgeIDs returns the "team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringJobMutation) TeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamEdge resets all changes to the "team_edge" edge.
func (m *HiringJobMutation) ResetTeamEdge() {
	m.team_edge = nil
	m.clearedteam_edge = false
}

// AddCandidateJobEdgeIDs adds the "candidate_job_edges" edge to the CandidateJob entity by ids.
func (m *HiringJobMutation) AddCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_job_edges == nil {
		m.candidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobEdges clears the "candidate_job_edges" edge to the CandidateJob entity.
func (m *HiringJobMutation) ClearCandidateJobEdges() {
	m.clearedcandidate_job_edges = true
}

// CandidateJobEdgesCleared reports if the "candidate_job_edges" edge to the CandidateJob entity was cleared.
func (m *HiringJobMutation) CandidateJobEdgesCleared() bool {
	return m.clearedcandidate_job_edges
}

// RemoveCandidateJobEdgeIDs removes the "candidate_job_edges" edge to the CandidateJob entity by IDs.
func (m *HiringJobMutation) RemoveCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_edges == nil {
		m.removedcandidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_edges, ids[i])
		m.removedcandidate_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobEdges returns the removed IDs of the "candidate_job_edges" edge to the CandidateJob entity.
func (m *HiringJobMutation) RemovedCandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateJobEdgesIDs returns the "candidate_job_edges" edge IDs in the mutation.
func (m *HiringJobMutation) CandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobEdges resets all changes to the "candidate_job_edges" edge.
func (m *HiringJobMutation) ResetCandidateJobEdges() {
	m.candidate_job_edges = nil
	m.clearedcandidate_job_edges = false
	m.removedcandidate_job_edges = nil
}

// Where appends a list predicates to the HiringJobMutation builder.
func (m *HiringJobMutation) Where(ps ...predicate.HiringJob) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HiringJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HiringJob).
func (m *HiringJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HiringJobMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, hiringjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hiringjob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hiringjob.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, hiringjob.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, hiringjob.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hiringjob.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, hiringjob.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, hiringjob.FieldStatus)
	}
	if m.owner_edge != nil {
		fields = append(fields, hiringjob.FieldCreatedBy)
	}
	if m.team_edge != nil {
		fields = append(fields, hiringjob.FieldTeamID)
	}
	if m.location != nil {
		fields = append(fields, hiringjob.FieldLocation)
	}
	if m.salary_type != nil {
		fields = append(fields, hiringjob.FieldSalaryType)
	}
	if m.salary_from != nil {
		fields = append(fields, hiringjob.FieldSalaryFrom)
	}
	if m.salary_to != nil {
		fields = append(fields, hiringjob.FieldSalaryTo)
	}
	if m.currency != nil {
		fields = append(fields, hiringjob.FieldCurrency)
	}
	if m.last_apply_date != nil {
		fields = append(fields, hiringjob.FieldLastApplyDate)
	}
	if m.priority != nil {
		fields = append(fields, hiringjob.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HiringJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hiringjob.FieldCreatedAt:
		return m.CreatedAt()
	case hiringjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case hiringjob.FieldDeletedAt:
		return m.DeletedAt()
	case hiringjob.FieldSlug:
		return m.Slug()
	case hiringjob.FieldName:
		return m.Name()
	case hiringjob.FieldDescription:
		return m.Description()
	case hiringjob.FieldAmount:
		return m.Amount()
	case hiringjob.FieldStatus:
		return m.Status()
	case hiringjob.FieldCreatedBy:
		return m.CreatedBy()
	case hiringjob.FieldTeamID:
		return m.TeamID()
	case hiringjob.FieldLocation:
		return m.Location()
	case hiringjob.FieldSalaryType:
		return m.SalaryType()
	case hiringjob.FieldSalaryFrom:
		return m.SalaryFrom()
	case hiringjob.FieldSalaryTo:
		return m.SalaryTo()
	case hiringjob.FieldCurrency:
		return m.Currency()
	case hiringjob.FieldLastApplyDate:
		return m.LastApplyDate()
	case hiringjob.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HiringJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hiringjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hiringjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hiringjob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hiringjob.FieldSlug:
		return m.OldSlug(ctx)
	case hiringjob.FieldName:
		return m.OldName(ctx)
	case hiringjob.FieldDescription:
		return m.OldDescription(ctx)
	case hiringjob.FieldAmount:
		return m.OldAmount(ctx)
	case hiringjob.FieldStatus:
		return m.OldStatus(ctx)
	case hiringjob.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hiringjob.FieldTeamID:
		return m.OldTeamID(ctx)
	case hiringjob.FieldLocation:
		return m.OldLocation(ctx)
	case hiringjob.FieldSalaryType:
		return m.OldSalaryType(ctx)
	case hiringjob.FieldSalaryFrom:
		return m.OldSalaryFrom(ctx)
	case hiringjob.FieldSalaryTo:
		return m.OldSalaryTo(ctx)
	case hiringjob.FieldCurrency:
		return m.OldCurrency(ctx)
	case hiringjob.FieldLastApplyDate:
		return m.OldLastApplyDate(ctx)
	case hiringjob.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown HiringJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hiringjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hiringjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hiringjob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hiringjob.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case hiringjob.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hiringjob.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hiringjob.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case hiringjob.FieldStatus:
		v, ok := value.(hiringjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hiringjob.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hiringjob.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case hiringjob.FieldLocation:
		v, ok := value.(hiringjob.Location)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case hiringjob.FieldSalaryType:
		v, ok := value.(hiringjob.SalaryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryType(v)
		return nil
	case hiringjob.FieldSalaryFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryFrom(v)
		return nil
	case hiringjob.FieldSalaryTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryTo(v)
		return nil
	case hiringjob.FieldCurrency:
		v, ok := value.(hiringjob.Currency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case hiringjob.FieldLastApplyDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastApplyDate(v)
		return nil
	case hiringjob.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown HiringJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HiringJobMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, hiringjob.FieldAmount)
	}
	if m.addsalary_from != nil {
		fields = append(fields, hiringjob.FieldSalaryFrom)
	}
	if m.addsalary_to != nil {
		fields = append(fields, hiringjob.FieldSalaryTo)
	}
	if m.addpriority != nil {
		fields = append(fields, hiringjob.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HiringJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hiringjob.FieldAmount:
		return m.AddedAmount()
	case hiringjob.FieldSalaryFrom:
		return m.AddedSalaryFrom()
	case hiringjob.FieldSalaryTo:
		return m.AddedSalaryTo()
	case hiringjob.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hiringjob.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case hiringjob.FieldSalaryFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryFrom(v)
		return nil
	case hiringjob.FieldSalaryTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryTo(v)
		return nil
	case hiringjob.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown HiringJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HiringJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hiringjob.FieldUpdatedAt) {
		fields = append(fields, hiringjob.FieldUpdatedAt)
	}
	if m.FieldCleared(hiringjob.FieldDeletedAt) {
		fields = append(fields, hiringjob.FieldDeletedAt)
	}
	if m.FieldCleared(hiringjob.FieldCreatedBy) {
		fields = append(fields, hiringjob.FieldCreatedBy)
	}
	if m.FieldCleared(hiringjob.FieldTeamID) {
		fields = append(fields, hiringjob.FieldTeamID)
	}
	if m.FieldCleared(hiringjob.FieldLastApplyDate) {
		fields = append(fields, hiringjob.FieldLastApplyDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HiringJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HiringJobMutation) ClearField(name string) error {
	switch name {
	case hiringjob.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hiringjob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case hiringjob.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case hiringjob.FieldTeamID:
		m.ClearTeamID()
		return nil
	case hiringjob.FieldLastApplyDate:
		m.ClearLastApplyDate()
		return nil
	}
	return fmt.Errorf("unknown HiringJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HiringJobMutation) ResetField(name string) error {
	switch name {
	case hiringjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hiringjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hiringjob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hiringjob.FieldSlug:
		m.ResetSlug()
		return nil
	case hiringjob.FieldName:
		m.ResetName()
		return nil
	case hiringjob.FieldDescription:
		m.ResetDescription()
		return nil
	case hiringjob.FieldAmount:
		m.ResetAmount()
		return nil
	case hiringjob.FieldStatus:
		m.ResetStatus()
		return nil
	case hiringjob.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hiringjob.FieldTeamID:
		m.ResetTeamID()
		return nil
	case hiringjob.FieldLocation:
		m.ResetLocation()
		return nil
	case hiringjob.FieldSalaryType:
		m.ResetSalaryType()
		return nil
	case hiringjob.FieldSalaryFrom:
		m.ResetSalaryFrom()
		return nil
	case hiringjob.FieldSalaryTo:
		m.ResetSalaryTo()
		return nil
	case hiringjob.FieldCurrency:
		m.ResetCurrency()
		return nil
	case hiringjob.FieldLastApplyDate:
		m.ResetLastApplyDate()
		return nil
	case hiringjob.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown HiringJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HiringJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner_edge != nil {
		edges = append(edges, hiringjob.EdgeOwnerEdge)
	}
	if m.team_edge != nil {
		edges = append(edges, hiringjob.EdgeTeamEdge)
	}
	if m.candidate_job_edges != nil {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HiringJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		if id := m.owner_edge; id != nil {
			return []ent.Value{*id}
		}
	case hiringjob.EdgeTeamEdge:
		if id := m.team_edge; id != nil {
			return []ent.Value{*id}
		}
	case hiringjob.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.candidate_job_edges))
		for id := range m.candidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HiringJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcandidate_job_edges != nil {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HiringJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hiringjob.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_edges))
		for id := range m.removedcandidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HiringJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner_edge {
		edges = append(edges, hiringjob.EdgeOwnerEdge)
	}
	if m.clearedteam_edge {
		edges = append(edges, hiringjob.EdgeTeamEdge)
	}
	if m.clearedcandidate_job_edges {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HiringJobMutation) EdgeCleared(name string) bool {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		return m.clearedowner_edge
	case hiringjob.EdgeTeamEdge:
		return m.clearedteam_edge
	case hiringjob.EdgeCandidateJobEdges:
		return m.clearedcandidate_job_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HiringJobMutation) ClearEdge(name string) error {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		m.ClearOwnerEdge()
		return nil
	case hiringjob.EdgeTeamEdge:
		m.ClearTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown HiringJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HiringJobMutation) ResetEdge(name string) error {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		m.ResetOwnerEdge()
		return nil
	case hiringjob.EdgeTeamEdge:
		m.ResetTeamEdge()
		return nil
	case hiringjob.EdgeCandidateJobEdges:
		m.ResetCandidateJobEdges()
		return nil
	}
	return fmt.Errorf("unknown HiringJob edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	slug                  *string
	name                  *string
	clearedFields         map[string]struct{}
	user_edges            map[uuid.UUID]struct{}
	removeduser_edges     map[uuid.UUID]struct{}
	cleareduser_edges     bool
	team_job_edges        map[uuid.UUID]struct{}
	removedteam_job_edges map[uuid.UUID]struct{}
	clearedteam_job_edges bool
	user_teams            map[uuid.UUID]struct{}
	removeduser_teams     map[uuid.UUID]struct{}
	cleareduser_teams     bool
	done                  bool
	oldValue              func(context.Context) (*Team, error)
	predicates            []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[team.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, team.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeamMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeamMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeamMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[team.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeamMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeamMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, team.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *TeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// AddUserEdgeIDs adds the "user_edges" edge to the User entity by ids.
func (m *TeamMutation) AddUserEdgeIDs(ids ...uuid.UUID) {
	if m.user_edges == nil {
		m.user_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_edges[ids[i]] = struct{}{}
	}
}

// ClearUserEdges clears the "user_edges" edge to the User entity.
func (m *TeamMutation) ClearUserEdges() {
	m.cleareduser_edges = true
}

// UserEdgesCleared reports if the "user_edges" edge to the User entity was cleared.
func (m *TeamMutation) UserEdgesCleared() bool {
	return m.cleareduser_edges
}

// RemoveUserEdgeIDs removes the "user_edges" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserEdgeIDs(ids ...uuid.UUID) {
	if m.removeduser_edges == nil {
		m.removeduser_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_edges, ids[i])
		m.removeduser_edges[ids[i]] = struct{}{}
	}
}

// RemovedUserEdges returns the removed IDs of the "user_edges" edge to the User entity.
func (m *TeamMutation) RemovedUserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_edges {
		ids = append(ids, id)
	}
	return
}

// UserEdgesIDs returns the "user_edges" edge IDs in the mutation.
func (m *TeamMutation) UserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.user_edges {
		ids = append(ids, id)
	}
	return
}

// ResetUserEdges resets all changes to the "user_edges" edge.
func (m *TeamMutation) ResetUserEdges() {
	m.user_edges = nil
	m.cleareduser_edges = false
	m.removeduser_edges = nil
}

// AddTeamJobEdgeIDs adds the "team_job_edges" edge to the HiringJob entity by ids.
func (m *TeamMutation) AddTeamJobEdgeIDs(ids ...uuid.UUID) {
	if m.team_job_edges == nil {
		m.team_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_job_edges[ids[i]] = struct{}{}
	}
}

// ClearTeamJobEdges clears the "team_job_edges" edge to the HiringJob entity.
func (m *TeamMutation) ClearTeamJobEdges() {
	m.clearedteam_job_edges = true
}

// TeamJobEdgesCleared reports if the "team_job_edges" edge to the HiringJob entity was cleared.
func (m *TeamMutation) TeamJobEdgesCleared() bool {
	return m.clearedteam_job_edges
}

// RemoveTeamJobEdgeIDs removes the "team_job_edges" edge to the HiringJob entity by IDs.
func (m *TeamMutation) RemoveTeamJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedteam_job_edges == nil {
		m.removedteam_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_job_edges, ids[i])
		m.removedteam_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedTeamJobEdges returns the removed IDs of the "team_job_edges" edge to the HiringJob entity.
func (m *TeamMutation) RemovedTeamJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_job_edges {
		ids = append(ids, id)
	}
	return
}

// TeamJobEdgesIDs returns the "team_job_edges" edge IDs in the mutation.
func (m *TeamMutation) TeamJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.team_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetTeamJobEdges resets all changes to the "team_job_edges" edge.
func (m *TeamMutation) ResetTeamJobEdges() {
	m.team_job_edges = nil
	m.clearedteam_job_edges = false
	m.removedteam_job_edges = nil
}

// AddUserTeamIDs adds the "user_teams" edge to the TeamManager entity by ids.
func (m *TeamMutation) AddUserTeamIDs(ids ...uuid.UUID) {
	if m.user_teams == nil {
		m.user_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_teams[ids[i]] = struct{}{}
	}
}

// ClearUserTeams clears the "user_teams" edge to the TeamManager entity.
func (m *TeamMutation) ClearUserTeams() {
	m.cleareduser_teams = true
}

// UserTeamsCleared reports if the "user_teams" edge to the TeamManager entity was cleared.
func (m *TeamMutation) UserTeamsCleared() bool {
	return m.cleareduser_teams
}

// RemoveUserTeamIDs removes the "user_teams" edge to the TeamManager entity by IDs.
func (m *TeamMutation) RemoveUserTeamIDs(ids ...uuid.UUID) {
	if m.removeduser_teams == nil {
		m.removeduser_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_teams, ids[i])
		m.removeduser_teams[ids[i]] = struct{}{}
	}
}

// RemovedUserTeams returns the removed IDs of the "user_teams" edge to the TeamManager entity.
func (m *TeamMutation) RemovedUserTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_teams {
		ids = append(ids, id)
	}
	return
}

// UserTeamsIDs returns the "user_teams" edge IDs in the mutation.
func (m *TeamMutation) UserTeamsIDs() (ids []uuid.UUID) {
	for id := range m.user_teams {
		ids = append(ids, id)
	}
	return
}

// ResetUserTeams resets all changes to the "user_teams" edge.
func (m *TeamMutation) ResetUserTeams() {
	m.user_teams = nil
	m.cleareduser_teams = false
	m.removeduser_teams = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, team.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, team.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	case team.FieldDeletedAt:
		return m.DeletedAt()
	case team.FieldSlug:
		return m.Slug()
	case team.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case team.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case team.FieldSlug:
		return m.OldSlug(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case team.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case team.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldUpdatedAt) {
		fields = append(fields, team.FieldUpdatedAt)
	}
	if m.FieldCleared(team.FieldDeletedAt) {
		fields = append(fields, team.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case team.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case team.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case team.FieldSlug:
		m.ResetSlug()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user_edges != nil {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.team_job_edges != nil {
		edges = append(edges, team.EdgeTeamJobEdges)
	}
	if m.user_teams != nil {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.user_edges))
		for id := range m.user_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamJobEdges:
		ids := make([]ent.Value, 0, len(m.team_job_edges))
		for id := range m.team_job_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUserTeams:
		ids := make([]ent.Value, 0, len(m.user_teams))
		for id := range m.user_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_edges != nil {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.removedteam_job_edges != nil {
		edges = append(edges, team.EdgeTeamJobEdges)
	}
	if m.removeduser_teams != nil {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.removeduser_edges))
		for id := range m.removeduser_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamJobEdges:
		ids := make([]ent.Value, 0, len(m.removedteam_job_edges))
		for id := range m.removedteam_job_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUserTeams:
		ids := make([]ent.Value, 0, len(m.removeduser_teams))
		for id := range m.removeduser_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser_edges {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.clearedteam_job_edges {
		edges = append(edges, team.EdgeTeamJobEdges)
	}
	if m.cleareduser_teams {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeUserEdges:
		return m.cleareduser_edges
	case team.EdgeTeamJobEdges:
		return m.clearedteam_job_edges
	case team.EdgeUserTeams:
		return m.cleareduser_teams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeUserEdges:
		m.ResetUserEdges()
		return nil
	case team.EdgeTeamJobEdges:
		m.ResetTeamJobEdges()
		return nil
	case team.EdgeUserTeams:
		m.ResetUserTeams()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamManagerMutation represents an operation that mutates the TeamManager nodes in the graph.
type TeamManagerMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	user_edge        *uuid.UUID
	cleareduser_edge bool
	team_edge        *uuid.UUID
	clearedteam_edge bool
	done             bool
	oldValue         func(context.Context) (*TeamManager, error)
	predicates       []predicate.TeamManager
}

var _ ent.Mutation = (*TeamManagerMutation)(nil)

// teammanagerOption allows management of the mutation configuration using functional options.
type teammanagerOption func(*TeamManagerMutation)

// newTeamManagerMutation creates new mutation for the TeamManager entity.
func newTeamManagerMutation(c config, op Op, opts ...teammanagerOption) *TeamManagerMutation {
	m := &TeamManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamManagerID sets the ID field of the mutation.
func withTeamManagerID(id uuid.UUID) teammanagerOption {
	return func(m *TeamManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamManager
		)
		m.oldValue = func(ctx context.Context) (*TeamManager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamManager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamManager sets the old TeamManager of the mutation.
func withTeamManager(node *TeamManager) teammanagerOption {
	return func(m *TeamManagerMutation) {
		m.oldValue = func(context.Context) (*TeamManager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamManager entities.
func (m *TeamManagerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamManagerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamManagerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamManager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamManagerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamManagerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[teammanager.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamManagerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[teammanager.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, teammanager.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeamManagerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeamManagerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeamManagerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[teammanager.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeamManagerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[teammanager.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeamManagerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, teammanager.FieldDeletedAt)
}

// SetTeamID sets the "team_id" field.
func (m *TeamManagerMutation) SetTeamID(u uuid.UUID) {
	m.team_edge = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TeamManagerMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TeamManagerMutation) ResetTeamID() {
	m.team_edge = nil
}

// SetUserID sets the "user_id" field.
func (m *TeamManagerMutation) SetUserID(u uuid.UUID) {
	m.user_edge = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TeamManagerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TeamManagerMutation) ResetUserID() {
	m.user_edge = nil
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *TeamManagerMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *TeamManagerMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *TeamManagerMutation) UserEdgeCleared() bool {
	return m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *TeamManagerMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *TeamManagerMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *TeamManagerMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetTeamEdgeID sets the "team_edge" edge to the Team entity by id.
func (m *TeamManagerMutation) SetTeamEdgeID(id uuid.UUID) {
	m.team_edge = &id
}

// ClearTeamEdge clears the "team_edge" edge to the Team entity.
func (m *TeamManagerMutation) ClearTeamEdge() {
	m.clearedteam_edge = true
}

// TeamEdgeCleared reports if the "team_edge" edge to the Team entity was cleared.
func (m *TeamManagerMutation) TeamEdgeCleared() bool {
	return m.clearedteam_edge
}

// TeamEdgeID returns the "team_edge" edge ID in the mutation.
func (m *TeamManagerMutation) TeamEdgeID() (id uuid.UUID, exists bool) {
	if m.team_edge != nil {
		return *m.team_edge, true
	}
	return
}

// TeamEdgeIDs returns the "team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamEdgeID instead. It exists only for internal usage by the builders.
func (m *TeamManagerMutation) TeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamEdge resets all changes to the "team_edge" edge.
func (m *TeamManagerMutation) ResetTeamEdge() {
	m.team_edge = nil
	m.clearedteam_edge = false
}

// Where appends a list predicates to the TeamManagerMutation builder.
func (m *TeamManagerMutation) Where(ps ...predicate.TeamManager) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamManagerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeamManager).
func (m *TeamManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamManagerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, teammanager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammanager.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, teammanager.FieldDeletedAt)
	}
	if m.team_edge != nil {
		fields = append(fields, teammanager.FieldTeamID)
	}
	if m.user_edge != nil {
		fields = append(fields, teammanager.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammanager.FieldCreatedAt:
		return m.CreatedAt()
	case teammanager.FieldUpdatedAt:
		return m.UpdatedAt()
	case teammanager.FieldDeletedAt:
		return m.DeletedAt()
	case teammanager.FieldTeamID:
		return m.TeamID()
	case teammanager.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammanager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammanager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teammanager.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case teammanager.FieldTeamID:
		return m.OldTeamID(ctx)
	case teammanager.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown TeamManager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammanager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammanager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teammanager.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case teammanager.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case teammanager.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown TeamManager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamManagerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamManagerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamManager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teammanager.FieldUpdatedAt) {
		fields = append(fields, teammanager.FieldUpdatedAt)
	}
	if m.FieldCleared(teammanager.FieldDeletedAt) {
		fields = append(fields, teammanager.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamManagerMutation) ClearField(name string) error {
	switch name {
	case teammanager.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case teammanager.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamManager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamManagerMutation) ResetField(name string) error {
	switch name {
	case teammanager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammanager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teammanager.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case teammanager.FieldTeamID:
		m.ResetTeamID()
		return nil
	case teammanager.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown TeamManager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_edge != nil {
		edges = append(edges, teammanager.EdgeUserEdge)
	}
	if m.team_edge != nil {
		edges = append(edges, teammanager.EdgeTeamEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamManagerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammanager.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case teammanager.EdgeTeamEdge:
		if id := m.team_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_edge {
		edges = append(edges, teammanager.EdgeUserEdge)
	}
	if m.clearedteam_edge {
		edges = append(edges, teammanager.EdgeTeamEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamManagerMutation) EdgeCleared(name string) bool {
	switch name {
	case teammanager.EdgeUserEdge:
		return m.cleareduser_edge
	case teammanager.EdgeTeamEdge:
		return m.clearedteam_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamManagerMutation) ClearEdge(name string) error {
	switch name {
	case teammanager.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case teammanager.EdgeTeamEdge:
		m.ClearTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown TeamManager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamManagerMutation) ResetEdge(name string) error {
	switch name {
	case teammanager.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case teammanager.EdgeTeamEdge:
		m.ResetTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown TeamManager edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	name                             *string
	work_email                       *string
	status                           *user.Status
	oid                              *string
	clearedFields                    map[string]struct{}
	audit_edge                       map[uuid.UUID]struct{}
	removedaudit_edge                map[uuid.UUID]struct{}
	clearedaudit_edge                bool
	hiring_owner                     map[uuid.UUID]struct{}
	removedhiring_owner              map[uuid.UUID]struct{}
	clearedhiring_owner              bool
	team_edges                       map[uuid.UUID]struct{}
	removedteam_edges                map[uuid.UUID]struct{}
	clearedteam_edges                bool
	candidate_job_feedback           map[uuid.UUID]struct{}
	removedcandidate_job_feedback    map[uuid.UUID]struct{}
	clearedcandidate_job_feedback    bool
	interview_edges                  map[uuid.UUID]struct{}
	removedinterview_edges           map[uuid.UUID]struct{}
	clearedinterview_edges           bool
	candidate_job_edges              map[uuid.UUID]struct{}
	removedcandidate_job_edges       map[uuid.UUID]struct{}
	clearedcandidate_job_edges       bool
	candidate_interview_edges        map[uuid.UUID]struct{}
	removedcandidate_interview_edges map[uuid.UUID]struct{}
	clearedcandidate_interview_edges bool
	team_users                       map[uuid.UUID]struct{}
	removedteam_users                map[uuid.UUID]struct{}
	clearedteam_users                bool
	interview_users                  map[uuid.UUID]struct{}
	removedinterview_users           map[uuid.UUID]struct{}
	clearedinterview_users           bool
	done                             bool
	oldValue                         func(context.Context) (*User, error)
	predicates                       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetWorkEmail sets the "work_email" field.
func (m *UserMutation) SetWorkEmail(s string) {
	m.work_email = &s
}

// WorkEmail returns the value of the "work_email" field in the mutation.
func (m *UserMutation) WorkEmail() (r string, exists bool) {
	v := m.work_email
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEmail returns the old "work_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWorkEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEmail: %w", err)
	}
	return oldValue.WorkEmail, nil
}

// ResetWorkEmail resets all changes to the "work_email" field.
func (m *UserMutation) ResetWorkEmail() {
	m.work_email = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetOid sets the "oid" field.
func (m *UserMutation) SetOid(s string) {
	m.oid = &s
}

// Oid returns the value of the "oid" field in the mutation.
func (m *UserMutation) Oid() (r string, exists bool) {
	v := m.oid
	if v == nil {
		return
	}
	return *v, true
}

// OldOid returns the old "oid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOid: %w", err)
	}
	return oldValue.Oid, nil
}

// ResetOid resets all changes to the "oid" field.
func (m *UserMutation) ResetOid() {
	m.oid = nil
}

// AddAuditEdgeIDs adds the "audit_edge" edge to the AuditTrail entity by ids.
func (m *UserMutation) AddAuditEdgeIDs(ids ...uuid.UUID) {
	if m.audit_edge == nil {
		m.audit_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.audit_edge[ids[i]] = struct{}{}
	}
}

// ClearAuditEdge clears the "audit_edge" edge to the AuditTrail entity.
func (m *UserMutation) ClearAuditEdge() {
	m.clearedaudit_edge = true
}

// AuditEdgeCleared reports if the "audit_edge" edge to the AuditTrail entity was cleared.
func (m *UserMutation) AuditEdgeCleared() bool {
	return m.clearedaudit_edge
}

// RemoveAuditEdgeIDs removes the "audit_edge" edge to the AuditTrail entity by IDs.
func (m *UserMutation) RemoveAuditEdgeIDs(ids ...uuid.UUID) {
	if m.removedaudit_edge == nil {
		m.removedaudit_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.audit_edge, ids[i])
		m.removedaudit_edge[ids[i]] = struct{}{}
	}
}

// RemovedAuditEdge returns the removed IDs of the "audit_edge" edge to the AuditTrail entity.
func (m *UserMutation) RemovedAuditEdgeIDs() (ids []uuid.UUID) {
	for id := range m.removedaudit_edge {
		ids = append(ids, id)
	}
	return
}

// AuditEdgeIDs returns the "audit_edge" edge IDs in the mutation.
func (m *UserMutation) AuditEdgeIDs() (ids []uuid.UUID) {
	for id := range m.audit_edge {
		ids = append(ids, id)
	}
	return
}

// ResetAuditEdge resets all changes to the "audit_edge" edge.
func (m *UserMutation) ResetAuditEdge() {
	m.audit_edge = nil
	m.clearedaudit_edge = false
	m.removedaudit_edge = nil
}

// AddHiringOwnerIDs adds the "hiring_owner" edge to the HiringJob entity by ids.
func (m *UserMutation) AddHiringOwnerIDs(ids ...uuid.UUID) {
	if m.hiring_owner == nil {
		m.hiring_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_owner[ids[i]] = struct{}{}
	}
}

// ClearHiringOwner clears the "hiring_owner" edge to the HiringJob entity.
func (m *UserMutation) ClearHiringOwner() {
	m.clearedhiring_owner = true
}

// HiringOwnerCleared reports if the "hiring_owner" edge to the HiringJob entity was cleared.
func (m *UserMutation) HiringOwnerCleared() bool {
	return m.clearedhiring_owner
}

// RemoveHiringOwnerIDs removes the "hiring_owner" edge to the HiringJob entity by IDs.
func (m *UserMutation) RemoveHiringOwnerIDs(ids ...uuid.UUID) {
	if m.removedhiring_owner == nil {
		m.removedhiring_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_owner, ids[i])
		m.removedhiring_owner[ids[i]] = struct{}{}
	}
}

// RemovedHiringOwner returns the removed IDs of the "hiring_owner" edge to the HiringJob entity.
func (m *UserMutation) RemovedHiringOwnerIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_owner {
		ids = append(ids, id)
	}
	return
}

// HiringOwnerIDs returns the "hiring_owner" edge IDs in the mutation.
func (m *UserMutation) HiringOwnerIDs() (ids []uuid.UUID) {
	for id := range m.hiring_owner {
		ids = append(ids, id)
	}
	return
}

// ResetHiringOwner resets all changes to the "hiring_owner" edge.
func (m *UserMutation) ResetHiringOwner() {
	m.hiring_owner = nil
	m.clearedhiring_owner = false
	m.removedhiring_owner = nil
}

// AddTeamEdgeIDs adds the "team_edges" edge to the Team entity by ids.
func (m *UserMutation) AddTeamEdgeIDs(ids ...uuid.UUID) {
	if m.team_edges == nil {
		m.team_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_edges[ids[i]] = struct{}{}
	}
}

// ClearTeamEdges clears the "team_edges" edge to the Team entity.
func (m *UserMutation) ClearTeamEdges() {
	m.clearedteam_edges = true
}

// TeamEdgesCleared reports if the "team_edges" edge to the Team entity was cleared.
func (m *UserMutation) TeamEdgesCleared() bool {
	return m.clearedteam_edges
}

// RemoveTeamEdgeIDs removes the "team_edges" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamEdgeIDs(ids ...uuid.UUID) {
	if m.removedteam_edges == nil {
		m.removedteam_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_edges, ids[i])
		m.removedteam_edges[ids[i]] = struct{}{}
	}
}

// RemovedTeamEdges returns the removed IDs of the "team_edges" edge to the Team entity.
func (m *UserMutation) RemovedTeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_edges {
		ids = append(ids, id)
	}
	return
}

// TeamEdgesIDs returns the "team_edges" edge IDs in the mutation.
func (m *UserMutation) TeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.team_edges {
		ids = append(ids, id)
	}
	return
}

// ResetTeamEdges resets all changes to the "team_edges" edge.
func (m *UserMutation) ResetTeamEdges() {
	m.team_edges = nil
	m.clearedteam_edges = false
	m.removedteam_edges = nil
}

// AddCandidateJobFeedbackIDs adds the "candidate_job_feedback" edge to the CandidateJobFeedback entity by ids.
func (m *UserMutation) AddCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.candidate_job_feedback == nil {
		m.candidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_feedback[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobFeedback clears the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *UserMutation) ClearCandidateJobFeedback() {
	m.clearedcandidate_job_feedback = true
}

// CandidateJobFeedbackCleared reports if the "candidate_job_feedback" edge to the CandidateJobFeedback entity was cleared.
func (m *UserMutation) CandidateJobFeedbackCleared() bool {
	return m.clearedcandidate_job_feedback
}

// RemoveCandidateJobFeedbackIDs removes the "candidate_job_feedback" edge to the CandidateJobFeedback entity by IDs.
func (m *UserMutation) RemoveCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_feedback == nil {
		m.removedcandidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_feedback, ids[i])
		m.removedcandidate_job_feedback[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobFeedback returns the removed IDs of the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *UserMutation) RemovedCandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// CandidateJobFeedbackIDs returns the "candidate_job_feedback" edge IDs in the mutation.
func (m *UserMutation) CandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobFeedback resets all changes to the "candidate_job_feedback" edge.
func (m *UserMutation) ResetCandidateJobFeedback() {
	m.candidate_job_feedback = nil
	m.clearedcandidate_job_feedback = false
	m.removedcandidate_job_feedback = nil
}

// AddInterviewEdgeIDs adds the "interview_edges" edge to the CandidateInterview entity by ids.
func (m *UserMutation) AddInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.interview_edges == nil {
		m.interview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interview_edges[ids[i]] = struct{}{}
	}
}

// ClearInterviewEdges clears the "interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) ClearInterviewEdges() {
	m.clearedinterview_edges = true
}

// InterviewEdgesCleared reports if the "interview_edges" edge to the CandidateInterview entity was cleared.
func (m *UserMutation) InterviewEdgesCleared() bool {
	return m.clearedinterview_edges
}

// RemoveInterviewEdgeIDs removes the "interview_edges" edge to the CandidateInterview entity by IDs.
func (m *UserMutation) RemoveInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.removedinterview_edges == nil {
		m.removedinterview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interview_edges, ids[i])
		m.removedinterview_edges[ids[i]] = struct{}{}
	}
}

// RemovedInterviewEdges returns the removed IDs of the "interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) RemovedInterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedinterview_edges {
		ids = append(ids, id)
	}
	return
}

// InterviewEdgesIDs returns the "interview_edges" edge IDs in the mutation.
func (m *UserMutation) InterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.interview_edges {
		ids = append(ids, id)
	}
	return
}

// ResetInterviewEdges resets all changes to the "interview_edges" edge.
func (m *UserMutation) ResetInterviewEdges() {
	m.interview_edges = nil
	m.clearedinterview_edges = false
	m.removedinterview_edges = nil
}

// AddCandidateJobEdgeIDs adds the "candidate_job_edges" edge to the CandidateJob entity by ids.
func (m *UserMutation) AddCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_job_edges == nil {
		m.candidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobEdges clears the "candidate_job_edges" edge to the CandidateJob entity.
func (m *UserMutation) ClearCandidateJobEdges() {
	m.clearedcandidate_job_edges = true
}

// CandidateJobEdgesCleared reports if the "candidate_job_edges" edge to the CandidateJob entity was cleared.
func (m *UserMutation) CandidateJobEdgesCleared() bool {
	return m.clearedcandidate_job_edges
}

// RemoveCandidateJobEdgeIDs removes the "candidate_job_edges" edge to the CandidateJob entity by IDs.
func (m *UserMutation) RemoveCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_edges == nil {
		m.removedcandidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_edges, ids[i])
		m.removedcandidate_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobEdges returns the removed IDs of the "candidate_job_edges" edge to the CandidateJob entity.
func (m *UserMutation) RemovedCandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateJobEdgesIDs returns the "candidate_job_edges" edge IDs in the mutation.
func (m *UserMutation) CandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobEdges resets all changes to the "candidate_job_edges" edge.
func (m *UserMutation) ResetCandidateJobEdges() {
	m.candidate_job_edges = nil
	m.clearedcandidate_job_edges = false
	m.removedcandidate_job_edges = nil
}

// AddCandidateInterviewEdgeIDs adds the "candidate_interview_edges" edge to the CandidateInterview entity by ids.
func (m *UserMutation) AddCandidateInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_interview_edges == nil {
		m.candidate_interview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_interview_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateInterviewEdges clears the "candidate_interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) ClearCandidateInterviewEdges() {
	m.clearedcandidate_interview_edges = true
}

// CandidateInterviewEdgesCleared reports if the "candidate_interview_edges" edge to the CandidateInterview entity was cleared.
func (m *UserMutation) CandidateInterviewEdgesCleared() bool {
	return m.clearedcandidate_interview_edges
}

// RemoveCandidateInterviewEdgeIDs removes the "candidate_interview_edges" edge to the CandidateInterview entity by IDs.
func (m *UserMutation) RemoveCandidateInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_interview_edges == nil {
		m.removedcandidate_interview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_interview_edges, ids[i])
		m.removedcandidate_interview_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateInterviewEdges returns the removed IDs of the "candidate_interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) RemovedCandidateInterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_interview_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateInterviewEdgesIDs returns the "candidate_interview_edges" edge IDs in the mutation.
func (m *UserMutation) CandidateInterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_interview_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateInterviewEdges resets all changes to the "candidate_interview_edges" edge.
func (m *UserMutation) ResetCandidateInterviewEdges() {
	m.candidate_interview_edges = nil
	m.clearedcandidate_interview_edges = false
	m.removedcandidate_interview_edges = nil
}

// AddTeamUserIDs adds the "team_users" edge to the TeamManager entity by ids.
func (m *UserMutation) AddTeamUserIDs(ids ...uuid.UUID) {
	if m.team_users == nil {
		m.team_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_users[ids[i]] = struct{}{}
	}
}

// ClearTeamUsers clears the "team_users" edge to the TeamManager entity.
func (m *UserMutation) ClearTeamUsers() {
	m.clearedteam_users = true
}

// TeamUsersCleared reports if the "team_users" edge to the TeamManager entity was cleared.
func (m *UserMutation) TeamUsersCleared() bool {
	return m.clearedteam_users
}

// RemoveTeamUserIDs removes the "team_users" edge to the TeamManager entity by IDs.
func (m *UserMutation) RemoveTeamUserIDs(ids ...uuid.UUID) {
	if m.removedteam_users == nil {
		m.removedteam_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_users, ids[i])
		m.removedteam_users[ids[i]] = struct{}{}
	}
}

// RemovedTeamUsers returns the removed IDs of the "team_users" edge to the TeamManager entity.
func (m *UserMutation) RemovedTeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_users {
		ids = append(ids, id)
	}
	return
}

// TeamUsersIDs returns the "team_users" edge IDs in the mutation.
func (m *UserMutation) TeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.team_users {
		ids = append(ids, id)
	}
	return
}

// ResetTeamUsers resets all changes to the "team_users" edge.
func (m *UserMutation) ResetTeamUsers() {
	m.team_users = nil
	m.clearedteam_users = false
	m.removedteam_users = nil
}

// AddInterviewUserIDs adds the "interview_users" edge to the CandidateInterviewer entity by ids.
func (m *UserMutation) AddInterviewUserIDs(ids ...uuid.UUID) {
	if m.interview_users == nil {
		m.interview_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interview_users[ids[i]] = struct{}{}
	}
}

// ClearInterviewUsers clears the "interview_users" edge to the CandidateInterviewer entity.
func (m *UserMutation) ClearInterviewUsers() {
	m.clearedinterview_users = true
}

// InterviewUsersCleared reports if the "interview_users" edge to the CandidateInterviewer entity was cleared.
func (m *UserMutation) InterviewUsersCleared() bool {
	return m.clearedinterview_users
}

// RemoveInterviewUserIDs removes the "interview_users" edge to the CandidateInterviewer entity by IDs.
func (m *UserMutation) RemoveInterviewUserIDs(ids ...uuid.UUID) {
	if m.removedinterview_users == nil {
		m.removedinterview_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interview_users, ids[i])
		m.removedinterview_users[ids[i]] = struct{}{}
	}
}

// RemovedInterviewUsers returns the removed IDs of the "interview_users" edge to the CandidateInterviewer entity.
func (m *UserMutation) RemovedInterviewUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedinterview_users {
		ids = append(ids, id)
	}
	return
}

// InterviewUsersIDs returns the "interview_users" edge IDs in the mutation.
func (m *UserMutation) InterviewUsersIDs() (ids []uuid.UUID) {
	for id := range m.interview_users {
		ids = append(ids, id)
	}
	return
}

// ResetInterviewUsers resets all changes to the "interview_users" edge.
func (m *UserMutation) ResetInterviewUsers() {
	m.interview_users = nil
	m.clearedinterview_users = false
	m.removedinterview_users = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.work_email != nil {
		fields = append(fields, user.FieldWorkEmail)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.oid != nil {
		fields = append(fields, user.FieldOid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldWorkEmail:
		return m.WorkEmail()
	case user.FieldStatus:
		return m.Status()
	case user.FieldOid:
		return m.Oid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldWorkEmail:
		return m.OldWorkEmail(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldOid:
		return m.OldOid(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldWorkEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEmail(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldOid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOid(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldWorkEmail:
		m.ResetWorkEmail()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldOid:
		m.ResetOid()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.audit_edge != nil {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.hiring_owner != nil {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.team_edges != nil {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.candidate_job_feedback != nil {
		edges = append(edges, user.EdgeCandidateJobFeedback)
	}
	if m.interview_edges != nil {
		edges = append(edges, user.EdgeInterviewEdges)
	}
	if m.candidate_job_edges != nil {
		edges = append(edges, user.EdgeCandidateJobEdges)
	}
	if m.candidate_interview_edges != nil {
		edges = append(edges, user.EdgeCandidateInterviewEdges)
	}
	if m.team_users != nil {
		edges = append(edges, user.EdgeTeamUsers)
	}
	if m.interview_users != nil {
		edges = append(edges, user.EdgeInterviewUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuditEdge:
		ids := make([]ent.Value, 0, len(m.audit_edge))
		for id := range m.audit_edge {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringOwner:
		ids := make([]ent.Value, 0, len(m.hiring_owner))
		for id := range m.hiring_owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamEdges:
		ids := make([]ent.Value, 0, len(m.team_edges))
		for id := range m.team_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.candidate_job_feedback))
		for id := range m.candidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewEdges:
		ids := make([]ent.Value, 0, len(m.interview_edges))
		for id := range m.interview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.candidate_job_edges))
		for id := range m.candidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateInterviewEdges:
		ids := make([]ent.Value, 0, len(m.candidate_interview_edges))
		for id := range m.candidate_interview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamUsers:
		ids := make([]ent.Value, 0, len(m.team_users))
		for id := range m.team_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewUsers:
		ids := make([]ent.Value, 0, len(m.interview_users))
		for id := range m.interview_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedaudit_edge != nil {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.removedhiring_owner != nil {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.removedteam_edges != nil {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.removedcandidate_job_feedback != nil {
		edges = append(edges, user.EdgeCandidateJobFeedback)
	}
	if m.removedinterview_edges != nil {
		edges = append(edges, user.EdgeInterviewEdges)
	}
	if m.removedcandidate_job_edges != nil {
		edges = append(edges, user.EdgeCandidateJobEdges)
	}
	if m.removedcandidate_interview_edges != nil {
		edges = append(edges, user.EdgeCandidateInterviewEdges)
	}
	if m.removedteam_users != nil {
		edges = append(edges, user.EdgeTeamUsers)
	}
	if m.removedinterview_users != nil {
		edges = append(edges, user.EdgeInterviewUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuditEdge:
		ids := make([]ent.Value, 0, len(m.removedaudit_edge))
		for id := range m.removedaudit_edge {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringOwner:
		ids := make([]ent.Value, 0, len(m.removedhiring_owner))
		for id := range m.removedhiring_owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamEdges:
		ids := make([]ent.Value, 0, len(m.removedteam_edges))
		for id := range m.removedteam_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_feedback))
		for id := range m.removedcandidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewEdges:
		ids := make([]ent.Value, 0, len(m.removedinterview_edges))
		for id := range m.removedinterview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_edges))
		for id := range m.removedcandidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateInterviewEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_interview_edges))
		for id := range m.removedcandidate_interview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamUsers:
		ids := make([]ent.Value, 0, len(m.removedteam_users))
		for id := range m.removedteam_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewUsers:
		ids := make([]ent.Value, 0, len(m.removedinterview_users))
		for id := range m.removedinterview_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedaudit_edge {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.clearedhiring_owner {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.clearedteam_edges {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.clearedcandidate_job_feedback {
		edges = append(edges, user.EdgeCandidateJobFeedback)
	}
	if m.clearedinterview_edges {
		edges = append(edges, user.EdgeInterviewEdges)
	}
	if m.clearedcandidate_job_edges {
		edges = append(edges, user.EdgeCandidateJobEdges)
	}
	if m.clearedcandidate_interview_edges {
		edges = append(edges, user.EdgeCandidateInterviewEdges)
	}
	if m.clearedteam_users {
		edges = append(edges, user.EdgeTeamUsers)
	}
	if m.clearedinterview_users {
		edges = append(edges, user.EdgeInterviewUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAuditEdge:
		return m.clearedaudit_edge
	case user.EdgeHiringOwner:
		return m.clearedhiring_owner
	case user.EdgeTeamEdges:
		return m.clearedteam_edges
	case user.EdgeCandidateJobFeedback:
		return m.clearedcandidate_job_feedback
	case user.EdgeInterviewEdges:
		return m.clearedinterview_edges
	case user.EdgeCandidateJobEdges:
		return m.clearedcandidate_job_edges
	case user.EdgeCandidateInterviewEdges:
		return m.clearedcandidate_interview_edges
	case user.EdgeTeamUsers:
		return m.clearedteam_users
	case user.EdgeInterviewUsers:
		return m.clearedinterview_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAuditEdge:
		m.ResetAuditEdge()
		return nil
	case user.EdgeHiringOwner:
		m.ResetHiringOwner()
		return nil
	case user.EdgeTeamEdges:
		m.ResetTeamEdges()
		return nil
	case user.EdgeCandidateJobFeedback:
		m.ResetCandidateJobFeedback()
		return nil
	case user.EdgeInterviewEdges:
		m.ResetInterviewEdges()
		return nil
	case user.EdgeCandidateJobEdges:
		m.ResetCandidateJobEdges()
		return nil
	case user.EdgeCandidateInterviewEdges:
		m.ResetCandidateInterviewEdges()
		return nil
	case user.EdgeTeamUsers:
		m.ResetTeamUsers()
		return nil
	case user.EdgeInterviewUsers:
		m.ResetInterviewUsers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
