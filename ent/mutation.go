// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"trec/ent/attachment"
	"trec/ent/audittrail"
	"trec/ent/candidate"
	"trec/ent/candidateinterview"
	"trec/ent/candidateinterviewer"
	"trec/ent/candidatejob"
	"trec/ent/candidatejobfeedback"
	"trec/ent/candidatejobstep"
	"trec/ent/emailroleattribute"
	"trec/ent/emailtemplate"
	"trec/ent/entitypermission"
	"trec/ent/entityskill"
	"trec/ent/hiringjob"
	"trec/ent/hiringteam"
	"trec/ent/hiringteammanager"
	"trec/ent/jobposition"
	"trec/ent/outgoingemail"
	"trec/ent/permission"
	"trec/ent/permissiongroup"
	"trec/ent/predicate"
	"trec/ent/role"
	"trec/ent/skill"
	"trec/ent/skilltype"
	"trec/ent/team"
	"trec/ent/teammanager"
	"trec/ent/user"
	"trec/ent/userrole"

	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment           = "Attachment"
	TypeAuditTrail           = "AuditTrail"
	TypeCandidate            = "Candidate"
	TypeCandidateInterview   = "CandidateInterview"
	TypeCandidateInterviewer = "CandidateInterviewer"
	TypeCandidateJob         = "CandidateJob"
	TypeCandidateJobFeedback = "CandidateJobFeedback"
	TypeCandidateJobStep     = "CandidateJobStep"
	TypeEmailRoleAttribute   = "EmailRoleAttribute"
	TypeEmailTemplate        = "EmailTemplate"
	TypeEntityPermission     = "EntityPermission"
	TypeEntitySkill          = "EntitySkill"
	TypeHiringJob            = "HiringJob"
	TypeHiringTeam           = "HiringTeam"
	TypeHiringTeamManager    = "HiringTeamManager"
	TypeJobPosition          = "JobPosition"
	TypeOutgoingEmail        = "OutgoingEmail"
	TypePermission           = "Permission"
	TypePermissionGroup      = "PermissionGroup"
	TypeRole                 = "Role"
	TypeSkill                = "Skill"
	TypeSkillType            = "SkillType"
	TypeTeam                 = "Team"
	TypeTeamManager          = "TeamManager"
	TypeUser                 = "User"
	TypeUserRole             = "UserRole"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	created_at                         *time.Time
	updated_at                         *time.Time
	deleted_at                         *time.Time
	document_id                        *uuid.UUID
	document_name                      *string
	relation_type                      *attachment.RelationType
	clearedFields                      map[string]struct{}
	candidate_job_edge                 *uuid.UUID
	clearedcandidate_job_edge          bool
	candidate_job_feedback_edge        *uuid.UUID
	clearedcandidate_job_feedback_edge bool
	candidate_interview_edge           *uuid.UUID
	clearedcandidate_interview_edge    bool
	candidate_edge                     *uuid.UUID
	clearedcandidate_edge              bool
	done                               bool
	oldValue                           func(context.Context) (*Attachment, error)
	predicates                         []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AttachmentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[attachment.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AttachmentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, attachment.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attachment.FieldDeletedAt)
}

// SetDocumentID sets the "document_id" field.
func (m *AttachmentMutation) SetDocumentID(u uuid.UUID) {
	m.document_id = &u
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *AttachmentMutation) DocumentID() (r uuid.UUID, exists bool) {
	v := m.document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDocumentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *AttachmentMutation) ResetDocumentID() {
	m.document_id = nil
}

// SetDocumentName sets the "document_name" field.
func (m *AttachmentMutation) SetDocumentName(s string) {
	m.document_name = &s
}

// DocumentName returns the value of the "document_name" field in the mutation.
func (m *AttachmentMutation) DocumentName() (r string, exists bool) {
	v := m.document_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentName returns the old "document_name" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDocumentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentName: %w", err)
	}
	return oldValue.DocumentName, nil
}

// ResetDocumentName resets all changes to the "document_name" field.
func (m *AttachmentMutation) ResetDocumentName() {
	m.document_name = nil
}

// SetRelationType sets the "relation_type" field.
func (m *AttachmentMutation) SetRelationType(at attachment.RelationType) {
	m.relation_type = &at
}

// RelationType returns the value of the "relation_type" field in the mutation.
func (m *AttachmentMutation) RelationType() (r attachment.RelationType, exists bool) {
	v := m.relation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationType returns the old "relation_type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldRelationType(ctx context.Context) (v attachment.RelationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationType: %w", err)
	}
	return oldValue.RelationType, nil
}

// ResetRelationType resets all changes to the "relation_type" field.
func (m *AttachmentMutation) ResetRelationType() {
	m.relation_type = nil
}

// SetRelationID sets the "relation_id" field.
func (m *AttachmentMutation) SetRelationID(u uuid.UUID) {
	m.candidate_job_feedback_edge = &u
}

// RelationID returns the value of the "relation_id" field in the mutation.
func (m *AttachmentMutation) RelationID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_feedback_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationID returns the old "relation_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldRelationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationID: %w", err)
	}
	return oldValue.RelationID, nil
}

// ClearRelationID clears the value of the "relation_id" field.
func (m *AttachmentMutation) ClearRelationID() {
	m.candidate_job_feedback_edge = nil
	m.clearedFields[attachment.FieldRelationID] = struct{}{}
}

// RelationIDCleared returns if the "relation_id" field was cleared in this mutation.
func (m *AttachmentMutation) RelationIDCleared() bool {
	_, ok := m.clearedFields[attachment.FieldRelationID]
	return ok
}

// ResetRelationID resets all changes to the "relation_id" field.
func (m *AttachmentMutation) ResetRelationID() {
	m.candidate_job_feedback_edge = nil
	delete(m.clearedFields, attachment.FieldRelationID)
}

// SetCandidateJobEdgeID sets the "candidate_job_edge" edge to the CandidateJob entity by id.
func (m *AttachmentMutation) SetCandidateJobEdgeID(id uuid.UUID) {
	m.candidate_job_edge = &id
}

// ClearCandidateJobEdge clears the "candidate_job_edge" edge to the CandidateJob entity.
func (m *AttachmentMutation) ClearCandidateJobEdge() {
	m.clearedcandidate_job_edge = true
}

// CandidateJobEdgeCleared reports if the "candidate_job_edge" edge to the CandidateJob entity was cleared.
func (m *AttachmentMutation) CandidateJobEdgeCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_job_edge
}

// CandidateJobEdgeID returns the "candidate_job_edge" edge ID in the mutation.
func (m *AttachmentMutation) CandidateJobEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_edge != nil {
		return *m.candidate_job_edge, true
	}
	return
}

// CandidateJobEdgeIDs returns the "candidate_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobEdgeID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobEdge resets all changes to the "candidate_job_edge" edge.
func (m *AttachmentMutation) ResetCandidateJobEdge() {
	m.candidate_job_edge = nil
	m.clearedcandidate_job_edge = false
}

// SetCandidateJobFeedbackEdgeID sets the "candidate_job_feedback_edge" edge to the CandidateJobFeedback entity by id.
func (m *AttachmentMutation) SetCandidateJobFeedbackEdgeID(id uuid.UUID) {
	m.candidate_job_feedback_edge = &id
}

// ClearCandidateJobFeedbackEdge clears the "candidate_job_feedback_edge" edge to the CandidateJobFeedback entity.
func (m *AttachmentMutation) ClearCandidateJobFeedbackEdge() {
	m.clearedcandidate_job_feedback_edge = true
}

// CandidateJobFeedbackEdgeCleared reports if the "candidate_job_feedback_edge" edge to the CandidateJobFeedback entity was cleared.
func (m *AttachmentMutation) CandidateJobFeedbackEdgeCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_job_feedback_edge
}

// CandidateJobFeedbackEdgeID returns the "candidate_job_feedback_edge" edge ID in the mutation.
func (m *AttachmentMutation) CandidateJobFeedbackEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_feedback_edge != nil {
		return *m.candidate_job_feedback_edge, true
	}
	return
}

// CandidateJobFeedbackEdgeIDs returns the "candidate_job_feedback_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobFeedbackEdgeID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateJobFeedbackEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_feedback_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobFeedbackEdge resets all changes to the "candidate_job_feedback_edge" edge.
func (m *AttachmentMutation) ResetCandidateJobFeedbackEdge() {
	m.candidate_job_feedback_edge = nil
	m.clearedcandidate_job_feedback_edge = false
}

// SetCandidateInterviewEdgeID sets the "candidate_interview_edge" edge to the CandidateInterview entity by id.
func (m *AttachmentMutation) SetCandidateInterviewEdgeID(id uuid.UUID) {
	m.candidate_interview_edge = &id
}

// ClearCandidateInterviewEdge clears the "candidate_interview_edge" edge to the CandidateInterview entity.
func (m *AttachmentMutation) ClearCandidateInterviewEdge() {
	m.clearedcandidate_interview_edge = true
}

// CandidateInterviewEdgeCleared reports if the "candidate_interview_edge" edge to the CandidateInterview entity was cleared.
func (m *AttachmentMutation) CandidateInterviewEdgeCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_interview_edge
}

// CandidateInterviewEdgeID returns the "candidate_interview_edge" edge ID in the mutation.
func (m *AttachmentMutation) CandidateInterviewEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_interview_edge != nil {
		return *m.candidate_interview_edge, true
	}
	return
}

// CandidateInterviewEdgeIDs returns the "candidate_interview_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateInterviewEdgeID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateInterviewEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_interview_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateInterviewEdge resets all changes to the "candidate_interview_edge" edge.
func (m *AttachmentMutation) ResetCandidateInterviewEdge() {
	m.candidate_interview_edge = nil
	m.clearedcandidate_interview_edge = false
}

// SetCandidateEdgeID sets the "candidate_edge" edge to the Candidate entity by id.
func (m *AttachmentMutation) SetCandidateEdgeID(id uuid.UUID) {
	m.candidate_edge = &id
}

// ClearCandidateEdge clears the "candidate_edge" edge to the Candidate entity.
func (m *AttachmentMutation) ClearCandidateEdge() {
	m.clearedcandidate_edge = true
}

// CandidateEdgeCleared reports if the "candidate_edge" edge to the Candidate entity was cleared.
func (m *AttachmentMutation) CandidateEdgeCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_edge
}

// CandidateEdgeID returns the "candidate_edge" edge ID in the mutation.
func (m *AttachmentMutation) CandidateEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_edge != nil {
		return *m.candidate_edge, true
	}
	return
}

// CandidateEdgeIDs returns the "candidate_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateEdgeID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateEdge resets all changes to the "candidate_edge" edge.
func (m *AttachmentMutation) ResetCandidateEdge() {
	m.candidate_edge = nil
	m.clearedcandidate_edge = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.document_id != nil {
		fields = append(fields, attachment.FieldDocumentID)
	}
	if m.document_name != nil {
		fields = append(fields, attachment.FieldDocumentName)
	}
	if m.relation_type != nil {
		fields = append(fields, attachment.FieldRelationType)
	}
	if m.candidate_job_feedback_edge != nil {
		fields = append(fields, attachment.FieldRelationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldDeletedAt:
		return m.DeletedAt()
	case attachment.FieldDocumentID:
		return m.DocumentID()
	case attachment.FieldDocumentName:
		return m.DocumentName()
	case attachment.FieldRelationType:
		return m.RelationType()
	case attachment.FieldRelationID:
		return m.RelationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attachment.FieldDocumentID:
		return m.OldDocumentID(ctx)
	case attachment.FieldDocumentName:
		return m.OldDocumentName(ctx)
	case attachment.FieldRelationType:
		return m.OldRelationType(ctx)
	case attachment.FieldRelationID:
		return m.OldRelationID(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attachment.FieldDocumentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	case attachment.FieldDocumentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentName(v)
		return nil
	case attachment.FieldRelationType:
		v, ok := value.(attachment.RelationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationType(v)
		return nil
	case attachment.FieldRelationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationID(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldUpdatedAt) {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.FieldCleared(attachment.FieldDeletedAt) {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.FieldCleared(attachment.FieldRelationID) {
		fields = append(fields, attachment.FieldRelationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attachment.FieldRelationID:
		m.ClearRelationID()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attachment.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	case attachment.FieldDocumentName:
		m.ResetDocumentName()
		return nil
	case attachment.FieldRelationType:
		m.ResetRelationType()
		return nil
	case attachment.FieldRelationID:
		m.ResetRelationID()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.candidate_job_edge != nil {
		edges = append(edges, attachment.EdgeCandidateJobEdge)
	}
	if m.candidate_job_feedback_edge != nil {
		edges = append(edges, attachment.EdgeCandidateJobFeedbackEdge)
	}
	if m.candidate_interview_edge != nil {
		edges = append(edges, attachment.EdgeCandidateInterviewEdge)
	}
	if m.candidate_edge != nil {
		edges = append(edges, attachment.EdgeCandidateEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeCandidateJobEdge:
		if id := m.candidate_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeCandidateJobFeedbackEdge:
		if id := m.candidate_job_feedback_edge; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeCandidateInterviewEdge:
		if id := m.candidate_interview_edge; id != nil {
			return []ent.Value{*id}
		}
	case attachment.EdgeCandidateEdge:
		if id := m.candidate_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcandidate_job_edge {
		edges = append(edges, attachment.EdgeCandidateJobEdge)
	}
	if m.clearedcandidate_job_feedback_edge {
		edges = append(edges, attachment.EdgeCandidateJobFeedbackEdge)
	}
	if m.clearedcandidate_interview_edge {
		edges = append(edges, attachment.EdgeCandidateInterviewEdge)
	}
	if m.clearedcandidate_edge {
		edges = append(edges, attachment.EdgeCandidateEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeCandidateJobEdge:
		return m.clearedcandidate_job_edge
	case attachment.EdgeCandidateJobFeedbackEdge:
		return m.clearedcandidate_job_feedback_edge
	case attachment.EdgeCandidateInterviewEdge:
		return m.clearedcandidate_interview_edge
	case attachment.EdgeCandidateEdge:
		return m.clearedcandidate_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeCandidateJobEdge:
		m.ClearCandidateJobEdge()
		return nil
	case attachment.EdgeCandidateJobFeedbackEdge:
		m.ClearCandidateJobFeedbackEdge()
		return nil
	case attachment.EdgeCandidateInterviewEdge:
		m.ClearCandidateInterviewEdge()
		return nil
	case attachment.EdgeCandidateEdge:
		m.ClearCandidateEdge()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeCandidateJobEdge:
		m.ResetCandidateJobEdge()
		return nil
	case attachment.EdgeCandidateJobFeedbackEdge:
		m.ResetCandidateJobFeedbackEdge()
		return nil
	case attachment.EdgeCandidateInterviewEdge:
		m.ResetCandidateInterviewEdge()
		return nil
	case attachment.EdgeCandidateEdge:
		m.ResetCandidateEdge()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// AuditTrailMutation represents an operation that mutates the AuditTrail nodes in the graph.
type AuditTrailMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	recordId         *uuid.UUID
	module           *audittrail.Module
	actionType       *audittrail.ActionType
	note             *string
	record_changes   *string
	clearedFields    map[string]struct{}
	user_edge        *uuid.UUID
	cleareduser_edge bool
	done             bool
	oldValue         func(context.Context) (*AuditTrail, error)
	predicates       []predicate.AuditTrail
}

var _ ent.Mutation = (*AuditTrailMutation)(nil)

// audittrailOption allows management of the mutation configuration using functional options.
type audittrailOption func(*AuditTrailMutation)

// newAuditTrailMutation creates new mutation for the AuditTrail entity.
func newAuditTrailMutation(c config, op Op, opts ...audittrailOption) *AuditTrailMutation {
	m := &AuditTrailMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditTrail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditTrailID sets the ID field of the mutation.
func withAuditTrailID(id uuid.UUID) audittrailOption {
	return func(m *AuditTrailMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditTrail
		)
		m.oldValue = func(ctx context.Context) (*AuditTrail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditTrail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditTrail sets the old AuditTrail of the mutation.
func withAuditTrail(node *AuditTrail) audittrailOption {
	return func(m *AuditTrailMutation) {
		m.oldValue = func(context.Context) (*AuditTrail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditTrailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditTrailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditTrail entities.
func (m *AuditTrailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditTrailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditTrailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditTrail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditTrailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditTrailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditTrailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuditTrailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuditTrailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AuditTrailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[audittrail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AuditTrailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuditTrailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, audittrail.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuditTrailMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuditTrailMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuditTrailMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[audittrail.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuditTrailMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuditTrailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, audittrail.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AuditTrailMutation) SetCreatedBy(u uuid.UUID) {
	m.user_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AuditTrailMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AuditTrailMutation) ClearCreatedBy() {
	m.user_edge = nil
	m.clearedFields[audittrail.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AuditTrailMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AuditTrailMutation) ResetCreatedBy() {
	m.user_edge = nil
	delete(m.clearedFields, audittrail.FieldCreatedBy)
}

// SetRecordId sets the "recordId" field.
func (m *AuditTrailMutation) SetRecordId(u uuid.UUID) {
	m.recordId = &u
}

// RecordId returns the value of the "recordId" field in the mutation.
func (m *AuditTrailMutation) RecordId() (r uuid.UUID, exists bool) {
	v := m.recordId
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordId returns the old "recordId" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldRecordId(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordId: %w", err)
	}
	return oldValue.RecordId, nil
}

// ResetRecordId resets all changes to the "recordId" field.
func (m *AuditTrailMutation) ResetRecordId() {
	m.recordId = nil
}

// SetModule sets the "module" field.
func (m *AuditTrailMutation) SetModule(a audittrail.Module) {
	m.module = &a
}

// Module returns the value of the "module" field in the mutation.
func (m *AuditTrailMutation) Module() (r audittrail.Module, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldModule(ctx context.Context) (v audittrail.Module, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *AuditTrailMutation) ResetModule() {
	m.module = nil
}

// SetActionType sets the "actionType" field.
func (m *AuditTrailMutation) SetActionType(at audittrail.ActionType) {
	m.actionType = &at
}

// ActionType returns the value of the "actionType" field in the mutation.
func (m *AuditTrailMutation) ActionType() (r audittrail.ActionType, exists bool) {
	v := m.actionType
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "actionType" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldActionType(ctx context.Context) (v audittrail.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ClearActionType clears the value of the "actionType" field.
func (m *AuditTrailMutation) ClearActionType() {
	m.actionType = nil
	m.clearedFields[audittrail.FieldActionType] = struct{}{}
}

// ActionTypeCleared returns if the "actionType" field was cleared in this mutation.
func (m *AuditTrailMutation) ActionTypeCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldActionType]
	return ok
}

// ResetActionType resets all changes to the "actionType" field.
func (m *AuditTrailMutation) ResetActionType() {
	m.actionType = nil
	delete(m.clearedFields, audittrail.FieldActionType)
}

// SetNote sets the "note" field.
func (m *AuditTrailMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *AuditTrailMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *AuditTrailMutation) ClearNote() {
	m.note = nil
	m.clearedFields[audittrail.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *AuditTrailMutation) NoteCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *AuditTrailMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, audittrail.FieldNote)
}

// SetRecordChanges sets the "record_changes" field.
func (m *AuditTrailMutation) SetRecordChanges(s string) {
	m.record_changes = &s
}

// RecordChanges returns the value of the "record_changes" field in the mutation.
func (m *AuditTrailMutation) RecordChanges() (r string, exists bool) {
	v := m.record_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordChanges returns the old "record_changes" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldRecordChanges(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordChanges: %w", err)
	}
	return oldValue.RecordChanges, nil
}

// ClearRecordChanges clears the value of the "record_changes" field.
func (m *AuditTrailMutation) ClearRecordChanges() {
	m.record_changes = nil
	m.clearedFields[audittrail.FieldRecordChanges] = struct{}{}
}

// RecordChangesCleared returns if the "record_changes" field was cleared in this mutation.
func (m *AuditTrailMutation) RecordChangesCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldRecordChanges]
	return ok
}

// ResetRecordChanges resets all changes to the "record_changes" field.
func (m *AuditTrailMutation) ResetRecordChanges() {
	m.record_changes = nil
	delete(m.clearedFields, audittrail.FieldRecordChanges)
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *AuditTrailMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *AuditTrailMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *AuditTrailMutation) UserEdgeCleared() bool {
	return m.CreatedByCleared() || m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *AuditTrailMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *AuditTrailMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *AuditTrailMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// Where appends a list predicates to the AuditTrailMutation builder.
func (m *AuditTrailMutation) Where(ps ...predicate.AuditTrail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuditTrailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuditTrail).
func (m *AuditTrailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditTrailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, audittrail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, audittrail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, audittrail.FieldDeletedAt)
	}
	if m.user_edge != nil {
		fields = append(fields, audittrail.FieldCreatedBy)
	}
	if m.recordId != nil {
		fields = append(fields, audittrail.FieldRecordId)
	}
	if m.module != nil {
		fields = append(fields, audittrail.FieldModule)
	}
	if m.actionType != nil {
		fields = append(fields, audittrail.FieldActionType)
	}
	if m.note != nil {
		fields = append(fields, audittrail.FieldNote)
	}
	if m.record_changes != nil {
		fields = append(fields, audittrail.FieldRecordChanges)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditTrailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case audittrail.FieldCreatedAt:
		return m.CreatedAt()
	case audittrail.FieldUpdatedAt:
		return m.UpdatedAt()
	case audittrail.FieldDeletedAt:
		return m.DeletedAt()
	case audittrail.FieldCreatedBy:
		return m.CreatedBy()
	case audittrail.FieldRecordId:
		return m.RecordId()
	case audittrail.FieldModule:
		return m.Module()
	case audittrail.FieldActionType:
		return m.ActionType()
	case audittrail.FieldNote:
		return m.Note()
	case audittrail.FieldRecordChanges:
		return m.RecordChanges()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditTrailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case audittrail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case audittrail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case audittrail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case audittrail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case audittrail.FieldRecordId:
		return m.OldRecordId(ctx)
	case audittrail.FieldModule:
		return m.OldModule(ctx)
	case audittrail.FieldActionType:
		return m.OldActionType(ctx)
	case audittrail.FieldNote:
		return m.OldNote(ctx)
	case audittrail.FieldRecordChanges:
		return m.OldRecordChanges(ctx)
	}
	return nil, fmt.Errorf("unknown AuditTrail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditTrailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case audittrail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case audittrail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case audittrail.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case audittrail.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case audittrail.FieldRecordId:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordId(v)
		return nil
	case audittrail.FieldModule:
		v, ok := value.(audittrail.Module)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case audittrail.FieldActionType:
		v, ok := value.(audittrail.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case audittrail.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case audittrail.FieldRecordChanges:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordChanges(v)
		return nil
	}
	return fmt.Errorf("unknown AuditTrail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditTrailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditTrailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditTrailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditTrail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditTrailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(audittrail.FieldUpdatedAt) {
		fields = append(fields, audittrail.FieldUpdatedAt)
	}
	if m.FieldCleared(audittrail.FieldDeletedAt) {
		fields = append(fields, audittrail.FieldDeletedAt)
	}
	if m.FieldCleared(audittrail.FieldCreatedBy) {
		fields = append(fields, audittrail.FieldCreatedBy)
	}
	if m.FieldCleared(audittrail.FieldActionType) {
		fields = append(fields, audittrail.FieldActionType)
	}
	if m.FieldCleared(audittrail.FieldNote) {
		fields = append(fields, audittrail.FieldNote)
	}
	if m.FieldCleared(audittrail.FieldRecordChanges) {
		fields = append(fields, audittrail.FieldRecordChanges)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditTrailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditTrailMutation) ClearField(name string) error {
	switch name {
	case audittrail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case audittrail.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case audittrail.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case audittrail.FieldActionType:
		m.ClearActionType()
		return nil
	case audittrail.FieldNote:
		m.ClearNote()
		return nil
	case audittrail.FieldRecordChanges:
		m.ClearRecordChanges()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditTrailMutation) ResetField(name string) error {
	switch name {
	case audittrail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case audittrail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case audittrail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case audittrail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case audittrail.FieldRecordId:
		m.ResetRecordId()
		return nil
	case audittrail.FieldModule:
		m.ResetModule()
		return nil
	case audittrail.FieldActionType:
		m.ResetActionType()
		return nil
	case audittrail.FieldNote:
		m.ResetNote()
		return nil
	case audittrail.FieldRecordChanges:
		m.ResetRecordChanges()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditTrailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_edge != nil {
		edges = append(edges, audittrail.EdgeUserEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditTrailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case audittrail.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditTrailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditTrailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditTrailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_edge {
		edges = append(edges, audittrail.EdgeUserEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditTrailMutation) EdgeCleared(name string) bool {
	switch name {
	case audittrail.EdgeUserEdge:
		return m.cleareduser_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditTrailMutation) ClearEdge(name string) error {
	switch name {
	case audittrail.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditTrailMutation) ResetEdge(name string) error {
	switch name {
	case audittrail.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail edge %s", name)
}

// CandidateMutation represents an operation that mutates the Candidate nodes in the graph.
type CandidateMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	email                        *string
	phone                        *string
	dob                          *time.Time
	is_blacklist                 *bool
	last_apply_date              *time.Time
	reference_type               *candidate.ReferenceType
	reference_value              *string
	recruit_time                 *time.Time
	description                  *string
	country                      *string
	clearedFields                map[string]struct{}
	candidate_job_edges          map[uuid.UUID]struct{}
	removedcandidate_job_edges   map[uuid.UUID]struct{}
	clearedcandidate_job_edges   bool
	reference_user_edge          *uuid.UUID
	clearedreference_user_edge   bool
	attachment_edges             map[uuid.UUID]struct{}
	removedattachment_edges      map[uuid.UUID]struct{}
	clearedattachment_edges      bool
	candidate_skill_edges        map[uuid.UUID]struct{}
	removedcandidate_skill_edges map[uuid.UUID]struct{}
	clearedcandidate_skill_edges bool
	done                         bool
	oldValue                     func(context.Context) (*Candidate, error)
	predicates                   []predicate.Candidate
}

var _ ent.Mutation = (*CandidateMutation)(nil)

// candidateOption allows management of the mutation configuration using functional options.
type candidateOption func(*CandidateMutation)

// newCandidateMutation creates new mutation for the Candidate entity.
func newCandidateMutation(c config, op Op, opts ...candidateOption) *CandidateMutation {
	m := &CandidateMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateID sets the ID field of the mutation.
func withCandidateID(id uuid.UUID) candidateOption {
	return func(m *CandidateMutation) {
		var (
			err   error
			once  sync.Once
			value *Candidate
		)
		m.oldValue = func(ctx context.Context) (*Candidate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Candidate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidate sets the old Candidate of the mutation.
func withCandidate(node *Candidate) candidateOption {
	return func(m *CandidateMutation) {
		m.oldValue = func(context.Context) (*Candidate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Candidate entities.
func (m *CandidateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Candidate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidate.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidate.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidate.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidate.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CandidateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CandidateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CandidateMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *CandidateMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CandidateMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CandidateMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *CandidateMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CandidateMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CandidateMutation) ResetPhone() {
	m.phone = nil
}

// SetDob sets the "dob" field.
func (m *CandidateMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *CandidateMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ClearDob clears the value of the "dob" field.
func (m *CandidateMutation) ClearDob() {
	m.dob = nil
	m.clearedFields[candidate.FieldDob] = struct{}{}
}

// DobCleared returns if the "dob" field was cleared in this mutation.
func (m *CandidateMutation) DobCleared() bool {
	_, ok := m.clearedFields[candidate.FieldDob]
	return ok
}

// ResetDob resets all changes to the "dob" field.
func (m *CandidateMutation) ResetDob() {
	m.dob = nil
	delete(m.clearedFields, candidate.FieldDob)
}

// SetIsBlacklist sets the "is_blacklist" field.
func (m *CandidateMutation) SetIsBlacklist(b bool) {
	m.is_blacklist = &b
}

// IsBlacklist returns the value of the "is_blacklist" field in the mutation.
func (m *CandidateMutation) IsBlacklist() (r bool, exists bool) {
	v := m.is_blacklist
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBlacklist returns the old "is_blacklist" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldIsBlacklist(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBlacklist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBlacklist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBlacklist: %w", err)
	}
	return oldValue.IsBlacklist, nil
}

// ResetIsBlacklist resets all changes to the "is_blacklist" field.
func (m *CandidateMutation) ResetIsBlacklist() {
	m.is_blacklist = nil
}

// SetLastApplyDate sets the "last_apply_date" field.
func (m *CandidateMutation) SetLastApplyDate(t time.Time) {
	m.last_apply_date = &t
}

// LastApplyDate returns the value of the "last_apply_date" field in the mutation.
func (m *CandidateMutation) LastApplyDate() (r time.Time, exists bool) {
	v := m.last_apply_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastApplyDate returns the old "last_apply_date" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldLastApplyDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastApplyDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastApplyDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastApplyDate: %w", err)
	}
	return oldValue.LastApplyDate, nil
}

// ClearLastApplyDate clears the value of the "last_apply_date" field.
func (m *CandidateMutation) ClearLastApplyDate() {
	m.last_apply_date = nil
	m.clearedFields[candidate.FieldLastApplyDate] = struct{}{}
}

// LastApplyDateCleared returns if the "last_apply_date" field was cleared in this mutation.
func (m *CandidateMutation) LastApplyDateCleared() bool {
	_, ok := m.clearedFields[candidate.FieldLastApplyDate]
	return ok
}

// ResetLastApplyDate resets all changes to the "last_apply_date" field.
func (m *CandidateMutation) ResetLastApplyDate() {
	m.last_apply_date = nil
	delete(m.clearedFields, candidate.FieldLastApplyDate)
}

// SetReferenceType sets the "reference_type" field.
func (m *CandidateMutation) SetReferenceType(ct candidate.ReferenceType) {
	m.reference_type = &ct
}

// ReferenceType returns the value of the "reference_type" field in the mutation.
func (m *CandidateMutation) ReferenceType() (r candidate.ReferenceType, exists bool) {
	v := m.reference_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceType returns the old "reference_type" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldReferenceType(ctx context.Context) (v candidate.ReferenceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceType: %w", err)
	}
	return oldValue.ReferenceType, nil
}

// ResetReferenceType resets all changes to the "reference_type" field.
func (m *CandidateMutation) ResetReferenceType() {
	m.reference_type = nil
}

// SetReferenceValue sets the "reference_value" field.
func (m *CandidateMutation) SetReferenceValue(s string) {
	m.reference_value = &s
}

// ReferenceValue returns the value of the "reference_value" field in the mutation.
func (m *CandidateMutation) ReferenceValue() (r string, exists bool) {
	v := m.reference_value
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceValue returns the old "reference_value" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldReferenceValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceValue: %w", err)
	}
	return oldValue.ReferenceValue, nil
}

// ClearReferenceValue clears the value of the "reference_value" field.
func (m *CandidateMutation) ClearReferenceValue() {
	m.reference_value = nil
	m.clearedFields[candidate.FieldReferenceValue] = struct{}{}
}

// ReferenceValueCleared returns if the "reference_value" field was cleared in this mutation.
func (m *CandidateMutation) ReferenceValueCleared() bool {
	_, ok := m.clearedFields[candidate.FieldReferenceValue]
	return ok
}

// ResetReferenceValue resets all changes to the "reference_value" field.
func (m *CandidateMutation) ResetReferenceValue() {
	m.reference_value = nil
	delete(m.clearedFields, candidate.FieldReferenceValue)
}

// SetReferenceUID sets the "reference_uid" field.
func (m *CandidateMutation) SetReferenceUID(u uuid.UUID) {
	m.reference_user_edge = &u
}

// ReferenceUID returns the value of the "reference_uid" field in the mutation.
func (m *CandidateMutation) ReferenceUID() (r uuid.UUID, exists bool) {
	v := m.reference_user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceUID returns the old "reference_uid" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldReferenceUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceUID: %w", err)
	}
	return oldValue.ReferenceUID, nil
}

// ClearReferenceUID clears the value of the "reference_uid" field.
func (m *CandidateMutation) ClearReferenceUID() {
	m.reference_user_edge = nil
	m.clearedFields[candidate.FieldReferenceUID] = struct{}{}
}

// ReferenceUIDCleared returns if the "reference_uid" field was cleared in this mutation.
func (m *CandidateMutation) ReferenceUIDCleared() bool {
	_, ok := m.clearedFields[candidate.FieldReferenceUID]
	return ok
}

// ResetReferenceUID resets all changes to the "reference_uid" field.
func (m *CandidateMutation) ResetReferenceUID() {
	m.reference_user_edge = nil
	delete(m.clearedFields, candidate.FieldReferenceUID)
}

// SetRecruitTime sets the "recruit_time" field.
func (m *CandidateMutation) SetRecruitTime(t time.Time) {
	m.recruit_time = &t
}

// RecruitTime returns the value of the "recruit_time" field in the mutation.
func (m *CandidateMutation) RecruitTime() (r time.Time, exists bool) {
	v := m.recruit_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRecruitTime returns the old "recruit_time" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldRecruitTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecruitTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecruitTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecruitTime: %w", err)
	}
	return oldValue.RecruitTime, nil
}

// ClearRecruitTime clears the value of the "recruit_time" field.
func (m *CandidateMutation) ClearRecruitTime() {
	m.recruit_time = nil
	m.clearedFields[candidate.FieldRecruitTime] = struct{}{}
}

// RecruitTimeCleared returns if the "recruit_time" field was cleared in this mutation.
func (m *CandidateMutation) RecruitTimeCleared() bool {
	_, ok := m.clearedFields[candidate.FieldRecruitTime]
	return ok
}

// ResetRecruitTime resets all changes to the "recruit_time" field.
func (m *CandidateMutation) ResetRecruitTime() {
	m.recruit_time = nil
	delete(m.clearedFields, candidate.FieldRecruitTime)
}

// SetDescription sets the "description" field.
func (m *CandidateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CandidateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CandidateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[candidate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CandidateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[candidate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CandidateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, candidate.FieldDescription)
}

// SetCountry sets the "country" field.
func (m *CandidateMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *CandidateMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *CandidateMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[candidate.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *CandidateMutation) CountryCleared() bool {
	_, ok := m.clearedFields[candidate.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *CandidateMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, candidate.FieldCountry)
}

// AddCandidateJobEdgeIDs adds the "candidate_job_edges" edge to the CandidateJob entity by ids.
func (m *CandidateMutation) AddCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_job_edges == nil {
		m.candidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobEdges clears the "candidate_job_edges" edge to the CandidateJob entity.
func (m *CandidateMutation) ClearCandidateJobEdges() {
	m.clearedcandidate_job_edges = true
}

// CandidateJobEdgesCleared reports if the "candidate_job_edges" edge to the CandidateJob entity was cleared.
func (m *CandidateMutation) CandidateJobEdgesCleared() bool {
	return m.clearedcandidate_job_edges
}

// RemoveCandidateJobEdgeIDs removes the "candidate_job_edges" edge to the CandidateJob entity by IDs.
func (m *CandidateMutation) RemoveCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_edges == nil {
		m.removedcandidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_edges, ids[i])
		m.removedcandidate_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobEdges returns the removed IDs of the "candidate_job_edges" edge to the CandidateJob entity.
func (m *CandidateMutation) RemovedCandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateJobEdgesIDs returns the "candidate_job_edges" edge IDs in the mutation.
func (m *CandidateMutation) CandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobEdges resets all changes to the "candidate_job_edges" edge.
func (m *CandidateMutation) ResetCandidateJobEdges() {
	m.candidate_job_edges = nil
	m.clearedcandidate_job_edges = false
	m.removedcandidate_job_edges = nil
}

// SetReferenceUserEdgeID sets the "reference_user_edge" edge to the User entity by id.
func (m *CandidateMutation) SetReferenceUserEdgeID(id uuid.UUID) {
	m.reference_user_edge = &id
}

// ClearReferenceUserEdge clears the "reference_user_edge" edge to the User entity.
func (m *CandidateMutation) ClearReferenceUserEdge() {
	m.clearedreference_user_edge = true
}

// ReferenceUserEdgeCleared reports if the "reference_user_edge" edge to the User entity was cleared.
func (m *CandidateMutation) ReferenceUserEdgeCleared() bool {
	return m.ReferenceUIDCleared() || m.clearedreference_user_edge
}

// ReferenceUserEdgeID returns the "reference_user_edge" edge ID in the mutation.
func (m *CandidateMutation) ReferenceUserEdgeID() (id uuid.UUID, exists bool) {
	if m.reference_user_edge != nil {
		return *m.reference_user_edge, true
	}
	return
}

// ReferenceUserEdgeIDs returns the "reference_user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferenceUserEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateMutation) ReferenceUserEdgeIDs() (ids []uuid.UUID) {
	if id := m.reference_user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferenceUserEdge resets all changes to the "reference_user_edge" edge.
func (m *CandidateMutation) ResetReferenceUserEdge() {
	m.reference_user_edge = nil
	m.clearedreference_user_edge = false
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// AddCandidateSkillEdgeIDs adds the "candidate_skill_edges" edge to the EntitySkill entity by ids.
func (m *CandidateMutation) AddCandidateSkillEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_skill_edges == nil {
		m.candidate_skill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_skill_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateSkillEdges clears the "candidate_skill_edges" edge to the EntitySkill entity.
func (m *CandidateMutation) ClearCandidateSkillEdges() {
	m.clearedcandidate_skill_edges = true
}

// CandidateSkillEdgesCleared reports if the "candidate_skill_edges" edge to the EntitySkill entity was cleared.
func (m *CandidateMutation) CandidateSkillEdgesCleared() bool {
	return m.clearedcandidate_skill_edges
}

// RemoveCandidateSkillEdgeIDs removes the "candidate_skill_edges" edge to the EntitySkill entity by IDs.
func (m *CandidateMutation) RemoveCandidateSkillEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_skill_edges == nil {
		m.removedcandidate_skill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_skill_edges, ids[i])
		m.removedcandidate_skill_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateSkillEdges returns the removed IDs of the "candidate_skill_edges" edge to the EntitySkill entity.
func (m *CandidateMutation) RemovedCandidateSkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_skill_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateSkillEdgesIDs returns the "candidate_skill_edges" edge IDs in the mutation.
func (m *CandidateMutation) CandidateSkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_skill_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateSkillEdges resets all changes to the "candidate_skill_edges" edge.
func (m *CandidateMutation) ResetCandidateSkillEdges() {
	m.candidate_skill_edges = nil
	m.clearedcandidate_skill_edges = false
	m.removedcandidate_skill_edges = nil
}

// Where appends a list predicates to the CandidateMutation builder.
func (m *CandidateMutation) Where(ps ...predicate.Candidate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Candidate).
func (m *CandidateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, candidate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidate.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, candidate.FieldName)
	}
	if m.email != nil {
		fields = append(fields, candidate.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, candidate.FieldPhone)
	}
	if m.dob != nil {
		fields = append(fields, candidate.FieldDob)
	}
	if m.is_blacklist != nil {
		fields = append(fields, candidate.FieldIsBlacklist)
	}
	if m.last_apply_date != nil {
		fields = append(fields, candidate.FieldLastApplyDate)
	}
	if m.reference_type != nil {
		fields = append(fields, candidate.FieldReferenceType)
	}
	if m.reference_value != nil {
		fields = append(fields, candidate.FieldReferenceValue)
	}
	if m.reference_user_edge != nil {
		fields = append(fields, candidate.FieldReferenceUID)
	}
	if m.recruit_time != nil {
		fields = append(fields, candidate.FieldRecruitTime)
	}
	if m.description != nil {
		fields = append(fields, candidate.FieldDescription)
	}
	if m.country != nil {
		fields = append(fields, candidate.FieldCountry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidate.FieldCreatedAt:
		return m.CreatedAt()
	case candidate.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidate.FieldDeletedAt:
		return m.DeletedAt()
	case candidate.FieldName:
		return m.Name()
	case candidate.FieldEmail:
		return m.Email()
	case candidate.FieldPhone:
		return m.Phone()
	case candidate.FieldDob:
		return m.Dob()
	case candidate.FieldIsBlacklist:
		return m.IsBlacklist()
	case candidate.FieldLastApplyDate:
		return m.LastApplyDate()
	case candidate.FieldReferenceType:
		return m.ReferenceType()
	case candidate.FieldReferenceValue:
		return m.ReferenceValue()
	case candidate.FieldReferenceUID:
		return m.ReferenceUID()
	case candidate.FieldRecruitTime:
		return m.RecruitTime()
	case candidate.FieldDescription:
		return m.Description()
	case candidate.FieldCountry:
		return m.Country()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidate.FieldName:
		return m.OldName(ctx)
	case candidate.FieldEmail:
		return m.OldEmail(ctx)
	case candidate.FieldPhone:
		return m.OldPhone(ctx)
	case candidate.FieldDob:
		return m.OldDob(ctx)
	case candidate.FieldIsBlacklist:
		return m.OldIsBlacklist(ctx)
	case candidate.FieldLastApplyDate:
		return m.OldLastApplyDate(ctx)
	case candidate.FieldReferenceType:
		return m.OldReferenceType(ctx)
	case candidate.FieldReferenceValue:
		return m.OldReferenceValue(ctx)
	case candidate.FieldReferenceUID:
		return m.OldReferenceUID(ctx)
	case candidate.FieldRecruitTime:
		return m.OldRecruitTime(ctx)
	case candidate.FieldDescription:
		return m.OldDescription(ctx)
	case candidate.FieldCountry:
		return m.OldCountry(ctx)
	}
	return nil, fmt.Errorf("unknown Candidate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case candidate.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case candidate.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case candidate.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case candidate.FieldIsBlacklist:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBlacklist(v)
		return nil
	case candidate.FieldLastApplyDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastApplyDate(v)
		return nil
	case candidate.FieldReferenceType:
		v, ok := value.(candidate.ReferenceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceType(v)
		return nil
	case candidate.FieldReferenceValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceValue(v)
		return nil
	case candidate.FieldReferenceUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceUID(v)
		return nil
	case candidate.FieldRecruitTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecruitTime(v)
		return nil
	case candidate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case candidate.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Candidate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidate.FieldUpdatedAt) {
		fields = append(fields, candidate.FieldUpdatedAt)
	}
	if m.FieldCleared(candidate.FieldDeletedAt) {
		fields = append(fields, candidate.FieldDeletedAt)
	}
	if m.FieldCleared(candidate.FieldDob) {
		fields = append(fields, candidate.FieldDob)
	}
	if m.FieldCleared(candidate.FieldLastApplyDate) {
		fields = append(fields, candidate.FieldLastApplyDate)
	}
	if m.FieldCleared(candidate.FieldReferenceValue) {
		fields = append(fields, candidate.FieldReferenceValue)
	}
	if m.FieldCleared(candidate.FieldReferenceUID) {
		fields = append(fields, candidate.FieldReferenceUID)
	}
	if m.FieldCleared(candidate.FieldRecruitTime) {
		fields = append(fields, candidate.FieldRecruitTime)
	}
	if m.FieldCleared(candidate.FieldDescription) {
		fields = append(fields, candidate.FieldDescription)
	}
	if m.FieldCleared(candidate.FieldCountry) {
		fields = append(fields, candidate.FieldCountry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateMutation) ClearField(name string) error {
	switch name {
	case candidate.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidate.FieldDob:
		m.ClearDob()
		return nil
	case candidate.FieldLastApplyDate:
		m.ClearLastApplyDate()
		return nil
	case candidate.FieldReferenceValue:
		m.ClearReferenceValue()
		return nil
	case candidate.FieldReferenceUID:
		m.ClearReferenceUID()
		return nil
	case candidate.FieldRecruitTime:
		m.ClearRecruitTime()
		return nil
	case candidate.FieldDescription:
		m.ClearDescription()
		return nil
	case candidate.FieldCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Candidate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateMutation) ResetField(name string) error {
	switch name {
	case candidate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidate.FieldName:
		m.ResetName()
		return nil
	case candidate.FieldEmail:
		m.ResetEmail()
		return nil
	case candidate.FieldPhone:
		m.ResetPhone()
		return nil
	case candidate.FieldDob:
		m.ResetDob()
		return nil
	case candidate.FieldIsBlacklist:
		m.ResetIsBlacklist()
		return nil
	case candidate.FieldLastApplyDate:
		m.ResetLastApplyDate()
		return nil
	case candidate.FieldReferenceType:
		m.ResetReferenceType()
		return nil
	case candidate.FieldReferenceValue:
		m.ResetReferenceValue()
		return nil
	case candidate.FieldReferenceUID:
		m.ResetReferenceUID()
		return nil
	case candidate.FieldRecruitTime:
		m.ResetRecruitTime()
		return nil
	case candidate.FieldDescription:
		m.ResetDescription()
		return nil
	case candidate.FieldCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.candidate_job_edges != nil {
		edges = append(edges, candidate.EdgeCandidateJobEdges)
	}
	if m.reference_user_edge != nil {
		edges = append(edges, candidate.EdgeReferenceUserEdge)
	}
	if m.attachment_edges != nil {
		edges = append(edges, candidate.EdgeAttachmentEdges)
	}
	if m.candidate_skill_edges != nil {
		edges = append(edges, candidate.EdgeCandidateSkillEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.candidate_job_edges))
		for id := range m.candidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case candidate.EdgeReferenceUserEdge:
		if id := m.reference_user_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidate.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidate.EdgeCandidateSkillEdges:
		ids := make([]ent.Value, 0, len(m.candidate_skill_edges))
		for id := range m.candidate_skill_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcandidate_job_edges != nil {
		edges = append(edges, candidate.EdgeCandidateJobEdges)
	}
	if m.removedattachment_edges != nil {
		edges = append(edges, candidate.EdgeAttachmentEdges)
	}
	if m.removedcandidate_skill_edges != nil {
		edges = append(edges, candidate.EdgeCandidateSkillEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_edges))
		for id := range m.removedcandidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case candidate.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidate.EdgeCandidateSkillEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_skill_edges))
		for id := range m.removedcandidate_skill_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcandidate_job_edges {
		edges = append(edges, candidate.EdgeCandidateJobEdges)
	}
	if m.clearedreference_user_edge {
		edges = append(edges, candidate.EdgeReferenceUserEdge)
	}
	if m.clearedattachment_edges {
		edges = append(edges, candidate.EdgeAttachmentEdges)
	}
	if m.clearedcandidate_skill_edges {
		edges = append(edges, candidate.EdgeCandidateSkillEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateMutation) EdgeCleared(name string) bool {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		return m.clearedcandidate_job_edges
	case candidate.EdgeReferenceUserEdge:
		return m.clearedreference_user_edge
	case candidate.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	case candidate.EdgeCandidateSkillEdges:
		return m.clearedcandidate_skill_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateMutation) ClearEdge(name string) error {
	switch name {
	case candidate.EdgeReferenceUserEdge:
		m.ClearReferenceUserEdge()
		return nil
	}
	return fmt.Errorf("unknown Candidate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateMutation) ResetEdge(name string) error {
	switch name {
	case candidate.EdgeCandidateJobEdges:
		m.ResetCandidateJobEdges()
		return nil
	case candidate.EdgeReferenceUserEdge:
		m.ResetReferenceUserEdge()
		return nil
	case candidate.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	case candidate.EdgeCandidateSkillEdges:
		m.ResetCandidateSkillEdges()
		return nil
	}
	return fmt.Errorf("unknown Candidate edge %s", name)
}

// CandidateInterviewMutation represents an operation that mutates the CandidateInterview nodes in the graph.
type CandidateInterviewMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	title                     *string
	candidate_job_status      *candidateinterview.CandidateJobStatus
	interview_date            *time.Time
	start_from                *time.Time
	end_at                    *time.Time
	description               *string
	status                    *candidateinterview.Status
	location                  *string
	meeting_link              *string
	clearedFields             map[string]struct{}
	candidate_job_edge        *uuid.UUID
	clearedcandidate_job_edge bool
	attachment_edges          map[uuid.UUID]struct{}
	removedattachment_edges   map[uuid.UUID]struct{}
	clearedattachment_edges   bool
	interviewer_edges         map[uuid.UUID]struct{}
	removedinterviewer_edges  map[uuid.UUID]struct{}
	clearedinterviewer_edges  bool
	created_by_edge           *uuid.UUID
	clearedcreated_by_edge    bool
	user_interviewers         map[uuid.UUID]struct{}
	removeduser_interviewers  map[uuid.UUID]struct{}
	cleareduser_interviewers  bool
	done                      bool
	oldValue                  func(context.Context) (*CandidateInterview, error)
	predicates                []predicate.CandidateInterview
}

var _ ent.Mutation = (*CandidateInterviewMutation)(nil)

// candidateinterviewOption allows management of the mutation configuration using functional options.
type candidateinterviewOption func(*CandidateInterviewMutation)

// newCandidateInterviewMutation creates new mutation for the CandidateInterview entity.
func newCandidateInterviewMutation(c config, op Op, opts ...candidateinterviewOption) *CandidateInterviewMutation {
	m := &CandidateInterviewMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateInterview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateInterviewID sets the ID field of the mutation.
func withCandidateInterviewID(id uuid.UUID) candidateinterviewOption {
	return func(m *CandidateInterviewMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateInterview
		)
		m.oldValue = func(ctx context.Context) (*CandidateInterview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateInterview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateInterview sets the old CandidateInterview of the mutation.
func withCandidateInterview(node *CandidateInterview) candidateinterviewOption {
	return func(m *CandidateInterviewMutation) {
		m.oldValue = func(context.Context) (*CandidateInterview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateInterviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateInterviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateInterview entities.
func (m *CandidateInterviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateInterviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateInterviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateInterview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateInterviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateInterviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateInterviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateInterviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateInterviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateInterviewMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidateinterview.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateInterviewMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateInterviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidateinterview.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateInterviewMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateInterviewMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateInterviewMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidateinterview.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateInterviewMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateInterviewMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidateinterview.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *CandidateInterviewMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CandidateInterviewMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CandidateInterviewMutation) ResetTitle() {
	m.title = nil
}

// SetCandidateJobStatus sets the "candidate_job_status" field.
func (m *CandidateInterviewMutation) SetCandidateJobStatus(cjs candidateinterview.CandidateJobStatus) {
	m.candidate_job_status = &cjs
}

// CandidateJobStatus returns the value of the "candidate_job_status" field in the mutation.
func (m *CandidateInterviewMutation) CandidateJobStatus() (r candidateinterview.CandidateJobStatus, exists bool) {
	v := m.candidate_job_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobStatus returns the old "candidate_job_status" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCandidateJobStatus(ctx context.Context) (v candidateinterview.CandidateJobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobStatus: %w", err)
	}
	return oldValue.CandidateJobStatus, nil
}

// ResetCandidateJobStatus resets all changes to the "candidate_job_status" field.
func (m *CandidateInterviewMutation) ResetCandidateJobStatus() {
	m.candidate_job_status = nil
}

// SetCandidateJobID sets the "candidate_job_id" field.
func (m *CandidateInterviewMutation) SetCandidateJobID(u uuid.UUID) {
	m.candidate_job_edge = &u
}

// CandidateJobID returns the value of the "candidate_job_id" field in the mutation.
func (m *CandidateInterviewMutation) CandidateJobID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobID returns the old "candidate_job_id" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCandidateJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobID: %w", err)
	}
	return oldValue.CandidateJobID, nil
}

// ClearCandidateJobID clears the value of the "candidate_job_id" field.
func (m *CandidateInterviewMutation) ClearCandidateJobID() {
	m.candidate_job_edge = nil
	m.clearedFields[candidateinterview.FieldCandidateJobID] = struct{}{}
}

// CandidateJobIDCleared returns if the "candidate_job_id" field was cleared in this mutation.
func (m *CandidateInterviewMutation) CandidateJobIDCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldCandidateJobID]
	return ok
}

// ResetCandidateJobID resets all changes to the "candidate_job_id" field.
func (m *CandidateInterviewMutation) ResetCandidateJobID() {
	m.candidate_job_edge = nil
	delete(m.clearedFields, candidateinterview.FieldCandidateJobID)
}

// SetInterviewDate sets the "interview_date" field.
func (m *CandidateInterviewMutation) SetInterviewDate(t time.Time) {
	m.interview_date = &t
}

// InterviewDate returns the value of the "interview_date" field in the mutation.
func (m *CandidateInterviewMutation) InterviewDate() (r time.Time, exists bool) {
	v := m.interview_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInterviewDate returns the old "interview_date" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldInterviewDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterviewDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterviewDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterviewDate: %w", err)
	}
	return oldValue.InterviewDate, nil
}

// ClearInterviewDate clears the value of the "interview_date" field.
func (m *CandidateInterviewMutation) ClearInterviewDate() {
	m.interview_date = nil
	m.clearedFields[candidateinterview.FieldInterviewDate] = struct{}{}
}

// InterviewDateCleared returns if the "interview_date" field was cleared in this mutation.
func (m *CandidateInterviewMutation) InterviewDateCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldInterviewDate]
	return ok
}

// ResetInterviewDate resets all changes to the "interview_date" field.
func (m *CandidateInterviewMutation) ResetInterviewDate() {
	m.interview_date = nil
	delete(m.clearedFields, candidateinterview.FieldInterviewDate)
}

// SetStartFrom sets the "start_from" field.
func (m *CandidateInterviewMutation) SetStartFrom(t time.Time) {
	m.start_from = &t
}

// StartFrom returns the value of the "start_from" field in the mutation.
func (m *CandidateInterviewMutation) StartFrom() (r time.Time, exists bool) {
	v := m.start_from
	if v == nil {
		return
	}
	return *v, true
}

// OldStartFrom returns the old "start_from" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldStartFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartFrom: %w", err)
	}
	return oldValue.StartFrom, nil
}

// ClearStartFrom clears the value of the "start_from" field.
func (m *CandidateInterviewMutation) ClearStartFrom() {
	m.start_from = nil
	m.clearedFields[candidateinterview.FieldStartFrom] = struct{}{}
}

// StartFromCleared returns if the "start_from" field was cleared in this mutation.
func (m *CandidateInterviewMutation) StartFromCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldStartFrom]
	return ok
}

// ResetStartFrom resets all changes to the "start_from" field.
func (m *CandidateInterviewMutation) ResetStartFrom() {
	m.start_from = nil
	delete(m.clearedFields, candidateinterview.FieldStartFrom)
}

// SetEndAt sets the "end_at" field.
func (m *CandidateInterviewMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *CandidateInterviewMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *CandidateInterviewMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[candidateinterview.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *CandidateInterviewMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *CandidateInterviewMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, candidateinterview.FieldEndAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *CandidateInterviewMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CandidateInterviewMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CandidateInterviewMutation) ClearCreatedBy() {
	m.created_by_edge = nil
	m.clearedFields[candidateinterview.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CandidateInterviewMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[candidateinterview.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CandidateInterviewMutation) ResetCreatedBy() {
	m.created_by_edge = nil
	delete(m.clearedFields, candidateinterview.FieldCreatedBy)
}

// SetDescription sets the "description" field.
func (m *CandidateInterviewMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CandidateInterviewMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CandidateInterviewMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *CandidateInterviewMutation) SetStatus(c candidateinterview.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CandidateInterviewMutation) Status() (r candidateinterview.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldStatus(ctx context.Context) (v candidateinterview.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CandidateInterviewMutation) ResetStatus() {
	m.status = nil
}

// SetLocation sets the "location" field.
func (m *CandidateInterviewMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *CandidateInterviewMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *CandidateInterviewMutation) ResetLocation() {
	m.location = nil
}

// SetMeetingLink sets the "meeting_link" field.
func (m *CandidateInterviewMutation) SetMeetingLink(s string) {
	m.meeting_link = &s
}

// MeetingLink returns the value of the "meeting_link" field in the mutation.
func (m *CandidateInterviewMutation) MeetingLink() (r string, exists bool) {
	v := m.meeting_link
	if v == nil {
		return
	}
	return *v, true
}

// OldMeetingLink returns the old "meeting_link" field's value of the CandidateInterview entity.
// If the CandidateInterview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewMutation) OldMeetingLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeetingLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeetingLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeetingLink: %w", err)
	}
	return oldValue.MeetingLink, nil
}

// ResetMeetingLink resets all changes to the "meeting_link" field.
func (m *CandidateInterviewMutation) ResetMeetingLink() {
	m.meeting_link = nil
}

// SetCandidateJobEdgeID sets the "candidate_job_edge" edge to the CandidateJob entity by id.
func (m *CandidateInterviewMutation) SetCandidateJobEdgeID(id uuid.UUID) {
	m.candidate_job_edge = &id
}

// ClearCandidateJobEdge clears the "candidate_job_edge" edge to the CandidateJob entity.
func (m *CandidateInterviewMutation) ClearCandidateJobEdge() {
	m.clearedcandidate_job_edge = true
}

// CandidateJobEdgeCleared reports if the "candidate_job_edge" edge to the CandidateJob entity was cleared.
func (m *CandidateInterviewMutation) CandidateJobEdgeCleared() bool {
	return m.CandidateJobIDCleared() || m.clearedcandidate_job_edge
}

// CandidateJobEdgeID returns the "candidate_job_edge" edge ID in the mutation.
func (m *CandidateInterviewMutation) CandidateJobEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_edge != nil {
		return *m.candidate_job_edge, true
	}
	return
}

// CandidateJobEdgeIDs returns the "candidate_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewMutation) CandidateJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobEdge resets all changes to the "candidate_job_edge" edge.
func (m *CandidateInterviewMutation) ResetCandidateJobEdge() {
	m.candidate_job_edge = nil
	m.clearedcandidate_job_edge = false
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateInterviewMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateInterviewMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateInterviewMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateInterviewMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateInterviewMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateInterviewMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateInterviewMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// AddInterviewerEdgeIDs adds the "interviewer_edges" edge to the User entity by ids.
func (m *CandidateInterviewMutation) AddInterviewerEdgeIDs(ids ...uuid.UUID) {
	if m.interviewer_edges == nil {
		m.interviewer_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interviewer_edges[ids[i]] = struct{}{}
	}
}

// ClearInterviewerEdges clears the "interviewer_edges" edge to the User entity.
func (m *CandidateInterviewMutation) ClearInterviewerEdges() {
	m.clearedinterviewer_edges = true
}

// InterviewerEdgesCleared reports if the "interviewer_edges" edge to the User entity was cleared.
func (m *CandidateInterviewMutation) InterviewerEdgesCleared() bool {
	return m.clearedinterviewer_edges
}

// RemoveInterviewerEdgeIDs removes the "interviewer_edges" edge to the User entity by IDs.
func (m *CandidateInterviewMutation) RemoveInterviewerEdgeIDs(ids ...uuid.UUID) {
	if m.removedinterviewer_edges == nil {
		m.removedinterviewer_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interviewer_edges, ids[i])
		m.removedinterviewer_edges[ids[i]] = struct{}{}
	}
}

// RemovedInterviewerEdges returns the removed IDs of the "interviewer_edges" edge to the User entity.
func (m *CandidateInterviewMutation) RemovedInterviewerEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedinterviewer_edges {
		ids = append(ids, id)
	}
	return
}

// InterviewerEdgesIDs returns the "interviewer_edges" edge IDs in the mutation.
func (m *CandidateInterviewMutation) InterviewerEdgesIDs() (ids []uuid.UUID) {
	for id := range m.interviewer_edges {
		ids = append(ids, id)
	}
	return
}

// ResetInterviewerEdges resets all changes to the "interviewer_edges" edge.
func (m *CandidateInterviewMutation) ResetInterviewerEdges() {
	m.interviewer_edges = nil
	m.clearedinterviewer_edges = false
	m.removedinterviewer_edges = nil
}

// SetCreatedByEdgeID sets the "created_by_edge" edge to the User entity by id.
func (m *CandidateInterviewMutation) SetCreatedByEdgeID(id uuid.UUID) {
	m.created_by_edge = &id
}

// ClearCreatedByEdge clears the "created_by_edge" edge to the User entity.
func (m *CandidateInterviewMutation) ClearCreatedByEdge() {
	m.clearedcreated_by_edge = true
}

// CreatedByEdgeCleared reports if the "created_by_edge" edge to the User entity was cleared.
func (m *CandidateInterviewMutation) CreatedByEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_edge
}

// CreatedByEdgeID returns the "created_by_edge" edge ID in the mutation.
func (m *CandidateInterviewMutation) CreatedByEdgeID() (id uuid.UUID, exists bool) {
	if m.created_by_edge != nil {
		return *m.created_by_edge, true
	}
	return
}

// CreatedByEdgeIDs returns the "created_by_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewMutation) CreatedByEdgeIDs() (ids []uuid.UUID) {
	if id := m.created_by_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByEdge resets all changes to the "created_by_edge" edge.
func (m *CandidateInterviewMutation) ResetCreatedByEdge() {
	m.created_by_edge = nil
	m.clearedcreated_by_edge = false
}

// AddUserInterviewerIDs adds the "user_interviewers" edge to the CandidateInterviewer entity by ids.
func (m *CandidateInterviewMutation) AddUserInterviewerIDs(ids ...uuid.UUID) {
	if m.user_interviewers == nil {
		m.user_interviewers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_interviewers[ids[i]] = struct{}{}
	}
}

// ClearUserInterviewers clears the "user_interviewers" edge to the CandidateInterviewer entity.
func (m *CandidateInterviewMutation) ClearUserInterviewers() {
	m.cleareduser_interviewers = true
}

// UserInterviewersCleared reports if the "user_interviewers" edge to the CandidateInterviewer entity was cleared.
func (m *CandidateInterviewMutation) UserInterviewersCleared() bool {
	return m.cleareduser_interviewers
}

// RemoveUserInterviewerIDs removes the "user_interviewers" edge to the CandidateInterviewer entity by IDs.
func (m *CandidateInterviewMutation) RemoveUserInterviewerIDs(ids ...uuid.UUID) {
	if m.removeduser_interviewers == nil {
		m.removeduser_interviewers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_interviewers, ids[i])
		m.removeduser_interviewers[ids[i]] = struct{}{}
	}
}

// RemovedUserInterviewers returns the removed IDs of the "user_interviewers" edge to the CandidateInterviewer entity.
func (m *CandidateInterviewMutation) RemovedUserInterviewersIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_interviewers {
		ids = append(ids, id)
	}
	return
}

// UserInterviewersIDs returns the "user_interviewers" edge IDs in the mutation.
func (m *CandidateInterviewMutation) UserInterviewersIDs() (ids []uuid.UUID) {
	for id := range m.user_interviewers {
		ids = append(ids, id)
	}
	return
}

// ResetUserInterviewers resets all changes to the "user_interviewers" edge.
func (m *CandidateInterviewMutation) ResetUserInterviewers() {
	m.user_interviewers = nil
	m.cleareduser_interviewers = false
	m.removeduser_interviewers = nil
}

// Where appends a list predicates to the CandidateInterviewMutation builder.
func (m *CandidateInterviewMutation) Where(ps ...predicate.CandidateInterview) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateInterviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateInterview).
func (m *CandidateInterviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateInterviewMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, candidateinterview.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidateinterview.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidateinterview.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, candidateinterview.FieldTitle)
	}
	if m.candidate_job_status != nil {
		fields = append(fields, candidateinterview.FieldCandidateJobStatus)
	}
	if m.candidate_job_edge != nil {
		fields = append(fields, candidateinterview.FieldCandidateJobID)
	}
	if m.interview_date != nil {
		fields = append(fields, candidateinterview.FieldInterviewDate)
	}
	if m.start_from != nil {
		fields = append(fields, candidateinterview.FieldStartFrom)
	}
	if m.end_at != nil {
		fields = append(fields, candidateinterview.FieldEndAt)
	}
	if m.created_by_edge != nil {
		fields = append(fields, candidateinterview.FieldCreatedBy)
	}
	if m.description != nil {
		fields = append(fields, candidateinterview.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, candidateinterview.FieldStatus)
	}
	if m.location != nil {
		fields = append(fields, candidateinterview.FieldLocation)
	}
	if m.meeting_link != nil {
		fields = append(fields, candidateinterview.FieldMeetingLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateInterviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidateinterview.FieldCreatedAt:
		return m.CreatedAt()
	case candidateinterview.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidateinterview.FieldDeletedAt:
		return m.DeletedAt()
	case candidateinterview.FieldTitle:
		return m.Title()
	case candidateinterview.FieldCandidateJobStatus:
		return m.CandidateJobStatus()
	case candidateinterview.FieldCandidateJobID:
		return m.CandidateJobID()
	case candidateinterview.FieldInterviewDate:
		return m.InterviewDate()
	case candidateinterview.FieldStartFrom:
		return m.StartFrom()
	case candidateinterview.FieldEndAt:
		return m.EndAt()
	case candidateinterview.FieldCreatedBy:
		return m.CreatedBy()
	case candidateinterview.FieldDescription:
		return m.Description()
	case candidateinterview.FieldStatus:
		return m.Status()
	case candidateinterview.FieldLocation:
		return m.Location()
	case candidateinterview.FieldMeetingLink:
		return m.MeetingLink()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateInterviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidateinterview.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidateinterview.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidateinterview.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidateinterview.FieldTitle:
		return m.OldTitle(ctx)
	case candidateinterview.FieldCandidateJobStatus:
		return m.OldCandidateJobStatus(ctx)
	case candidateinterview.FieldCandidateJobID:
		return m.OldCandidateJobID(ctx)
	case candidateinterview.FieldInterviewDate:
		return m.OldInterviewDate(ctx)
	case candidateinterview.FieldStartFrom:
		return m.OldStartFrom(ctx)
	case candidateinterview.FieldEndAt:
		return m.OldEndAt(ctx)
	case candidateinterview.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case candidateinterview.FieldDescription:
		return m.OldDescription(ctx)
	case candidateinterview.FieldStatus:
		return m.OldStatus(ctx)
	case candidateinterview.FieldLocation:
		return m.OldLocation(ctx)
	case candidateinterview.FieldMeetingLink:
		return m.OldMeetingLink(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateInterview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidateinterview.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidateinterview.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidateinterview.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidateinterview.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case candidateinterview.FieldCandidateJobStatus:
		v, ok := value.(candidateinterview.CandidateJobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobStatus(v)
		return nil
	case candidateinterview.FieldCandidateJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobID(v)
		return nil
	case candidateinterview.FieldInterviewDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterviewDate(v)
		return nil
	case candidateinterview.FieldStartFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartFrom(v)
		return nil
	case candidateinterview.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case candidateinterview.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case candidateinterview.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case candidateinterview.FieldStatus:
		v, ok := value.(candidateinterview.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case candidateinterview.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case candidateinterview.FieldMeetingLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeetingLink(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateInterviewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateInterviewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateInterview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateInterviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidateinterview.FieldUpdatedAt) {
		fields = append(fields, candidateinterview.FieldUpdatedAt)
	}
	if m.FieldCleared(candidateinterview.FieldDeletedAt) {
		fields = append(fields, candidateinterview.FieldDeletedAt)
	}
	if m.FieldCleared(candidateinterview.FieldCandidateJobID) {
		fields = append(fields, candidateinterview.FieldCandidateJobID)
	}
	if m.FieldCleared(candidateinterview.FieldInterviewDate) {
		fields = append(fields, candidateinterview.FieldInterviewDate)
	}
	if m.FieldCleared(candidateinterview.FieldStartFrom) {
		fields = append(fields, candidateinterview.FieldStartFrom)
	}
	if m.FieldCleared(candidateinterview.FieldEndAt) {
		fields = append(fields, candidateinterview.FieldEndAt)
	}
	if m.FieldCleared(candidateinterview.FieldCreatedBy) {
		fields = append(fields, candidateinterview.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateInterviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateInterviewMutation) ClearField(name string) error {
	switch name {
	case candidateinterview.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidateinterview.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidateinterview.FieldCandidateJobID:
		m.ClearCandidateJobID()
		return nil
	case candidateinterview.FieldInterviewDate:
		m.ClearInterviewDate()
		return nil
	case candidateinterview.FieldStartFrom:
		m.ClearStartFrom()
		return nil
	case candidateinterview.FieldEndAt:
		m.ClearEndAt()
		return nil
	case candidateinterview.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateInterviewMutation) ResetField(name string) error {
	switch name {
	case candidateinterview.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidateinterview.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidateinterview.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidateinterview.FieldTitle:
		m.ResetTitle()
		return nil
	case candidateinterview.FieldCandidateJobStatus:
		m.ResetCandidateJobStatus()
		return nil
	case candidateinterview.FieldCandidateJobID:
		m.ResetCandidateJobID()
		return nil
	case candidateinterview.FieldInterviewDate:
		m.ResetInterviewDate()
		return nil
	case candidateinterview.FieldStartFrom:
		m.ResetStartFrom()
		return nil
	case candidateinterview.FieldEndAt:
		m.ResetEndAt()
		return nil
	case candidateinterview.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case candidateinterview.FieldDescription:
		m.ResetDescription()
		return nil
	case candidateinterview.FieldStatus:
		m.ResetStatus()
		return nil
	case candidateinterview.FieldLocation:
		m.ResetLocation()
		return nil
	case candidateinterview.FieldMeetingLink:
		m.ResetMeetingLink()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateInterviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.candidate_job_edge != nil {
		edges = append(edges, candidateinterview.EdgeCandidateJobEdge)
	}
	if m.attachment_edges != nil {
		edges = append(edges, candidateinterview.EdgeAttachmentEdges)
	}
	if m.interviewer_edges != nil {
		edges = append(edges, candidateinterview.EdgeInterviewerEdges)
	}
	if m.created_by_edge != nil {
		edges = append(edges, candidateinterview.EdgeCreatedByEdge)
	}
	if m.user_interviewers != nil {
		edges = append(edges, candidateinterview.EdgeUserInterviewers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateInterviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		if id := m.candidate_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidateinterview.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeInterviewerEdges:
		ids := make([]ent.Value, 0, len(m.interviewer_edges))
		for id := range m.interviewer_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeCreatedByEdge:
		if id := m.created_by_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidateinterview.EdgeUserInterviewers:
		ids := make([]ent.Value, 0, len(m.user_interviewers))
		for id := range m.user_interviewers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateInterviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedattachment_edges != nil {
		edges = append(edges, candidateinterview.EdgeAttachmentEdges)
	}
	if m.removedinterviewer_edges != nil {
		edges = append(edges, candidateinterview.EdgeInterviewerEdges)
	}
	if m.removeduser_interviewers != nil {
		edges = append(edges, candidateinterview.EdgeUserInterviewers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateInterviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidateinterview.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeInterviewerEdges:
		ids := make([]ent.Value, 0, len(m.removedinterviewer_edges))
		for id := range m.removedinterviewer_edges {
			ids = append(ids, id)
		}
		return ids
	case candidateinterview.EdgeUserInterviewers:
		ids := make([]ent.Value, 0, len(m.removeduser_interviewers))
		for id := range m.removeduser_interviewers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateInterviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcandidate_job_edge {
		edges = append(edges, candidateinterview.EdgeCandidateJobEdge)
	}
	if m.clearedattachment_edges {
		edges = append(edges, candidateinterview.EdgeAttachmentEdges)
	}
	if m.clearedinterviewer_edges {
		edges = append(edges, candidateinterview.EdgeInterviewerEdges)
	}
	if m.clearedcreated_by_edge {
		edges = append(edges, candidateinterview.EdgeCreatedByEdge)
	}
	if m.cleareduser_interviewers {
		edges = append(edges, candidateinterview.EdgeUserInterviewers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateInterviewMutation) EdgeCleared(name string) bool {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		return m.clearedcandidate_job_edge
	case candidateinterview.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	case candidateinterview.EdgeInterviewerEdges:
		return m.clearedinterviewer_edges
	case candidateinterview.EdgeCreatedByEdge:
		return m.clearedcreated_by_edge
	case candidateinterview.EdgeUserInterviewers:
		return m.cleareduser_interviewers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateInterviewMutation) ClearEdge(name string) error {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		m.ClearCandidateJobEdge()
		return nil
	case candidateinterview.EdgeCreatedByEdge:
		m.ClearCreatedByEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateInterviewMutation) ResetEdge(name string) error {
	switch name {
	case candidateinterview.EdgeCandidateJobEdge:
		m.ResetCandidateJobEdge()
		return nil
	case candidateinterview.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	case candidateinterview.EdgeInterviewerEdges:
		m.ResetInterviewerEdges()
		return nil
	case candidateinterview.EdgeCreatedByEdge:
		m.ResetCreatedByEdge()
		return nil
	case candidateinterview.EdgeUserInterviewers:
		m.ResetUserInterviewers()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterview edge %s", name)
}

// CandidateInterviewerMutation represents an operation that mutates the CandidateInterviewer nodes in the graph.
type CandidateInterviewerMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	user_edge             *uuid.UUID
	cleareduser_edge      bool
	interview_edge        *uuid.UUID
	clearedinterview_edge bool
	done                  bool
	oldValue              func(context.Context) (*CandidateInterviewer, error)
	predicates            []predicate.CandidateInterviewer
}

var _ ent.Mutation = (*CandidateInterviewerMutation)(nil)

// candidateinterviewerOption allows management of the mutation configuration using functional options.
type candidateinterviewerOption func(*CandidateInterviewerMutation)

// newCandidateInterviewerMutation creates new mutation for the CandidateInterviewer entity.
func newCandidateInterviewerMutation(c config, op Op, opts ...candidateinterviewerOption) *CandidateInterviewerMutation {
	m := &CandidateInterviewerMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateInterviewer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateInterviewerID sets the ID field of the mutation.
func withCandidateInterviewerID(id uuid.UUID) candidateinterviewerOption {
	return func(m *CandidateInterviewerMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateInterviewer
		)
		m.oldValue = func(ctx context.Context) (*CandidateInterviewer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateInterviewer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateInterviewer sets the old CandidateInterviewer of the mutation.
func withCandidateInterviewer(node *CandidateInterviewer) candidateinterviewerOption {
	return func(m *CandidateInterviewerMutation) {
		m.oldValue = func(context.Context) (*CandidateInterviewer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateInterviewerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateInterviewerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateInterviewer entities.
func (m *CandidateInterviewerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateInterviewerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateInterviewerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateInterviewer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateInterviewerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateInterviewerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateInterviewerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateInterviewerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateInterviewerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateInterviewerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidateinterviewer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateInterviewerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterviewer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateInterviewerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidateinterviewer.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateInterviewerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateInterviewerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateInterviewerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidateinterviewer.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateInterviewerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidateinterviewer.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateInterviewerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidateinterviewer.FieldDeletedAt)
}

// SetCandidateInterviewID sets the "candidate_interview_id" field.
func (m *CandidateInterviewerMutation) SetCandidateInterviewID(u uuid.UUID) {
	m.interview_edge = &u
}

// CandidateInterviewID returns the value of the "candidate_interview_id" field in the mutation.
func (m *CandidateInterviewerMutation) CandidateInterviewID() (r uuid.UUID, exists bool) {
	v := m.interview_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateInterviewID returns the old "candidate_interview_id" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldCandidateInterviewID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateInterviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateInterviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateInterviewID: %w", err)
	}
	return oldValue.CandidateInterviewID, nil
}

// ResetCandidateInterviewID resets all changes to the "candidate_interview_id" field.
func (m *CandidateInterviewerMutation) ResetCandidateInterviewID() {
	m.interview_edge = nil
}

// SetUserID sets the "user_id" field.
func (m *CandidateInterviewerMutation) SetUserID(u uuid.UUID) {
	m.user_edge = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CandidateInterviewerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CandidateInterviewer entity.
// If the CandidateInterviewer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateInterviewerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CandidateInterviewerMutation) ResetUserID() {
	m.user_edge = nil
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *CandidateInterviewerMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *CandidateInterviewerMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *CandidateInterviewerMutation) UserEdgeCleared() bool {
	return m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *CandidateInterviewerMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewerMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *CandidateInterviewerMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetInterviewEdgeID sets the "interview_edge" edge to the CandidateInterview entity by id.
func (m *CandidateInterviewerMutation) SetInterviewEdgeID(id uuid.UUID) {
	m.interview_edge = &id
}

// ClearInterviewEdge clears the "interview_edge" edge to the CandidateInterview entity.
func (m *CandidateInterviewerMutation) ClearInterviewEdge() {
	m.clearedinterview_edge = true
}

// InterviewEdgeCleared reports if the "interview_edge" edge to the CandidateInterview entity was cleared.
func (m *CandidateInterviewerMutation) InterviewEdgeCleared() bool {
	return m.clearedinterview_edge
}

// InterviewEdgeID returns the "interview_edge" edge ID in the mutation.
func (m *CandidateInterviewerMutation) InterviewEdgeID() (id uuid.UUID, exists bool) {
	if m.interview_edge != nil {
		return *m.interview_edge, true
	}
	return
}

// InterviewEdgeIDs returns the "interview_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InterviewEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateInterviewerMutation) InterviewEdgeIDs() (ids []uuid.UUID) {
	if id := m.interview_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInterviewEdge resets all changes to the "interview_edge" edge.
func (m *CandidateInterviewerMutation) ResetInterviewEdge() {
	m.interview_edge = nil
	m.clearedinterview_edge = false
}

// Where appends a list predicates to the CandidateInterviewerMutation builder.
func (m *CandidateInterviewerMutation) Where(ps ...predicate.CandidateInterviewer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateInterviewerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateInterviewer).
func (m *CandidateInterviewerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateInterviewerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, candidateinterviewer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidateinterviewer.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidateinterviewer.FieldDeletedAt)
	}
	if m.interview_edge != nil {
		fields = append(fields, candidateinterviewer.FieldCandidateInterviewID)
	}
	if m.user_edge != nil {
		fields = append(fields, candidateinterviewer.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateInterviewerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		return m.CreatedAt()
	case candidateinterviewer.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidateinterviewer.FieldDeletedAt:
		return m.DeletedAt()
	case candidateinterviewer.FieldCandidateInterviewID:
		return m.CandidateInterviewID()
	case candidateinterviewer.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateInterviewerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidateinterviewer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidateinterviewer.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidateinterviewer.FieldCandidateInterviewID:
		return m.OldCandidateInterviewID(ctx)
	case candidateinterviewer.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateInterviewer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidateinterviewer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidateinterviewer.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidateinterviewer.FieldCandidateInterviewID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateInterviewID(v)
		return nil
	case candidateinterviewer.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateInterviewerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateInterviewerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateInterviewerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateInterviewer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateInterviewerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidateinterviewer.FieldUpdatedAt) {
		fields = append(fields, candidateinterviewer.FieldUpdatedAt)
	}
	if m.FieldCleared(candidateinterviewer.FieldDeletedAt) {
		fields = append(fields, candidateinterviewer.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateInterviewerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateInterviewerMutation) ClearField(name string) error {
	switch name {
	case candidateinterviewer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidateinterviewer.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateInterviewerMutation) ResetField(name string) error {
	switch name {
	case candidateinterviewer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidateinterviewer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidateinterviewer.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidateinterviewer.FieldCandidateInterviewID:
		m.ResetCandidateInterviewID()
		return nil
	case candidateinterviewer.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateInterviewerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_edge != nil {
		edges = append(edges, candidateinterviewer.EdgeUserEdge)
	}
	if m.interview_edge != nil {
		edges = append(edges, candidateinterviewer.EdgeInterviewEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateInterviewerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidateinterviewer.EdgeInterviewEdge:
		if id := m.interview_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateInterviewerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateInterviewerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateInterviewerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_edge {
		edges = append(edges, candidateinterviewer.EdgeUserEdge)
	}
	if m.clearedinterview_edge {
		edges = append(edges, candidateinterviewer.EdgeInterviewEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateInterviewerMutation) EdgeCleared(name string) bool {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		return m.cleareduser_edge
	case candidateinterviewer.EdgeInterviewEdge:
		return m.clearedinterview_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateInterviewerMutation) ClearEdge(name string) error {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case candidateinterviewer.EdgeInterviewEdge:
		m.ClearInterviewEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateInterviewerMutation) ResetEdge(name string) error {
	switch name {
	case candidateinterviewer.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case candidateinterviewer.EdgeInterviewEdge:
		m.ResetInterviewEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateInterviewer edge %s", name)
}

// CandidateJobMutation represents an operation that mutates the CandidateJob nodes in the graph.
type CandidateJobMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	created_at                     *time.Time
	updated_at                     *time.Time
	deleted_at                     *time.Time
	status                         *candidatejob.Status
	failed_reason                  *[]string
	appendfailed_reason            []string
	onboard_date                   *time.Time
	offer_expiration_date          *time.Time
	clearedFields                  map[string]struct{}
	attachment_edges               map[uuid.UUID]struct{}
	removedattachment_edges        map[uuid.UUID]struct{}
	clearedattachment_edges        bool
	hiring_job_edge                *uuid.UUID
	clearedhiring_job_edge         bool
	candidate_job_feedback         map[uuid.UUID]struct{}
	removedcandidate_job_feedback  map[uuid.UUID]struct{}
	clearedcandidate_job_feedback  bool
	candidate_edge                 *uuid.UUID
	clearedcandidate_edge          bool
	candidate_job_interview        map[uuid.UUID]struct{}
	removedcandidate_job_interview map[uuid.UUID]struct{}
	clearedcandidate_job_interview bool
	created_by_edge                *uuid.UUID
	clearedcreated_by_edge         bool
	candidate_job_step             map[uuid.UUID]struct{}
	removedcandidate_job_step      map[uuid.UUID]struct{}
	clearedcandidate_job_step      bool
	done                           bool
	oldValue                       func(context.Context) (*CandidateJob, error)
	predicates                     []predicate.CandidateJob
}

var _ ent.Mutation = (*CandidateJobMutation)(nil)

// candidatejobOption allows management of the mutation configuration using functional options.
type candidatejobOption func(*CandidateJobMutation)

// newCandidateJobMutation creates new mutation for the CandidateJob entity.
func newCandidateJobMutation(c config, op Op, opts ...candidatejobOption) *CandidateJobMutation {
	m := &CandidateJobMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateJobID sets the ID field of the mutation.
func withCandidateJobID(id uuid.UUID) candidatejobOption {
	return func(m *CandidateJobMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateJob
		)
		m.oldValue = func(ctx context.Context) (*CandidateJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateJob sets the old CandidateJob of the mutation.
func withCandidateJob(node *CandidateJob) candidatejobOption {
	return func(m *CandidateJobMutation) {
		m.oldValue = func(context.Context) (*CandidateJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateJob entities.
func (m *CandidateJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateJobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidatejob.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateJobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidatejob.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidatejob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidatejob.FieldDeletedAt)
}

// SetHiringJobID sets the "hiring_job_id" field.
func (m *CandidateJobMutation) SetHiringJobID(u uuid.UUID) {
	m.hiring_job_edge = &u
}

// HiringJobID returns the value of the "hiring_job_id" field in the mutation.
func (m *CandidateJobMutation) HiringJobID() (r uuid.UUID, exists bool) {
	v := m.hiring_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldHiringJobID returns the old "hiring_job_id" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldHiringJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHiringJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHiringJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiringJobID: %w", err)
	}
	return oldValue.HiringJobID, nil
}

// ClearHiringJobID clears the value of the "hiring_job_id" field.
func (m *CandidateJobMutation) ClearHiringJobID() {
	m.hiring_job_edge = nil
	m.clearedFields[candidatejob.FieldHiringJobID] = struct{}{}
}

// HiringJobIDCleared returns if the "hiring_job_id" field was cleared in this mutation.
func (m *CandidateJobMutation) HiringJobIDCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldHiringJobID]
	return ok
}

// ResetHiringJobID resets all changes to the "hiring_job_id" field.
func (m *CandidateJobMutation) ResetHiringJobID() {
	m.hiring_job_edge = nil
	delete(m.clearedFields, candidatejob.FieldHiringJobID)
}

// SetCandidateID sets the "candidate_id" field.
func (m *CandidateJobMutation) SetCandidateID(u uuid.UUID) {
	m.candidate_edge = &u
}

// CandidateID returns the value of the "candidate_id" field in the mutation.
func (m *CandidateJobMutation) CandidateID() (r uuid.UUID, exists bool) {
	v := m.candidate_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateID returns the old "candidate_id" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCandidateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateID: %w", err)
	}
	return oldValue.CandidateID, nil
}

// ClearCandidateID clears the value of the "candidate_id" field.
func (m *CandidateJobMutation) ClearCandidateID() {
	m.candidate_edge = nil
	m.clearedFields[candidatejob.FieldCandidateID] = struct{}{}
}

// CandidateIDCleared returns if the "candidate_id" field was cleared in this mutation.
func (m *CandidateJobMutation) CandidateIDCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldCandidateID]
	return ok
}

// ResetCandidateID resets all changes to the "candidate_id" field.
func (m *CandidateJobMutation) ResetCandidateID() {
	m.candidate_edge = nil
	delete(m.clearedFields, candidatejob.FieldCandidateID)
}

// SetCreatedBy sets the "created_by" field.
func (m *CandidateJobMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CandidateJobMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CandidateJobMutation) ClearCreatedBy() {
	m.created_by_edge = nil
	m.clearedFields[candidatejob.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CandidateJobMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CandidateJobMutation) ResetCreatedBy() {
	m.created_by_edge = nil
	delete(m.clearedFields, candidatejob.FieldCreatedBy)
}

// SetStatus sets the "status" field.
func (m *CandidateJobMutation) SetStatus(c candidatejob.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CandidateJobMutation) Status() (r candidatejob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldStatus(ctx context.Context) (v candidatejob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CandidateJobMutation) ResetStatus() {
	m.status = nil
}

// SetFailedReason sets the "failed_reason" field.
func (m *CandidateJobMutation) SetFailedReason(s []string) {
	m.failed_reason = &s
	m.appendfailed_reason = nil
}

// FailedReason returns the value of the "failed_reason" field in the mutation.
func (m *CandidateJobMutation) FailedReason() (r []string, exists bool) {
	v := m.failed_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailedReason returns the old "failed_reason" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldFailedReason(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailedReason: %w", err)
	}
	return oldValue.FailedReason, nil
}

// AppendFailedReason adds s to the "failed_reason" field.
func (m *CandidateJobMutation) AppendFailedReason(s []string) {
	m.appendfailed_reason = append(m.appendfailed_reason, s...)
}

// AppendedFailedReason returns the list of values that were appended to the "failed_reason" field in this mutation.
func (m *CandidateJobMutation) AppendedFailedReason() ([]string, bool) {
	if len(m.appendfailed_reason) == 0 {
		return nil, false
	}
	return m.appendfailed_reason, true
}

// ClearFailedReason clears the value of the "failed_reason" field.
func (m *CandidateJobMutation) ClearFailedReason() {
	m.failed_reason = nil
	m.appendfailed_reason = nil
	m.clearedFields[candidatejob.FieldFailedReason] = struct{}{}
}

// FailedReasonCleared returns if the "failed_reason" field was cleared in this mutation.
func (m *CandidateJobMutation) FailedReasonCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldFailedReason]
	return ok
}

// ResetFailedReason resets all changes to the "failed_reason" field.
func (m *CandidateJobMutation) ResetFailedReason() {
	m.failed_reason = nil
	m.appendfailed_reason = nil
	delete(m.clearedFields, candidatejob.FieldFailedReason)
}

// SetOnboardDate sets the "onboard_date" field.
func (m *CandidateJobMutation) SetOnboardDate(t time.Time) {
	m.onboard_date = &t
}

// OnboardDate returns the value of the "onboard_date" field in the mutation.
func (m *CandidateJobMutation) OnboardDate() (r time.Time, exists bool) {
	v := m.onboard_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardDate returns the old "onboard_date" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldOnboardDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardDate: %w", err)
	}
	return oldValue.OnboardDate, nil
}

// ClearOnboardDate clears the value of the "onboard_date" field.
func (m *CandidateJobMutation) ClearOnboardDate() {
	m.onboard_date = nil
	m.clearedFields[candidatejob.FieldOnboardDate] = struct{}{}
}

// OnboardDateCleared returns if the "onboard_date" field was cleared in this mutation.
func (m *CandidateJobMutation) OnboardDateCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldOnboardDate]
	return ok
}

// ResetOnboardDate resets all changes to the "onboard_date" field.
func (m *CandidateJobMutation) ResetOnboardDate() {
	m.onboard_date = nil
	delete(m.clearedFields, candidatejob.FieldOnboardDate)
}

// SetOfferExpirationDate sets the "offer_expiration_date" field.
func (m *CandidateJobMutation) SetOfferExpirationDate(t time.Time) {
	m.offer_expiration_date = &t
}

// OfferExpirationDate returns the value of the "offer_expiration_date" field in the mutation.
func (m *CandidateJobMutation) OfferExpirationDate() (r time.Time, exists bool) {
	v := m.offer_expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOfferExpirationDate returns the old "offer_expiration_date" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldOfferExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfferExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfferExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfferExpirationDate: %w", err)
	}
	return oldValue.OfferExpirationDate, nil
}

// ClearOfferExpirationDate clears the value of the "offer_expiration_date" field.
func (m *CandidateJobMutation) ClearOfferExpirationDate() {
	m.offer_expiration_date = nil
	m.clearedFields[candidatejob.FieldOfferExpirationDate] = struct{}{}
}

// OfferExpirationDateCleared returns if the "offer_expiration_date" field was cleared in this mutation.
func (m *CandidateJobMutation) OfferExpirationDateCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldOfferExpirationDate]
	return ok
}

// ResetOfferExpirationDate resets all changes to the "offer_expiration_date" field.
func (m *CandidateJobMutation) ResetOfferExpirationDate() {
	m.offer_expiration_date = nil
	delete(m.clearedFields, candidatejob.FieldOfferExpirationDate)
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateJobMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateJobMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateJobMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateJobMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateJobMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// SetHiringJobEdgeID sets the "hiring_job_edge" edge to the HiringJob entity by id.
func (m *CandidateJobMutation) SetHiringJobEdgeID(id uuid.UUID) {
	m.hiring_job_edge = &id
}

// ClearHiringJobEdge clears the "hiring_job_edge" edge to the HiringJob entity.
func (m *CandidateJobMutation) ClearHiringJobEdge() {
	m.clearedhiring_job_edge = true
}

// HiringJobEdgeCleared reports if the "hiring_job_edge" edge to the HiringJob entity was cleared.
func (m *CandidateJobMutation) HiringJobEdgeCleared() bool {
	return m.HiringJobIDCleared() || m.clearedhiring_job_edge
}

// HiringJobEdgeID returns the "hiring_job_edge" edge ID in the mutation.
func (m *CandidateJobMutation) HiringJobEdgeID() (id uuid.UUID, exists bool) {
	if m.hiring_job_edge != nil {
		return *m.hiring_job_edge, true
	}
	return
}

// HiringJobEdgeIDs returns the "hiring_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HiringJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobMutation) HiringJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.hiring_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHiringJobEdge resets all changes to the "hiring_job_edge" edge.
func (m *CandidateJobMutation) ResetHiringJobEdge() {
	m.hiring_job_edge = nil
	m.clearedhiring_job_edge = false
}

// AddCandidateJobFeedbackIDs adds the "candidate_job_feedback" edge to the CandidateJobFeedback entity by ids.
func (m *CandidateJobMutation) AddCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.candidate_job_feedback == nil {
		m.candidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_feedback[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobFeedback clears the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *CandidateJobMutation) ClearCandidateJobFeedback() {
	m.clearedcandidate_job_feedback = true
}

// CandidateJobFeedbackCleared reports if the "candidate_job_feedback" edge to the CandidateJobFeedback entity was cleared.
func (m *CandidateJobMutation) CandidateJobFeedbackCleared() bool {
	return m.clearedcandidate_job_feedback
}

// RemoveCandidateJobFeedbackIDs removes the "candidate_job_feedback" edge to the CandidateJobFeedback entity by IDs.
func (m *CandidateJobMutation) RemoveCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_feedback == nil {
		m.removedcandidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_feedback, ids[i])
		m.removedcandidate_job_feedback[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobFeedback returns the removed IDs of the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *CandidateJobMutation) RemovedCandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// CandidateJobFeedbackIDs returns the "candidate_job_feedback" edge IDs in the mutation.
func (m *CandidateJobMutation) CandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobFeedback resets all changes to the "candidate_job_feedback" edge.
func (m *CandidateJobMutation) ResetCandidateJobFeedback() {
	m.candidate_job_feedback = nil
	m.clearedcandidate_job_feedback = false
	m.removedcandidate_job_feedback = nil
}

// SetCandidateEdgeID sets the "candidate_edge" edge to the Candidate entity by id.
func (m *CandidateJobMutation) SetCandidateEdgeID(id uuid.UUID) {
	m.candidate_edge = &id
}

// ClearCandidateEdge clears the "candidate_edge" edge to the Candidate entity.
func (m *CandidateJobMutation) ClearCandidateEdge() {
	m.clearedcandidate_edge = true
}

// CandidateEdgeCleared reports if the "candidate_edge" edge to the Candidate entity was cleared.
func (m *CandidateJobMutation) CandidateEdgeCleared() bool {
	return m.CandidateIDCleared() || m.clearedcandidate_edge
}

// CandidateEdgeID returns the "candidate_edge" edge ID in the mutation.
func (m *CandidateJobMutation) CandidateEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_edge != nil {
		return *m.candidate_edge, true
	}
	return
}

// CandidateEdgeIDs returns the "candidate_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobMutation) CandidateEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateEdge resets all changes to the "candidate_edge" edge.
func (m *CandidateJobMutation) ResetCandidateEdge() {
	m.candidate_edge = nil
	m.clearedcandidate_edge = false
}

// AddCandidateJobInterviewIDs adds the "candidate_job_interview" edge to the CandidateInterview entity by ids.
func (m *CandidateJobMutation) AddCandidateJobInterviewIDs(ids ...uuid.UUID) {
	if m.candidate_job_interview == nil {
		m.candidate_job_interview = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_interview[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobInterview clears the "candidate_job_interview" edge to the CandidateInterview entity.
func (m *CandidateJobMutation) ClearCandidateJobInterview() {
	m.clearedcandidate_job_interview = true
}

// CandidateJobInterviewCleared reports if the "candidate_job_interview" edge to the CandidateInterview entity was cleared.
func (m *CandidateJobMutation) CandidateJobInterviewCleared() bool {
	return m.clearedcandidate_job_interview
}

// RemoveCandidateJobInterviewIDs removes the "candidate_job_interview" edge to the CandidateInterview entity by IDs.
func (m *CandidateJobMutation) RemoveCandidateJobInterviewIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_interview == nil {
		m.removedcandidate_job_interview = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_interview, ids[i])
		m.removedcandidate_job_interview[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobInterview returns the removed IDs of the "candidate_job_interview" edge to the CandidateInterview entity.
func (m *CandidateJobMutation) RemovedCandidateJobInterviewIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_interview {
		ids = append(ids, id)
	}
	return
}

// CandidateJobInterviewIDs returns the "candidate_job_interview" edge IDs in the mutation.
func (m *CandidateJobMutation) CandidateJobInterviewIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_interview {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobInterview resets all changes to the "candidate_job_interview" edge.
func (m *CandidateJobMutation) ResetCandidateJobInterview() {
	m.candidate_job_interview = nil
	m.clearedcandidate_job_interview = false
	m.removedcandidate_job_interview = nil
}

// SetCreatedByEdgeID sets the "created_by_edge" edge to the User entity by id.
func (m *CandidateJobMutation) SetCreatedByEdgeID(id uuid.UUID) {
	m.created_by_edge = &id
}

// ClearCreatedByEdge clears the "created_by_edge" edge to the User entity.
func (m *CandidateJobMutation) ClearCreatedByEdge() {
	m.clearedcreated_by_edge = true
}

// CreatedByEdgeCleared reports if the "created_by_edge" edge to the User entity was cleared.
func (m *CandidateJobMutation) CreatedByEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_edge
}

// CreatedByEdgeID returns the "created_by_edge" edge ID in the mutation.
func (m *CandidateJobMutation) CreatedByEdgeID() (id uuid.UUID, exists bool) {
	if m.created_by_edge != nil {
		return *m.created_by_edge, true
	}
	return
}

// CreatedByEdgeIDs returns the "created_by_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobMutation) CreatedByEdgeIDs() (ids []uuid.UUID) {
	if id := m.created_by_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByEdge resets all changes to the "created_by_edge" edge.
func (m *CandidateJobMutation) ResetCreatedByEdge() {
	m.created_by_edge = nil
	m.clearedcreated_by_edge = false
}

// AddCandidateJobStepIDs adds the "candidate_job_step" edge to the CandidateJobStep entity by ids.
func (m *CandidateJobMutation) AddCandidateJobStepIDs(ids ...uuid.UUID) {
	if m.candidate_job_step == nil {
		m.candidate_job_step = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_step[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobStep clears the "candidate_job_step" edge to the CandidateJobStep entity.
func (m *CandidateJobMutation) ClearCandidateJobStep() {
	m.clearedcandidate_job_step = true
}

// CandidateJobStepCleared reports if the "candidate_job_step" edge to the CandidateJobStep entity was cleared.
func (m *CandidateJobMutation) CandidateJobStepCleared() bool {
	return m.clearedcandidate_job_step
}

// RemoveCandidateJobStepIDs removes the "candidate_job_step" edge to the CandidateJobStep entity by IDs.
func (m *CandidateJobMutation) RemoveCandidateJobStepIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_step == nil {
		m.removedcandidate_job_step = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_step, ids[i])
		m.removedcandidate_job_step[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobStep returns the removed IDs of the "candidate_job_step" edge to the CandidateJobStep entity.
func (m *CandidateJobMutation) RemovedCandidateJobStepIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_step {
		ids = append(ids, id)
	}
	return
}

// CandidateJobStepIDs returns the "candidate_job_step" edge IDs in the mutation.
func (m *CandidateJobMutation) CandidateJobStepIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_step {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobStep resets all changes to the "candidate_job_step" edge.
func (m *CandidateJobMutation) ResetCandidateJobStep() {
	m.candidate_job_step = nil
	m.clearedcandidate_job_step = false
	m.removedcandidate_job_step = nil
}

// Where appends a list predicates to the CandidateJobMutation builder.
func (m *CandidateJobMutation) Where(ps ...predicate.CandidateJob) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateJob).
func (m *CandidateJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateJobMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, candidatejob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidatejob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidatejob.FieldDeletedAt)
	}
	if m.hiring_job_edge != nil {
		fields = append(fields, candidatejob.FieldHiringJobID)
	}
	if m.candidate_edge != nil {
		fields = append(fields, candidatejob.FieldCandidateID)
	}
	if m.created_by_edge != nil {
		fields = append(fields, candidatejob.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, candidatejob.FieldStatus)
	}
	if m.failed_reason != nil {
		fields = append(fields, candidatejob.FieldFailedReason)
	}
	if m.onboard_date != nil {
		fields = append(fields, candidatejob.FieldOnboardDate)
	}
	if m.offer_expiration_date != nil {
		fields = append(fields, candidatejob.FieldOfferExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidatejob.FieldCreatedAt:
		return m.CreatedAt()
	case candidatejob.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidatejob.FieldDeletedAt:
		return m.DeletedAt()
	case candidatejob.FieldHiringJobID:
		return m.HiringJobID()
	case candidatejob.FieldCandidateID:
		return m.CandidateID()
	case candidatejob.FieldCreatedBy:
		return m.CreatedBy()
	case candidatejob.FieldStatus:
		return m.Status()
	case candidatejob.FieldFailedReason:
		return m.FailedReason()
	case candidatejob.FieldOnboardDate:
		return m.OnboardDate()
	case candidatejob.FieldOfferExpirationDate:
		return m.OfferExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidatejob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidatejob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidatejob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidatejob.FieldHiringJobID:
		return m.OldHiringJobID(ctx)
	case candidatejob.FieldCandidateID:
		return m.OldCandidateID(ctx)
	case candidatejob.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case candidatejob.FieldStatus:
		return m.OldStatus(ctx)
	case candidatejob.FieldFailedReason:
		return m.OldFailedReason(ctx)
	case candidatejob.FieldOnboardDate:
		return m.OldOnboardDate(ctx)
	case candidatejob.FieldOfferExpirationDate:
		return m.OldOfferExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidatejob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidatejob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidatejob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidatejob.FieldHiringJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiringJobID(v)
		return nil
	case candidatejob.FieldCandidateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateID(v)
		return nil
	case candidatejob.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case candidatejob.FieldStatus:
		v, ok := value.(candidatejob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case candidatejob.FieldFailedReason:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailedReason(v)
		return nil
	case candidatejob.FieldOnboardDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardDate(v)
		return nil
	case candidatejob.FieldOfferExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfferExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidatejob.FieldUpdatedAt) {
		fields = append(fields, candidatejob.FieldUpdatedAt)
	}
	if m.FieldCleared(candidatejob.FieldDeletedAt) {
		fields = append(fields, candidatejob.FieldDeletedAt)
	}
	if m.FieldCleared(candidatejob.FieldHiringJobID) {
		fields = append(fields, candidatejob.FieldHiringJobID)
	}
	if m.FieldCleared(candidatejob.FieldCandidateID) {
		fields = append(fields, candidatejob.FieldCandidateID)
	}
	if m.FieldCleared(candidatejob.FieldCreatedBy) {
		fields = append(fields, candidatejob.FieldCreatedBy)
	}
	if m.FieldCleared(candidatejob.FieldFailedReason) {
		fields = append(fields, candidatejob.FieldFailedReason)
	}
	if m.FieldCleared(candidatejob.FieldOnboardDate) {
		fields = append(fields, candidatejob.FieldOnboardDate)
	}
	if m.FieldCleared(candidatejob.FieldOfferExpirationDate) {
		fields = append(fields, candidatejob.FieldOfferExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateJobMutation) ClearField(name string) error {
	switch name {
	case candidatejob.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidatejob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidatejob.FieldHiringJobID:
		m.ClearHiringJobID()
		return nil
	case candidatejob.FieldCandidateID:
		m.ClearCandidateID()
		return nil
	case candidatejob.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case candidatejob.FieldFailedReason:
		m.ClearFailedReason()
		return nil
	case candidatejob.FieldOnboardDate:
		m.ClearOnboardDate()
		return nil
	case candidatejob.FieldOfferExpirationDate:
		m.ClearOfferExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateJobMutation) ResetField(name string) error {
	switch name {
	case candidatejob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidatejob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidatejob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidatejob.FieldHiringJobID:
		m.ResetHiringJobID()
		return nil
	case candidatejob.FieldCandidateID:
		m.ResetCandidateID()
		return nil
	case candidatejob.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case candidatejob.FieldStatus:
		m.ResetStatus()
		return nil
	case candidatejob.FieldFailedReason:
		m.ResetFailedReason()
		return nil
	case candidatejob.FieldOnboardDate:
		m.ResetOnboardDate()
		return nil
	case candidatejob.FieldOfferExpirationDate:
		m.ResetOfferExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.attachment_edges != nil {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.hiring_job_edge != nil {
		edges = append(edges, candidatejob.EdgeHiringJobEdge)
	}
	if m.candidate_job_feedback != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobFeedback)
	}
	if m.candidate_edge != nil {
		edges = append(edges, candidatejob.EdgeCandidateEdge)
	}
	if m.candidate_job_interview != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobInterview)
	}
	if m.created_by_edge != nil {
		edges = append(edges, candidatejob.EdgeCreatedByEdge)
	}
	if m.candidate_job_step != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobStep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeHiringJobEdge:
		if id := m.hiring_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejob.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.candidate_job_feedback))
		for id := range m.candidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateEdge:
		if id := m.candidate_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejob.EdgeCandidateJobInterview:
		ids := make([]ent.Value, 0, len(m.candidate_job_interview))
		for id := range m.candidate_job_interview {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCreatedByEdge:
		if id := m.created_by_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejob.EdgeCandidateJobStep:
		ids := make([]ent.Value, 0, len(m.candidate_job_step))
		for id := range m.candidate_job_step {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedattachment_edges != nil {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.removedcandidate_job_feedback != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobFeedback)
	}
	if m.removedcandidate_job_interview != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobInterview)
	}
	if m.removedcandidate_job_step != nil {
		edges = append(edges, candidatejob.EdgeCandidateJobStep)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_feedback))
		for id := range m.removedcandidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateJobInterview:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_interview))
		for id := range m.removedcandidate_job_interview {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeCandidateJobStep:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_step))
		for id := range m.removedcandidate_job_step {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedattachment_edges {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.clearedhiring_job_edge {
		edges = append(edges, candidatejob.EdgeHiringJobEdge)
	}
	if m.clearedcandidate_job_feedback {
		edges = append(edges, candidatejob.EdgeCandidateJobFeedback)
	}
	if m.clearedcandidate_edge {
		edges = append(edges, candidatejob.EdgeCandidateEdge)
	}
	if m.clearedcandidate_job_interview {
		edges = append(edges, candidatejob.EdgeCandidateJobInterview)
	}
	if m.clearedcreated_by_edge {
		edges = append(edges, candidatejob.EdgeCreatedByEdge)
	}
	if m.clearedcandidate_job_step {
		edges = append(edges, candidatejob.EdgeCandidateJobStep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateJobMutation) EdgeCleared(name string) bool {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	case candidatejob.EdgeHiringJobEdge:
		return m.clearedhiring_job_edge
	case candidatejob.EdgeCandidateJobFeedback:
		return m.clearedcandidate_job_feedback
	case candidatejob.EdgeCandidateEdge:
		return m.clearedcandidate_edge
	case candidatejob.EdgeCandidateJobInterview:
		return m.clearedcandidate_job_interview
	case candidatejob.EdgeCreatedByEdge:
		return m.clearedcreated_by_edge
	case candidatejob.EdgeCandidateJobStep:
		return m.clearedcandidate_job_step
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateJobMutation) ClearEdge(name string) error {
	switch name {
	case candidatejob.EdgeHiringJobEdge:
		m.ClearHiringJobEdge()
		return nil
	case candidatejob.EdgeCandidateEdge:
		m.ClearCandidateEdge()
		return nil
	case candidatejob.EdgeCreatedByEdge:
		m.ClearCreatedByEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateJobMutation) ResetEdge(name string) error {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	case candidatejob.EdgeHiringJobEdge:
		m.ResetHiringJobEdge()
		return nil
	case candidatejob.EdgeCandidateJobFeedback:
		m.ResetCandidateJobFeedback()
		return nil
	case candidatejob.EdgeCandidateEdge:
		m.ResetCandidateEdge()
		return nil
	case candidatejob.EdgeCandidateJobInterview:
		m.ResetCandidateJobInterview()
		return nil
	case candidatejob.EdgeCreatedByEdge:
		m.ResetCreatedByEdge()
		return nil
	case candidatejob.EdgeCandidateJobStep:
		m.ResetCandidateJobStep()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob edge %s", name)
}

// CandidateJobFeedbackMutation represents an operation that mutates the CandidateJobFeedback nodes in the graph.
type CandidateJobFeedbackMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	candidate_job_status      *candidatejobfeedback.CandidateJobStatus
	feedback                  *string
	clearedFields             map[string]struct{}
	created_by_edge           *uuid.UUID
	clearedcreated_by_edge    bool
	candidate_job_edge        *uuid.UUID
	clearedcandidate_job_edge bool
	attachment_edges          map[uuid.UUID]struct{}
	removedattachment_edges   map[uuid.UUID]struct{}
	clearedattachment_edges   bool
	done                      bool
	oldValue                  func(context.Context) (*CandidateJobFeedback, error)
	predicates                []predicate.CandidateJobFeedback
}

var _ ent.Mutation = (*CandidateJobFeedbackMutation)(nil)

// candidatejobfeedbackOption allows management of the mutation configuration using functional options.
type candidatejobfeedbackOption func(*CandidateJobFeedbackMutation)

// newCandidateJobFeedbackMutation creates new mutation for the CandidateJobFeedback entity.
func newCandidateJobFeedbackMutation(c config, op Op, opts ...candidatejobfeedbackOption) *CandidateJobFeedbackMutation {
	m := &CandidateJobFeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateJobFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateJobFeedbackID sets the ID field of the mutation.
func withCandidateJobFeedbackID(id uuid.UUID) candidatejobfeedbackOption {
	return func(m *CandidateJobFeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateJobFeedback
		)
		m.oldValue = func(ctx context.Context) (*CandidateJobFeedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateJobFeedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateJobFeedback sets the old CandidateJobFeedback of the mutation.
func withCandidateJobFeedback(node *CandidateJobFeedback) candidatejobfeedbackOption {
	return func(m *CandidateJobFeedbackMutation) {
		m.oldValue = func(context.Context) (*CandidateJobFeedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateJobFeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateJobFeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateJobFeedback entities.
func (m *CandidateJobFeedbackMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateJobFeedbackMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateJobFeedbackMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateJobFeedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateJobFeedbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateJobFeedbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateJobFeedbackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateJobFeedbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateJobFeedbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateJobFeedbackMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidatejobfeedback.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateJobFeedbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidatejobfeedback.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateJobFeedbackMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateJobFeedbackMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateJobFeedbackMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidatejobfeedback.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateJobFeedbackMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidatejobfeedback.FieldDeletedAt)
}

// SetCandidateJobID sets the "candidate_job_id" field.
func (m *CandidateJobFeedbackMutation) SetCandidateJobID(u uuid.UUID) {
	m.candidate_job_edge = &u
}

// CandidateJobID returns the value of the "candidate_job_id" field in the mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobID returns the old "candidate_job_id" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCandidateJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobID: %w", err)
	}
	return oldValue.CandidateJobID, nil
}

// ClearCandidateJobID clears the value of the "candidate_job_id" field.
func (m *CandidateJobFeedbackMutation) ClearCandidateJobID() {
	m.candidate_job_edge = nil
	m.clearedFields[candidatejobfeedback.FieldCandidateJobID] = struct{}{}
}

// CandidateJobIDCleared returns if the "candidate_job_id" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobIDCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldCandidateJobID]
	return ok
}

// ResetCandidateJobID resets all changes to the "candidate_job_id" field.
func (m *CandidateJobFeedbackMutation) ResetCandidateJobID() {
	m.candidate_job_edge = nil
	delete(m.clearedFields, candidatejobfeedback.FieldCandidateJobID)
}

// SetCreatedBy sets the "created_by" field.
func (m *CandidateJobFeedbackMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CandidateJobFeedbackMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *CandidateJobFeedbackMutation) ClearCreatedBy() {
	m.created_by_edge = nil
	m.clearedFields[candidatejobfeedback.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[candidatejobfeedback.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CandidateJobFeedbackMutation) ResetCreatedBy() {
	m.created_by_edge = nil
	delete(m.clearedFields, candidatejobfeedback.FieldCreatedBy)
}

// SetCandidateJobStatus sets the "candidate_job_status" field.
func (m *CandidateJobFeedbackMutation) SetCandidateJobStatus(cjs candidatejobfeedback.CandidateJobStatus) {
	m.candidate_job_status = &cjs
}

// CandidateJobStatus returns the value of the "candidate_job_status" field in the mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobStatus() (r candidatejobfeedback.CandidateJobStatus, exists bool) {
	v := m.candidate_job_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobStatus returns the old "candidate_job_status" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldCandidateJobStatus(ctx context.Context) (v candidatejobfeedback.CandidateJobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobStatus: %w", err)
	}
	return oldValue.CandidateJobStatus, nil
}

// ResetCandidateJobStatus resets all changes to the "candidate_job_status" field.
func (m *CandidateJobFeedbackMutation) ResetCandidateJobStatus() {
	m.candidate_job_status = nil
}

// SetFeedback sets the "feedback" field.
func (m *CandidateJobFeedbackMutation) SetFeedback(s string) {
	m.feedback = &s
}

// Feedback returns the value of the "feedback" field in the mutation.
func (m *CandidateJobFeedbackMutation) Feedback() (r string, exists bool) {
	v := m.feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedback returns the old "feedback" field's value of the CandidateJobFeedback entity.
// If the CandidateJobFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobFeedbackMutation) OldFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedback: %w", err)
	}
	return oldValue.Feedback, nil
}

// ResetFeedback resets all changes to the "feedback" field.
func (m *CandidateJobFeedbackMutation) ResetFeedback() {
	m.feedback = nil
}

// SetCreatedByEdgeID sets the "created_by_edge" edge to the User entity by id.
func (m *CandidateJobFeedbackMutation) SetCreatedByEdgeID(id uuid.UUID) {
	m.created_by_edge = &id
}

// ClearCreatedByEdge clears the "created_by_edge" edge to the User entity.
func (m *CandidateJobFeedbackMutation) ClearCreatedByEdge() {
	m.clearedcreated_by_edge = true
}

// CreatedByEdgeCleared reports if the "created_by_edge" edge to the User entity was cleared.
func (m *CandidateJobFeedbackMutation) CreatedByEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_edge
}

// CreatedByEdgeID returns the "created_by_edge" edge ID in the mutation.
func (m *CandidateJobFeedbackMutation) CreatedByEdgeID() (id uuid.UUID, exists bool) {
	if m.created_by_edge != nil {
		return *m.created_by_edge, true
	}
	return
}

// CreatedByEdgeIDs returns the "created_by_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobFeedbackMutation) CreatedByEdgeIDs() (ids []uuid.UUID) {
	if id := m.created_by_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByEdge resets all changes to the "created_by_edge" edge.
func (m *CandidateJobFeedbackMutation) ResetCreatedByEdge() {
	m.created_by_edge = nil
	m.clearedcreated_by_edge = false
}

// SetCandidateJobEdgeID sets the "candidate_job_edge" edge to the CandidateJob entity by id.
func (m *CandidateJobFeedbackMutation) SetCandidateJobEdgeID(id uuid.UUID) {
	m.candidate_job_edge = &id
}

// ClearCandidateJobEdge clears the "candidate_job_edge" edge to the CandidateJob entity.
func (m *CandidateJobFeedbackMutation) ClearCandidateJobEdge() {
	m.clearedcandidate_job_edge = true
}

// CandidateJobEdgeCleared reports if the "candidate_job_edge" edge to the CandidateJob entity was cleared.
func (m *CandidateJobFeedbackMutation) CandidateJobEdgeCleared() bool {
	return m.CandidateJobIDCleared() || m.clearedcandidate_job_edge
}

// CandidateJobEdgeID returns the "candidate_job_edge" edge ID in the mutation.
func (m *CandidateJobFeedbackMutation) CandidateJobEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_edge != nil {
		return *m.candidate_job_edge, true
	}
	return
}

// CandidateJobEdgeIDs returns the "candidate_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobFeedbackMutation) CandidateJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobEdge resets all changes to the "candidate_job_edge" edge.
func (m *CandidateJobFeedbackMutation) ResetCandidateJobEdge() {
	m.candidate_job_edge = nil
	m.clearedcandidate_job_edge = false
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateJobFeedbackMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobFeedbackMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateJobFeedbackMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateJobFeedbackMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobFeedbackMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateJobFeedbackMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateJobFeedbackMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// Where appends a list predicates to the CandidateJobFeedbackMutation builder.
func (m *CandidateJobFeedbackMutation) Where(ps ...predicate.CandidateJobFeedback) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateJobFeedbackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateJobFeedback).
func (m *CandidateJobFeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateJobFeedbackMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, candidatejobfeedback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidatejobfeedback.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidatejobfeedback.FieldDeletedAt)
	}
	if m.candidate_job_edge != nil {
		fields = append(fields, candidatejobfeedback.FieldCandidateJobID)
	}
	if m.created_by_edge != nil {
		fields = append(fields, candidatejobfeedback.FieldCreatedBy)
	}
	if m.candidate_job_status != nil {
		fields = append(fields, candidatejobfeedback.FieldCandidateJobStatus)
	}
	if m.feedback != nil {
		fields = append(fields, candidatejobfeedback.FieldFeedback)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateJobFeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		return m.CreatedAt()
	case candidatejobfeedback.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidatejobfeedback.FieldDeletedAt:
		return m.DeletedAt()
	case candidatejobfeedback.FieldCandidateJobID:
		return m.CandidateJobID()
	case candidatejobfeedback.FieldCreatedBy:
		return m.CreatedBy()
	case candidatejobfeedback.FieldCandidateJobStatus:
		return m.CandidateJobStatus()
	case candidatejobfeedback.FieldFeedback:
		return m.Feedback()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateJobFeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidatejobfeedback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidatejobfeedback.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidatejobfeedback.FieldCandidateJobID:
		return m.OldCandidateJobID(ctx)
	case candidatejobfeedback.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case candidatejobfeedback.FieldCandidateJobStatus:
		return m.OldCandidateJobStatus(ctx)
	case candidatejobfeedback.FieldFeedback:
		return m.OldFeedback(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateJobFeedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobFeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidatejobfeedback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidatejobfeedback.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidatejobfeedback.FieldCandidateJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobID(v)
		return nil
	case candidatejobfeedback.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case candidatejobfeedback.FieldCandidateJobStatus:
		v, ok := value.(candidatejobfeedback.CandidateJobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobStatus(v)
		return nil
	case candidatejobfeedback.FieldFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedback(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateJobFeedbackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateJobFeedbackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobFeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateJobFeedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateJobFeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidatejobfeedback.FieldUpdatedAt) {
		fields = append(fields, candidatejobfeedback.FieldUpdatedAt)
	}
	if m.FieldCleared(candidatejobfeedback.FieldDeletedAt) {
		fields = append(fields, candidatejobfeedback.FieldDeletedAt)
	}
	if m.FieldCleared(candidatejobfeedback.FieldCandidateJobID) {
		fields = append(fields, candidatejobfeedback.FieldCandidateJobID)
	}
	if m.FieldCleared(candidatejobfeedback.FieldCreatedBy) {
		fields = append(fields, candidatejobfeedback.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateJobFeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ClearField(name string) error {
	switch name {
	case candidatejobfeedback.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidatejobfeedback.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidatejobfeedback.FieldCandidateJobID:
		m.ClearCandidateJobID()
		return nil
	case candidatejobfeedback.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ResetField(name string) error {
	switch name {
	case candidatejobfeedback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidatejobfeedback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidatejobfeedback.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidatejobfeedback.FieldCandidateJobID:
		m.ResetCandidateJobID()
		return nil
	case candidatejobfeedback.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case candidatejobfeedback.FieldCandidateJobStatus:
		m.ResetCandidateJobStatus()
		return nil
	case candidatejobfeedback.FieldFeedback:
		m.ResetFeedback()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateJobFeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.created_by_edge != nil {
		edges = append(edges, candidatejobfeedback.EdgeCreatedByEdge)
	}
	if m.candidate_job_edge != nil {
		edges = append(edges, candidatejobfeedback.EdgeCandidateJobEdge)
	}
	if m.attachment_edges != nil {
		edges = append(edges, candidatejobfeedback.EdgeAttachmentEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateJobFeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		if id := m.created_by_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejobfeedback.EdgeCandidateJobEdge:
		if id := m.candidate_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case candidatejobfeedback.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateJobFeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedattachment_edges != nil {
		edges = append(edges, candidatejobfeedback.EdgeAttachmentEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateJobFeedbackMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidatejobfeedback.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateJobFeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreated_by_edge {
		edges = append(edges, candidatejobfeedback.EdgeCreatedByEdge)
	}
	if m.clearedcandidate_job_edge {
		edges = append(edges, candidatejobfeedback.EdgeCandidateJobEdge)
	}
	if m.clearedattachment_edges {
		edges = append(edges, candidatejobfeedback.EdgeAttachmentEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateJobFeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		return m.clearedcreated_by_edge
	case candidatejobfeedback.EdgeCandidateJobEdge:
		return m.clearedcandidate_job_edge
	case candidatejobfeedback.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ClearEdge(name string) error {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		m.ClearCreatedByEdge()
		return nil
	case candidatejobfeedback.EdgeCandidateJobEdge:
		m.ClearCandidateJobEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateJobFeedbackMutation) ResetEdge(name string) error {
	switch name {
	case candidatejobfeedback.EdgeCreatedByEdge:
		m.ResetCreatedByEdge()
		return nil
	case candidatejobfeedback.EdgeCandidateJobEdge:
		m.ResetCandidateJobEdge()
		return nil
	case candidatejobfeedback.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobFeedback edge %s", name)
}

// CandidateJobStepMutation represents an operation that mutates the CandidateJobStep nodes in the graph.
type CandidateJobStepMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	candidate_job_status      *candidatejobstep.CandidateJobStatus
	clearedFields             map[string]struct{}
	candidate_job_edge        *uuid.UUID
	clearedcandidate_job_edge bool
	done                      bool
	oldValue                  func(context.Context) (*CandidateJobStep, error)
	predicates                []predicate.CandidateJobStep
}

var _ ent.Mutation = (*CandidateJobStepMutation)(nil)

// candidatejobstepOption allows management of the mutation configuration using functional options.
type candidatejobstepOption func(*CandidateJobStepMutation)

// newCandidateJobStepMutation creates new mutation for the CandidateJobStep entity.
func newCandidateJobStepMutation(c config, op Op, opts ...candidatejobstepOption) *CandidateJobStepMutation {
	m := &CandidateJobStepMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateJobStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateJobStepID sets the ID field of the mutation.
func withCandidateJobStepID(id uuid.UUID) candidatejobstepOption {
	return func(m *CandidateJobStepMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateJobStep
		)
		m.oldValue = func(ctx context.Context) (*CandidateJobStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateJobStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateJobStep sets the old CandidateJobStep of the mutation.
func withCandidateJobStep(node *CandidateJobStep) candidatejobstepOption {
	return func(m *CandidateJobStepMutation) {
		m.oldValue = func(context.Context) (*CandidateJobStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateJobStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateJobStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateJobStep entities.
func (m *CandidateJobStepMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateJobStepMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateJobStepMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateJobStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateJobStepMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateJobStepMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateJobStepMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateJobStepMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateJobStepMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateJobStepMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidatejobstep.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateJobStepMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobstep.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateJobStepMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidatejobstep.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateJobStepMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateJobStepMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateJobStepMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidatejobstep.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateJobStepMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidatejobstep.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateJobStepMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidatejobstep.FieldDeletedAt)
}

// SetCandidateJobStatus sets the "candidate_job_status" field.
func (m *CandidateJobStepMutation) SetCandidateJobStatus(cjs candidatejobstep.CandidateJobStatus) {
	m.candidate_job_status = &cjs
}

// CandidateJobStatus returns the value of the "candidate_job_status" field in the mutation.
func (m *CandidateJobStepMutation) CandidateJobStatus() (r candidatejobstep.CandidateJobStatus, exists bool) {
	v := m.candidate_job_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobStatus returns the old "candidate_job_status" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldCandidateJobStatus(ctx context.Context) (v candidatejobstep.CandidateJobStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobStatus: %w", err)
	}
	return oldValue.CandidateJobStatus, nil
}

// ResetCandidateJobStatus resets all changes to the "candidate_job_status" field.
func (m *CandidateJobStepMutation) ResetCandidateJobStatus() {
	m.candidate_job_status = nil
}

// SetCandidateJobID sets the "candidate_job_id" field.
func (m *CandidateJobStepMutation) SetCandidateJobID(u uuid.UUID) {
	m.candidate_job_edge = &u
}

// CandidateJobID returns the value of the "candidate_job_id" field in the mutation.
func (m *CandidateJobStepMutation) CandidateJobID() (r uuid.UUID, exists bool) {
	v := m.candidate_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateJobID returns the old "candidate_job_id" field's value of the CandidateJobStep entity.
// If the CandidateJobStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobStepMutation) OldCandidateJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateJobID: %w", err)
	}
	return oldValue.CandidateJobID, nil
}

// ClearCandidateJobID clears the value of the "candidate_job_id" field.
func (m *CandidateJobStepMutation) ClearCandidateJobID() {
	m.candidate_job_edge = nil
	m.clearedFields[candidatejobstep.FieldCandidateJobID] = struct{}{}
}

// CandidateJobIDCleared returns if the "candidate_job_id" field was cleared in this mutation.
func (m *CandidateJobStepMutation) CandidateJobIDCleared() bool {
	_, ok := m.clearedFields[candidatejobstep.FieldCandidateJobID]
	return ok
}

// ResetCandidateJobID resets all changes to the "candidate_job_id" field.
func (m *CandidateJobStepMutation) ResetCandidateJobID() {
	m.candidate_job_edge = nil
	delete(m.clearedFields, candidatejobstep.FieldCandidateJobID)
}

// SetCandidateJobEdgeID sets the "candidate_job_edge" edge to the CandidateJob entity by id.
func (m *CandidateJobStepMutation) SetCandidateJobEdgeID(id uuid.UUID) {
	m.candidate_job_edge = &id
}

// ClearCandidateJobEdge clears the "candidate_job_edge" edge to the CandidateJob entity.
func (m *CandidateJobStepMutation) ClearCandidateJobEdge() {
	m.clearedcandidate_job_edge = true
}

// CandidateJobEdgeCleared reports if the "candidate_job_edge" edge to the CandidateJob entity was cleared.
func (m *CandidateJobStepMutation) CandidateJobEdgeCleared() bool {
	return m.CandidateJobIDCleared() || m.clearedcandidate_job_edge
}

// CandidateJobEdgeID returns the "candidate_job_edge" edge ID in the mutation.
func (m *CandidateJobStepMutation) CandidateJobEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_job_edge != nil {
		return *m.candidate_job_edge, true
	}
	return
}

// CandidateJobEdgeIDs returns the "candidate_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobEdgeID instead. It exists only for internal usage by the builders.
func (m *CandidateJobStepMutation) CandidateJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJobEdge resets all changes to the "candidate_job_edge" edge.
func (m *CandidateJobStepMutation) ResetCandidateJobEdge() {
	m.candidate_job_edge = nil
	m.clearedcandidate_job_edge = false
}

// Where appends a list predicates to the CandidateJobStepMutation builder.
func (m *CandidateJobStepMutation) Where(ps ...predicate.CandidateJobStep) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateJobStepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateJobStep).
func (m *CandidateJobStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateJobStepMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, candidatejobstep.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidatejobstep.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidatejobstep.FieldDeletedAt)
	}
	if m.candidate_job_status != nil {
		fields = append(fields, candidatejobstep.FieldCandidateJobStatus)
	}
	if m.candidate_job_edge != nil {
		fields = append(fields, candidatejobstep.FieldCandidateJobID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateJobStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		return m.CreatedAt()
	case candidatejobstep.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidatejobstep.FieldDeletedAt:
		return m.DeletedAt()
	case candidatejobstep.FieldCandidateJobStatus:
		return m.CandidateJobStatus()
	case candidatejobstep.FieldCandidateJobID:
		return m.CandidateJobID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateJobStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidatejobstep.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidatejobstep.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidatejobstep.FieldCandidateJobStatus:
		return m.OldCandidateJobStatus(ctx)
	case candidatejobstep.FieldCandidateJobID:
		return m.OldCandidateJobID(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateJobStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidatejobstep.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidatejobstep.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidatejobstep.FieldCandidateJobStatus:
		v, ok := value.(candidatejobstep.CandidateJobStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobStatus(v)
		return nil
	case candidatejobstep.FieldCandidateJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateJobID(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateJobStepMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateJobStepMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateJobStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateJobStepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidatejobstep.FieldUpdatedAt) {
		fields = append(fields, candidatejobstep.FieldUpdatedAt)
	}
	if m.FieldCleared(candidatejobstep.FieldDeletedAt) {
		fields = append(fields, candidatejobstep.FieldDeletedAt)
	}
	if m.FieldCleared(candidatejobstep.FieldCandidateJobID) {
		fields = append(fields, candidatejobstep.FieldCandidateJobID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateJobStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateJobStepMutation) ClearField(name string) error {
	switch name {
	case candidatejobstep.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidatejobstep.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidatejobstep.FieldCandidateJobID:
		m.ClearCandidateJobID()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateJobStepMutation) ResetField(name string) error {
	switch name {
	case candidatejobstep.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidatejobstep.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidatejobstep.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidatejobstep.FieldCandidateJobStatus:
		m.ResetCandidateJobStatus()
		return nil
	case candidatejobstep.FieldCandidateJobID:
		m.ResetCandidateJobID()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateJobStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.candidate_job_edge != nil {
		edges = append(edges, candidatejobstep.EdgeCandidateJobEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateJobStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		if id := m.candidate_job_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateJobStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateJobStepMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateJobStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcandidate_job_edge {
		edges = append(edges, candidatejobstep.EdgeCandidateJobEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateJobStepMutation) EdgeCleared(name string) bool {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		return m.clearedcandidate_job_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateJobStepMutation) ClearEdge(name string) error {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		m.ClearCandidateJobEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateJobStepMutation) ResetEdge(name string) error {
	switch name {
	case candidatejobstep.EdgeCandidateJobEdge:
		m.ResetCandidateJobEdge()
		return nil
	}
	return fmt.Errorf("unknown CandidateJobStep edge %s", name)
}

// EmailRoleAttributeMutation represents an operation that mutates the EmailRoleAttribute nodes in the graph.
type EmailRoleAttributeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	clearedFields              map[string]struct{}
	email_template_edge        *uuid.UUID
	clearedemail_template_edge bool
	role_edge                  *uuid.UUID
	clearedrole_edge           bool
	done                       bool
	oldValue                   func(context.Context) (*EmailRoleAttribute, error)
	predicates                 []predicate.EmailRoleAttribute
}

var _ ent.Mutation = (*EmailRoleAttributeMutation)(nil)

// emailroleattributeOption allows management of the mutation configuration using functional options.
type emailroleattributeOption func(*EmailRoleAttributeMutation)

// newEmailRoleAttributeMutation creates new mutation for the EmailRoleAttribute entity.
func newEmailRoleAttributeMutation(c config, op Op, opts ...emailroleattributeOption) *EmailRoleAttributeMutation {
	m := &EmailRoleAttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailRoleAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailRoleAttributeID sets the ID field of the mutation.
func withEmailRoleAttributeID(id uuid.UUID) emailroleattributeOption {
	return func(m *EmailRoleAttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailRoleAttribute
		)
		m.oldValue = func(ctx context.Context) (*EmailRoleAttribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailRoleAttribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailRoleAttribute sets the old EmailRoleAttribute of the mutation.
func withEmailRoleAttribute(node *EmailRoleAttribute) emailroleattributeOption {
	return func(m *EmailRoleAttributeMutation) {
		m.oldValue = func(context.Context) (*EmailRoleAttribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailRoleAttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailRoleAttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailRoleAttribute entities.
func (m *EmailRoleAttributeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailRoleAttributeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailRoleAttributeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailRoleAttribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailRoleAttributeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailRoleAttributeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailRoleAttribute entity.
// If the EmailRoleAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailRoleAttributeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailRoleAttributeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailRoleAttributeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailRoleAttributeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailRoleAttribute entity.
// If the EmailRoleAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailRoleAttributeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EmailRoleAttributeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[emailroleattribute.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EmailRoleAttributeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[emailroleattribute.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailRoleAttributeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, emailroleattribute.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmailRoleAttributeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmailRoleAttributeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EmailRoleAttribute entity.
// If the EmailRoleAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailRoleAttributeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmailRoleAttributeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[emailroleattribute.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmailRoleAttributeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[emailroleattribute.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmailRoleAttributeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, emailroleattribute.FieldDeletedAt)
}

// SetEmailTemplateID sets the "email_template_id" field.
func (m *EmailRoleAttributeMutation) SetEmailTemplateID(u uuid.UUID) {
	m.email_template_edge = &u
}

// EmailTemplateID returns the value of the "email_template_id" field in the mutation.
func (m *EmailRoleAttributeMutation) EmailTemplateID() (r uuid.UUID, exists bool) {
	v := m.email_template_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailTemplateID returns the old "email_template_id" field's value of the EmailRoleAttribute entity.
// If the EmailRoleAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailRoleAttributeMutation) OldEmailTemplateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailTemplateID: %w", err)
	}
	return oldValue.EmailTemplateID, nil
}

// ResetEmailTemplateID resets all changes to the "email_template_id" field.
func (m *EmailRoleAttributeMutation) ResetEmailTemplateID() {
	m.email_template_edge = nil
}

// SetRoleID sets the "role_id" field.
func (m *EmailRoleAttributeMutation) SetRoleID(u uuid.UUID) {
	m.role_edge = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *EmailRoleAttributeMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the EmailRoleAttribute entity.
// If the EmailRoleAttribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailRoleAttributeMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *EmailRoleAttributeMutation) ResetRoleID() {
	m.role_edge = nil
}

// SetEmailTemplateEdgeID sets the "email_template_edge" edge to the EmailTemplate entity by id.
func (m *EmailRoleAttributeMutation) SetEmailTemplateEdgeID(id uuid.UUID) {
	m.email_template_edge = &id
}

// ClearEmailTemplateEdge clears the "email_template_edge" edge to the EmailTemplate entity.
func (m *EmailRoleAttributeMutation) ClearEmailTemplateEdge() {
	m.clearedemail_template_edge = true
}

// EmailTemplateEdgeCleared reports if the "email_template_edge" edge to the EmailTemplate entity was cleared.
func (m *EmailRoleAttributeMutation) EmailTemplateEdgeCleared() bool {
	return m.clearedemail_template_edge
}

// EmailTemplateEdgeID returns the "email_template_edge" edge ID in the mutation.
func (m *EmailRoleAttributeMutation) EmailTemplateEdgeID() (id uuid.UUID, exists bool) {
	if m.email_template_edge != nil {
		return *m.email_template_edge, true
	}
	return
}

// EmailTemplateEdgeIDs returns the "email_template_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailTemplateEdgeID instead. It exists only for internal usage by the builders.
func (m *EmailRoleAttributeMutation) EmailTemplateEdgeIDs() (ids []uuid.UUID) {
	if id := m.email_template_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailTemplateEdge resets all changes to the "email_template_edge" edge.
func (m *EmailRoleAttributeMutation) ResetEmailTemplateEdge() {
	m.email_template_edge = nil
	m.clearedemail_template_edge = false
}

// SetRoleEdgeID sets the "role_edge" edge to the Role entity by id.
func (m *EmailRoleAttributeMutation) SetRoleEdgeID(id uuid.UUID) {
	m.role_edge = &id
}

// ClearRoleEdge clears the "role_edge" edge to the Role entity.
func (m *EmailRoleAttributeMutation) ClearRoleEdge() {
	m.clearedrole_edge = true
}

// RoleEdgeCleared reports if the "role_edge" edge to the Role entity was cleared.
func (m *EmailRoleAttributeMutation) RoleEdgeCleared() bool {
	return m.clearedrole_edge
}

// RoleEdgeID returns the "role_edge" edge ID in the mutation.
func (m *EmailRoleAttributeMutation) RoleEdgeID() (id uuid.UUID, exists bool) {
	if m.role_edge != nil {
		return *m.role_edge, true
	}
	return
}

// RoleEdgeIDs returns the "role_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleEdgeID instead. It exists only for internal usage by the builders.
func (m *EmailRoleAttributeMutation) RoleEdgeIDs() (ids []uuid.UUID) {
	if id := m.role_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleEdge resets all changes to the "role_edge" edge.
func (m *EmailRoleAttributeMutation) ResetRoleEdge() {
	m.role_edge = nil
	m.clearedrole_edge = false
}

// Where appends a list predicates to the EmailRoleAttributeMutation builder.
func (m *EmailRoleAttributeMutation) Where(ps ...predicate.EmailRoleAttribute) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmailRoleAttributeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EmailRoleAttribute).
func (m *EmailRoleAttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailRoleAttributeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, emailroleattribute.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailroleattribute.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, emailroleattribute.FieldDeletedAt)
	}
	if m.email_template_edge != nil {
		fields = append(fields, emailroleattribute.FieldEmailTemplateID)
	}
	if m.role_edge != nil {
		fields = append(fields, emailroleattribute.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailRoleAttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailroleattribute.FieldCreatedAt:
		return m.CreatedAt()
	case emailroleattribute.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailroleattribute.FieldDeletedAt:
		return m.DeletedAt()
	case emailroleattribute.FieldEmailTemplateID:
		return m.EmailTemplateID()
	case emailroleattribute.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailRoleAttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailroleattribute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailroleattribute.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailroleattribute.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case emailroleattribute.FieldEmailTemplateID:
		return m.OldEmailTemplateID(ctx)
	case emailroleattribute.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown EmailRoleAttribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailRoleAttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailroleattribute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailroleattribute.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailroleattribute.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case emailroleattribute.FieldEmailTemplateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailTemplateID(v)
		return nil
	case emailroleattribute.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown EmailRoleAttribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailRoleAttributeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailRoleAttributeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailRoleAttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailRoleAttribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailRoleAttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailroleattribute.FieldUpdatedAt) {
		fields = append(fields, emailroleattribute.FieldUpdatedAt)
	}
	if m.FieldCleared(emailroleattribute.FieldDeletedAt) {
		fields = append(fields, emailroleattribute.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailRoleAttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailRoleAttributeMutation) ClearField(name string) error {
	switch name {
	case emailroleattribute.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case emailroleattribute.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailRoleAttribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailRoleAttributeMutation) ResetField(name string) error {
	switch name {
	case emailroleattribute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailroleattribute.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailroleattribute.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case emailroleattribute.FieldEmailTemplateID:
		m.ResetEmailTemplateID()
		return nil
	case emailroleattribute.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown EmailRoleAttribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailRoleAttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.email_template_edge != nil {
		edges = append(edges, emailroleattribute.EdgeEmailTemplateEdge)
	}
	if m.role_edge != nil {
		edges = append(edges, emailroleattribute.EdgeRoleEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailRoleAttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailroleattribute.EdgeEmailTemplateEdge:
		if id := m.email_template_edge; id != nil {
			return []ent.Value{*id}
		}
	case emailroleattribute.EdgeRoleEdge:
		if id := m.role_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailRoleAttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailRoleAttributeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailRoleAttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedemail_template_edge {
		edges = append(edges, emailroleattribute.EdgeEmailTemplateEdge)
	}
	if m.clearedrole_edge {
		edges = append(edges, emailroleattribute.EdgeRoleEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailRoleAttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case emailroleattribute.EdgeEmailTemplateEdge:
		return m.clearedemail_template_edge
	case emailroleattribute.EdgeRoleEdge:
		return m.clearedrole_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailRoleAttributeMutation) ClearEdge(name string) error {
	switch name {
	case emailroleattribute.EdgeEmailTemplateEdge:
		m.ClearEmailTemplateEdge()
		return nil
	case emailroleattribute.EdgeRoleEdge:
		m.ClearRoleEdge()
		return nil
	}
	return fmt.Errorf("unknown EmailRoleAttribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailRoleAttributeMutation) ResetEdge(name string) error {
	switch name {
	case emailroleattribute.EdgeEmailTemplateEdge:
		m.ResetEmailTemplateEdge()
		return nil
	case emailroleattribute.EdgeRoleEdge:
		m.ResetRoleEdge()
		return nil
	}
	return fmt.Errorf("unknown EmailRoleAttribute edge %s", name)
}

// EmailTemplateMutation represents an operation that mutates the EmailTemplate nodes in the graph.
type EmailTemplateMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	event                       *emailtemplate.Event
	send_to                     *[]string
	appendsend_to               []string
	cc                          *[]string
	appendcc                    []string
	bcc                         *[]string
	appendbcc                   []string
	subject                     *string
	content                     *string
	signature                   *string
	status                      *emailtemplate.Status
	clearedFields               map[string]struct{}
	role_edges                  map[uuid.UUID]struct{}
	removedrole_edges           map[uuid.UUID]struct{}
	clearedrole_edges           bool
	role_email_templates        map[uuid.UUID]struct{}
	removedrole_email_templates map[uuid.UUID]struct{}
	clearedrole_email_templates bool
	done                        bool
	oldValue                    func(context.Context) (*EmailTemplate, error)
	predicates                  []predicate.EmailTemplate
}

var _ ent.Mutation = (*EmailTemplateMutation)(nil)

// emailtemplateOption allows management of the mutation configuration using functional options.
type emailtemplateOption func(*EmailTemplateMutation)

// newEmailTemplateMutation creates new mutation for the EmailTemplate entity.
func newEmailTemplateMutation(c config, op Op, opts ...emailtemplateOption) *EmailTemplateMutation {
	m := &EmailTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailTemplateID sets the ID field of the mutation.
func withEmailTemplateID(id uuid.UUID) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailTemplate
		)
		m.oldValue = func(ctx context.Context) (*EmailTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailTemplate sets the old EmailTemplate of the mutation.
func withEmailTemplate(node *EmailTemplate) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		m.oldValue = func(context.Context) (*EmailTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailTemplate entities.
func (m *EmailTemplateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailTemplateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailTemplateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EmailTemplateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[emailtemplate.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EmailTemplateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, emailtemplate.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmailTemplateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmailTemplateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmailTemplateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[emailtemplate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmailTemplateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmailTemplateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, emailtemplate.FieldDeletedAt)
}

// SetEvent sets the "event" field.
func (m *EmailTemplateMutation) SetEvent(e emailtemplate.Event) {
	m.event = &e
}

// Event returns the value of the "event" field in the mutation.
func (m *EmailTemplateMutation) Event() (r emailtemplate.Event, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldEvent(ctx context.Context) (v emailtemplate.Event, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *EmailTemplateMutation) ResetEvent() {
	m.event = nil
}

// SetSendTo sets the "send_to" field.
func (m *EmailTemplateMutation) SetSendTo(s []string) {
	m.send_to = &s
	m.appendsend_to = nil
}

// SendTo returns the value of the "send_to" field in the mutation.
func (m *EmailTemplateMutation) SendTo() (r []string, exists bool) {
	v := m.send_to
	if v == nil {
		return
	}
	return *v, true
}

// OldSendTo returns the old "send_to" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSendTo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendTo: %w", err)
	}
	return oldValue.SendTo, nil
}

// AppendSendTo adds s to the "send_to" field.
func (m *EmailTemplateMutation) AppendSendTo(s []string) {
	m.appendsend_to = append(m.appendsend_to, s...)
}

// AppendedSendTo returns the list of values that were appended to the "send_to" field in this mutation.
func (m *EmailTemplateMutation) AppendedSendTo() ([]string, bool) {
	if len(m.appendsend_to) == 0 {
		return nil, false
	}
	return m.appendsend_to, true
}

// ResetSendTo resets all changes to the "send_to" field.
func (m *EmailTemplateMutation) ResetSendTo() {
	m.send_to = nil
	m.appendsend_to = nil
}

// SetCc sets the "cc" field.
func (m *EmailTemplateMutation) SetCc(s []string) {
	m.cc = &s
	m.appendcc = nil
}

// Cc returns the value of the "cc" field in the mutation.
func (m *EmailTemplateMutation) Cc() (r []string, exists bool) {
	v := m.cc
	if v == nil {
		return
	}
	return *v, true
}

// OldCc returns the old "cc" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldCc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCc: %w", err)
	}
	return oldValue.Cc, nil
}

// AppendCc adds s to the "cc" field.
func (m *EmailTemplateMutation) AppendCc(s []string) {
	m.appendcc = append(m.appendcc, s...)
}

// AppendedCc returns the list of values that were appended to the "cc" field in this mutation.
func (m *EmailTemplateMutation) AppendedCc() ([]string, bool) {
	if len(m.appendcc) == 0 {
		return nil, false
	}
	return m.appendcc, true
}

// ResetCc resets all changes to the "cc" field.
func (m *EmailTemplateMutation) ResetCc() {
	m.cc = nil
	m.appendcc = nil
}

// SetBcc sets the "bcc" field.
func (m *EmailTemplateMutation) SetBcc(s []string) {
	m.bcc = &s
	m.appendbcc = nil
}

// Bcc returns the value of the "bcc" field in the mutation.
func (m *EmailTemplateMutation) Bcc() (r []string, exists bool) {
	v := m.bcc
	if v == nil {
		return
	}
	return *v, true
}

// OldBcc returns the old "bcc" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldBcc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBcc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBcc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBcc: %w", err)
	}
	return oldValue.Bcc, nil
}

// AppendBcc adds s to the "bcc" field.
func (m *EmailTemplateMutation) AppendBcc(s []string) {
	m.appendbcc = append(m.appendbcc, s...)
}

// AppendedBcc returns the list of values that were appended to the "bcc" field in this mutation.
func (m *EmailTemplateMutation) AppendedBcc() ([]string, bool) {
	if len(m.appendbcc) == 0 {
		return nil, false
	}
	return m.appendbcc, true
}

// ResetBcc resets all changes to the "bcc" field.
func (m *EmailTemplateMutation) ResetBcc() {
	m.bcc = nil
	m.appendbcc = nil
}

// SetSubject sets the "subject" field.
func (m *EmailTemplateMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailTemplateMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailTemplateMutation) ResetSubject() {
	m.subject = nil
}

// SetContent sets the "content" field.
func (m *EmailTemplateMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *EmailTemplateMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *EmailTemplateMutation) ResetContent() {
	m.content = nil
}

// SetSignature sets the "signature" field.
func (m *EmailTemplateMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *EmailTemplateMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *EmailTemplateMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[emailtemplate.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *EmailTemplateMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *EmailTemplateMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, emailtemplate.FieldSignature)
}

// SetStatus sets the "status" field.
func (m *EmailTemplateMutation) SetStatus(e emailtemplate.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailTemplateMutation) Status() (r emailtemplate.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldStatus(ctx context.Context) (v emailtemplate.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailTemplateMutation) ResetStatus() {
	m.status = nil
}

// AddRoleEdgeIDs adds the "role_edges" edge to the Role entity by ids.
func (m *EmailTemplateMutation) AddRoleEdgeIDs(ids ...uuid.UUID) {
	if m.role_edges == nil {
		m.role_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_edges[ids[i]] = struct{}{}
	}
}

// ClearRoleEdges clears the "role_edges" edge to the Role entity.
func (m *EmailTemplateMutation) ClearRoleEdges() {
	m.clearedrole_edges = true
}

// RoleEdgesCleared reports if the "role_edges" edge to the Role entity was cleared.
func (m *EmailTemplateMutation) RoleEdgesCleared() bool {
	return m.clearedrole_edges
}

// RemoveRoleEdgeIDs removes the "role_edges" edge to the Role entity by IDs.
func (m *EmailTemplateMutation) RemoveRoleEdgeIDs(ids ...uuid.UUID) {
	if m.removedrole_edges == nil {
		m.removedrole_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_edges, ids[i])
		m.removedrole_edges[ids[i]] = struct{}{}
	}
}

// RemovedRoleEdges returns the removed IDs of the "role_edges" edge to the Role entity.
func (m *EmailTemplateMutation) RemovedRoleEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_edges {
		ids = append(ids, id)
	}
	return
}

// RoleEdgesIDs returns the "role_edges" edge IDs in the mutation.
func (m *EmailTemplateMutation) RoleEdgesIDs() (ids []uuid.UUID) {
	for id := range m.role_edges {
		ids = append(ids, id)
	}
	return
}

// ResetRoleEdges resets all changes to the "role_edges" edge.
func (m *EmailTemplateMutation) ResetRoleEdges() {
	m.role_edges = nil
	m.clearedrole_edges = false
	m.removedrole_edges = nil
}

// AddRoleEmailTemplateIDs adds the "role_email_templates" edge to the EmailRoleAttribute entity by ids.
func (m *EmailTemplateMutation) AddRoleEmailTemplateIDs(ids ...uuid.UUID) {
	if m.role_email_templates == nil {
		m.role_email_templates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_email_templates[ids[i]] = struct{}{}
	}
}

// ClearRoleEmailTemplates clears the "role_email_templates" edge to the EmailRoleAttribute entity.
func (m *EmailTemplateMutation) ClearRoleEmailTemplates() {
	m.clearedrole_email_templates = true
}

// RoleEmailTemplatesCleared reports if the "role_email_templates" edge to the EmailRoleAttribute entity was cleared.
func (m *EmailTemplateMutation) RoleEmailTemplatesCleared() bool {
	return m.clearedrole_email_templates
}

// RemoveRoleEmailTemplateIDs removes the "role_email_templates" edge to the EmailRoleAttribute entity by IDs.
func (m *EmailTemplateMutation) RemoveRoleEmailTemplateIDs(ids ...uuid.UUID) {
	if m.removedrole_email_templates == nil {
		m.removedrole_email_templates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_email_templates, ids[i])
		m.removedrole_email_templates[ids[i]] = struct{}{}
	}
}

// RemovedRoleEmailTemplates returns the removed IDs of the "role_email_templates" edge to the EmailRoleAttribute entity.
func (m *EmailTemplateMutation) RemovedRoleEmailTemplatesIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_email_templates {
		ids = append(ids, id)
	}
	return
}

// RoleEmailTemplatesIDs returns the "role_email_templates" edge IDs in the mutation.
func (m *EmailTemplateMutation) RoleEmailTemplatesIDs() (ids []uuid.UUID) {
	for id := range m.role_email_templates {
		ids = append(ids, id)
	}
	return
}

// ResetRoleEmailTemplates resets all changes to the "role_email_templates" edge.
func (m *EmailTemplateMutation) ResetRoleEmailTemplates() {
	m.role_email_templates = nil
	m.clearedrole_email_templates = false
	m.removedrole_email_templates = nil
}

// Where appends a list predicates to the EmailTemplateMutation builder.
func (m *EmailTemplateMutation) Where(ps ...predicate.EmailTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmailTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EmailTemplate).
func (m *EmailTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailTemplateMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, emailtemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailtemplate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, emailtemplate.FieldDeletedAt)
	}
	if m.event != nil {
		fields = append(fields, emailtemplate.FieldEvent)
	}
	if m.send_to != nil {
		fields = append(fields, emailtemplate.FieldSendTo)
	}
	if m.cc != nil {
		fields = append(fields, emailtemplate.FieldCc)
	}
	if m.bcc != nil {
		fields = append(fields, emailtemplate.FieldBcc)
	}
	if m.subject != nil {
		fields = append(fields, emailtemplate.FieldSubject)
	}
	if m.content != nil {
		fields = append(fields, emailtemplate.FieldContent)
	}
	if m.signature != nil {
		fields = append(fields, emailtemplate.FieldSignature)
	}
	if m.status != nil {
		fields = append(fields, emailtemplate.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailtemplate.FieldCreatedAt:
		return m.CreatedAt()
	case emailtemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailtemplate.FieldDeletedAt:
		return m.DeletedAt()
	case emailtemplate.FieldEvent:
		return m.Event()
	case emailtemplate.FieldSendTo:
		return m.SendTo()
	case emailtemplate.FieldCc:
		return m.Cc()
	case emailtemplate.FieldBcc:
		return m.Bcc()
	case emailtemplate.FieldSubject:
		return m.Subject()
	case emailtemplate.FieldContent:
		return m.Content()
	case emailtemplate.FieldSignature:
		return m.Signature()
	case emailtemplate.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailtemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailtemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailtemplate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case emailtemplate.FieldEvent:
		return m.OldEvent(ctx)
	case emailtemplate.FieldSendTo:
		return m.OldSendTo(ctx)
	case emailtemplate.FieldCc:
		return m.OldCc(ctx)
	case emailtemplate.FieldBcc:
		return m.OldBcc(ctx)
	case emailtemplate.FieldSubject:
		return m.OldSubject(ctx)
	case emailtemplate.FieldContent:
		return m.OldContent(ctx)
	case emailtemplate.FieldSignature:
		return m.OldSignature(ctx)
	case emailtemplate.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown EmailTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailtemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailtemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailtemplate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case emailtemplate.FieldEvent:
		v, ok := value.(emailtemplate.Event)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case emailtemplate.FieldSendTo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendTo(v)
		return nil
	case emailtemplate.FieldCc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCc(v)
		return nil
	case emailtemplate.FieldBcc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBcc(v)
		return nil
	case emailtemplate.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case emailtemplate.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case emailtemplate.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case emailtemplate.FieldStatus:
		v, ok := value.(emailtemplate.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailtemplate.FieldUpdatedAt) {
		fields = append(fields, emailtemplate.FieldUpdatedAt)
	}
	if m.FieldCleared(emailtemplate.FieldDeletedAt) {
		fields = append(fields, emailtemplate.FieldDeletedAt)
	}
	if m.FieldCleared(emailtemplate.FieldSignature) {
		fields = append(fields, emailtemplate.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ClearField(name string) error {
	switch name {
	case emailtemplate.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case emailtemplate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case emailtemplate.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ResetField(name string) error {
	switch name {
	case emailtemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailtemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailtemplate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case emailtemplate.FieldEvent:
		m.ResetEvent()
		return nil
	case emailtemplate.FieldSendTo:
		m.ResetSendTo()
		return nil
	case emailtemplate.FieldCc:
		m.ResetCc()
		return nil
	case emailtemplate.FieldBcc:
		m.ResetBcc()
		return nil
	case emailtemplate.FieldSubject:
		m.ResetSubject()
		return nil
	case emailtemplate.FieldContent:
		m.ResetContent()
		return nil
	case emailtemplate.FieldSignature:
		m.ResetSignature()
		return nil
	case emailtemplate.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role_edges != nil {
		edges = append(edges, emailtemplate.EdgeRoleEdges)
	}
	if m.role_email_templates != nil {
		edges = append(edges, emailtemplate.EdgeRoleEmailTemplates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailtemplate.EdgeRoleEdges:
		ids := make([]ent.Value, 0, len(m.role_edges))
		for id := range m.role_edges {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeRoleEmailTemplates:
		ids := make([]ent.Value, 0, len(m.role_email_templates))
		for id := range m.role_email_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrole_edges != nil {
		edges = append(edges, emailtemplate.EdgeRoleEdges)
	}
	if m.removedrole_email_templates != nil {
		edges = append(edges, emailtemplate.EdgeRoleEmailTemplates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailtemplate.EdgeRoleEdges:
		ids := make([]ent.Value, 0, len(m.removedrole_edges))
		for id := range m.removedrole_edges {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeRoleEmailTemplates:
		ids := make([]ent.Value, 0, len(m.removedrole_email_templates))
		for id := range m.removedrole_email_templates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole_edges {
		edges = append(edges, emailtemplate.EdgeRoleEdges)
	}
	if m.clearedrole_email_templates {
		edges = append(edges, emailtemplate.EdgeRoleEmailTemplates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case emailtemplate.EdgeRoleEdges:
		return m.clearedrole_edges
	case emailtemplate.EdgeRoleEmailTemplates:
		return m.clearedrole_email_templates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailTemplateMutation) ResetEdge(name string) error {
	switch name {
	case emailtemplate.EdgeRoleEdges:
		m.ResetRoleEdges()
		return nil
	case emailtemplate.EdgeRoleEmailTemplates:
		m.ResetRoleEmailTemplates()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate edge %s", name)
}

// EntityPermissionMutation represents an operation that mutates the EntityPermission nodes in the graph.
type EntityPermissionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	for_owner               *bool
	for_team                *bool
	for_all                 *bool
	entity_type             *entitypermission.EntityType
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	permission_edges        *uuid.UUID
	clearedpermission_edges bool
	user_edge               *uuid.UUID
	cleareduser_edge        bool
	role_edge               *uuid.UUID
	clearedrole_edge        bool
	done                    bool
	oldValue                func(context.Context) (*EntityPermission, error)
	predicates              []predicate.EntityPermission
}

var _ ent.Mutation = (*EntityPermissionMutation)(nil)

// entitypermissionOption allows management of the mutation configuration using functional options.
type entitypermissionOption func(*EntityPermissionMutation)

// newEntityPermissionMutation creates new mutation for the EntityPermission entity.
func newEntityPermissionMutation(c config, op Op, opts ...entitypermissionOption) *EntityPermissionMutation {
	m := &EntityPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeEntityPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntityPermissionID sets the ID field of the mutation.
func withEntityPermissionID(id uuid.UUID) entitypermissionOption {
	return func(m *EntityPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *EntityPermission
		)
		m.oldValue = func(ctx context.Context) (*EntityPermission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntityPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntityPermission sets the old EntityPermission of the mutation.
func withEntityPermission(node *EntityPermission) entitypermissionOption {
	return func(m *EntityPermissionMutation) {
		m.oldValue = func(context.Context) (*EntityPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntityPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntityPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntityPermission entities.
func (m *EntityPermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntityPermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntityPermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntityPermission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEntityID sets the "entity_id" field.
func (m *EntityPermissionMutation) SetEntityID(u uuid.UUID) {
	m.user_edge = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *EntityPermissionMutation) EntityID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldEntityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *EntityPermissionMutation) ClearEntityID() {
	m.user_edge = nil
	m.clearedFields[entitypermission.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *EntityPermissionMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[entitypermission.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *EntityPermissionMutation) ResetEntityID() {
	m.user_edge = nil
	delete(m.clearedFields, entitypermission.FieldEntityID)
}

// SetPermissionID sets the "permission_id" field.
func (m *EntityPermissionMutation) SetPermissionID(u uuid.UUID) {
	m.permission_edges = &u
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *EntityPermissionMutation) PermissionID() (r uuid.UUID, exists bool) {
	v := m.permission_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldPermissionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ClearPermissionID clears the value of the "permission_id" field.
func (m *EntityPermissionMutation) ClearPermissionID() {
	m.permission_edges = nil
	m.clearedFields[entitypermission.FieldPermissionID] = struct{}{}
}

// PermissionIDCleared returns if the "permission_id" field was cleared in this mutation.
func (m *EntityPermissionMutation) PermissionIDCleared() bool {
	_, ok := m.clearedFields[entitypermission.FieldPermissionID]
	return ok
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *EntityPermissionMutation) ResetPermissionID() {
	m.permission_edges = nil
	delete(m.clearedFields, entitypermission.FieldPermissionID)
}

// SetForOwner sets the "for_owner" field.
func (m *EntityPermissionMutation) SetForOwner(b bool) {
	m.for_owner = &b
}

// ForOwner returns the value of the "for_owner" field in the mutation.
func (m *EntityPermissionMutation) ForOwner() (r bool, exists bool) {
	v := m.for_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldForOwner returns the old "for_owner" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldForOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForOwner: %w", err)
	}
	return oldValue.ForOwner, nil
}

// ResetForOwner resets all changes to the "for_owner" field.
func (m *EntityPermissionMutation) ResetForOwner() {
	m.for_owner = nil
}

// SetForTeam sets the "for_team" field.
func (m *EntityPermissionMutation) SetForTeam(b bool) {
	m.for_team = &b
}

// ForTeam returns the value of the "for_team" field in the mutation.
func (m *EntityPermissionMutation) ForTeam() (r bool, exists bool) {
	v := m.for_team
	if v == nil {
		return
	}
	return *v, true
}

// OldForTeam returns the old "for_team" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldForTeam(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForTeam: %w", err)
	}
	return oldValue.ForTeam, nil
}

// ResetForTeam resets all changes to the "for_team" field.
func (m *EntityPermissionMutation) ResetForTeam() {
	m.for_team = nil
}

// SetForAll sets the "for_all" field.
func (m *EntityPermissionMutation) SetForAll(b bool) {
	m.for_all = &b
}

// ForAll returns the value of the "for_all" field in the mutation.
func (m *EntityPermissionMutation) ForAll() (r bool, exists bool) {
	v := m.for_all
	if v == nil {
		return
	}
	return *v, true
}

// OldForAll returns the old "for_all" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldForAll(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForAll is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForAll requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForAll: %w", err)
	}
	return oldValue.ForAll, nil
}

// ResetForAll resets all changes to the "for_all" field.
func (m *EntityPermissionMutation) ResetForAll() {
	m.for_all = nil
}

// SetEntityType sets the "entity_type" field.
func (m *EntityPermissionMutation) SetEntityType(et entitypermission.EntityType) {
	m.entity_type = &et
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *EntityPermissionMutation) EntityType() (r entitypermission.EntityType, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldEntityType(ctx context.Context) (v entitypermission.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *EntityPermissionMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[entitypermission.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *EntityPermissionMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[entitypermission.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *EntityPermissionMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, entitypermission.FieldEntityType)
}

// SetCreatedAt sets the "created_at" field.
func (m *EntityPermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntityPermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntityPermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntityPermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntityPermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntityPermission entity.
// If the EntityPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntityPermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntityPermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entitypermission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntityPermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entitypermission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntityPermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entitypermission.FieldUpdatedAt)
}

// SetPermissionEdgesID sets the "permission_edges" edge to the Permission entity by id.
func (m *EntityPermissionMutation) SetPermissionEdgesID(id uuid.UUID) {
	m.permission_edges = &id
}

// ClearPermissionEdges clears the "permission_edges" edge to the Permission entity.
func (m *EntityPermissionMutation) ClearPermissionEdges() {
	m.clearedpermission_edges = true
}

// PermissionEdgesCleared reports if the "permission_edges" edge to the Permission entity was cleared.
func (m *EntityPermissionMutation) PermissionEdgesCleared() bool {
	return m.PermissionIDCleared() || m.clearedpermission_edges
}

// PermissionEdgesID returns the "permission_edges" edge ID in the mutation.
func (m *EntityPermissionMutation) PermissionEdgesID() (id uuid.UUID, exists bool) {
	if m.permission_edges != nil {
		return *m.permission_edges, true
	}
	return
}

// PermissionEdgesIDs returns the "permission_edges" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PermissionEdgesID instead. It exists only for internal usage by the builders.
func (m *EntityPermissionMutation) PermissionEdgesIDs() (ids []uuid.UUID) {
	if id := m.permission_edges; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPermissionEdges resets all changes to the "permission_edges" edge.
func (m *EntityPermissionMutation) ResetPermissionEdges() {
	m.permission_edges = nil
	m.clearedpermission_edges = false
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *EntityPermissionMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *EntityPermissionMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *EntityPermissionMutation) UserEdgeCleared() bool {
	return m.EntityIDCleared() || m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *EntityPermissionMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *EntityPermissionMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *EntityPermissionMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetRoleEdgeID sets the "role_edge" edge to the Role entity by id.
func (m *EntityPermissionMutation) SetRoleEdgeID(id uuid.UUID) {
	m.role_edge = &id
}

// ClearRoleEdge clears the "role_edge" edge to the Role entity.
func (m *EntityPermissionMutation) ClearRoleEdge() {
	m.clearedrole_edge = true
}

// RoleEdgeCleared reports if the "role_edge" edge to the Role entity was cleared.
func (m *EntityPermissionMutation) RoleEdgeCleared() bool {
	return m.EntityIDCleared() || m.clearedrole_edge
}

// RoleEdgeID returns the "role_edge" edge ID in the mutation.
func (m *EntityPermissionMutation) RoleEdgeID() (id uuid.UUID, exists bool) {
	if m.role_edge != nil {
		return *m.role_edge, true
	}
	return
}

// RoleEdgeIDs returns the "role_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleEdgeID instead. It exists only for internal usage by the builders.
func (m *EntityPermissionMutation) RoleEdgeIDs() (ids []uuid.UUID) {
	if id := m.role_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleEdge resets all changes to the "role_edge" edge.
func (m *EntityPermissionMutation) ResetRoleEdge() {
	m.role_edge = nil
	m.clearedrole_edge = false
}

// Where appends a list predicates to the EntityPermissionMutation builder.
func (m *EntityPermissionMutation) Where(ps ...predicate.EntityPermission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntityPermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntityPermission).
func (m *EntityPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntityPermissionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user_edge != nil {
		fields = append(fields, entitypermission.FieldEntityID)
	}
	if m.permission_edges != nil {
		fields = append(fields, entitypermission.FieldPermissionID)
	}
	if m.for_owner != nil {
		fields = append(fields, entitypermission.FieldForOwner)
	}
	if m.for_team != nil {
		fields = append(fields, entitypermission.FieldForTeam)
	}
	if m.for_all != nil {
		fields = append(fields, entitypermission.FieldForAll)
	}
	if m.entity_type != nil {
		fields = append(fields, entitypermission.FieldEntityType)
	}
	if m.created_at != nil {
		fields = append(fields, entitypermission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entitypermission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntityPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entitypermission.FieldEntityID:
		return m.EntityID()
	case entitypermission.FieldPermissionID:
		return m.PermissionID()
	case entitypermission.FieldForOwner:
		return m.ForOwner()
	case entitypermission.FieldForTeam:
		return m.ForTeam()
	case entitypermission.FieldForAll:
		return m.ForAll()
	case entitypermission.FieldEntityType:
		return m.EntityType()
	case entitypermission.FieldCreatedAt:
		return m.CreatedAt()
	case entitypermission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntityPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entitypermission.FieldEntityID:
		return m.OldEntityID(ctx)
	case entitypermission.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case entitypermission.FieldForOwner:
		return m.OldForOwner(ctx)
	case entitypermission.FieldForTeam:
		return m.OldForTeam(ctx)
	case entitypermission.FieldForAll:
		return m.OldForAll(ctx)
	case entitypermission.FieldEntityType:
		return m.OldEntityType(ctx)
	case entitypermission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entitypermission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EntityPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entitypermission.FieldEntityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case entitypermission.FieldPermissionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case entitypermission.FieldForOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForOwner(v)
		return nil
	case entitypermission.FieldForTeam:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForTeam(v)
		return nil
	case entitypermission.FieldForAll:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForAll(v)
		return nil
	case entitypermission.FieldEntityType:
		v, ok := value.(entitypermission.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case entitypermission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entitypermission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EntityPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntityPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntityPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntityPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EntityPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntityPermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entitypermission.FieldEntityID) {
		fields = append(fields, entitypermission.FieldEntityID)
	}
	if m.FieldCleared(entitypermission.FieldPermissionID) {
		fields = append(fields, entitypermission.FieldPermissionID)
	}
	if m.FieldCleared(entitypermission.FieldEntityType) {
		fields = append(fields, entitypermission.FieldEntityType)
	}
	if m.FieldCleared(entitypermission.FieldUpdatedAt) {
		fields = append(fields, entitypermission.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntityPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntityPermissionMutation) ClearField(name string) error {
	switch name {
	case entitypermission.FieldEntityID:
		m.ClearEntityID()
		return nil
	case entitypermission.FieldPermissionID:
		m.ClearPermissionID()
		return nil
	case entitypermission.FieldEntityType:
		m.ClearEntityType()
		return nil
	case entitypermission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EntityPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntityPermissionMutation) ResetField(name string) error {
	switch name {
	case entitypermission.FieldEntityID:
		m.ResetEntityID()
		return nil
	case entitypermission.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case entitypermission.FieldForOwner:
		m.ResetForOwner()
		return nil
	case entitypermission.FieldForTeam:
		m.ResetForTeam()
		return nil
	case entitypermission.FieldForAll:
		m.ResetForAll()
		return nil
	case entitypermission.FieldEntityType:
		m.ResetEntityType()
		return nil
	case entitypermission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entitypermission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EntityPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntityPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.permission_edges != nil {
		edges = append(edges, entitypermission.EdgePermissionEdges)
	}
	if m.user_edge != nil {
		edges = append(edges, entitypermission.EdgeUserEdge)
	}
	if m.role_edge != nil {
		edges = append(edges, entitypermission.EdgeRoleEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntityPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entitypermission.EdgePermissionEdges:
		if id := m.permission_edges; id != nil {
			return []ent.Value{*id}
		}
	case entitypermission.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case entitypermission.EdgeRoleEdge:
		if id := m.role_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntityPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntityPermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntityPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpermission_edges {
		edges = append(edges, entitypermission.EdgePermissionEdges)
	}
	if m.cleareduser_edge {
		edges = append(edges, entitypermission.EdgeUserEdge)
	}
	if m.clearedrole_edge {
		edges = append(edges, entitypermission.EdgeRoleEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntityPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case entitypermission.EdgePermissionEdges:
		return m.clearedpermission_edges
	case entitypermission.EdgeUserEdge:
		return m.cleareduser_edge
	case entitypermission.EdgeRoleEdge:
		return m.clearedrole_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntityPermissionMutation) ClearEdge(name string) error {
	switch name {
	case entitypermission.EdgePermissionEdges:
		m.ClearPermissionEdges()
		return nil
	case entitypermission.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case entitypermission.EdgeRoleEdge:
		m.ClearRoleEdge()
		return nil
	}
	return fmt.Errorf("unknown EntityPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntityPermissionMutation) ResetEdge(name string) error {
	switch name {
	case entitypermission.EdgePermissionEdges:
		m.ResetPermissionEdges()
		return nil
	case entitypermission.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case entitypermission.EdgeRoleEdge:
		m.ResetRoleEdge()
		return nil
	}
	return fmt.Errorf("unknown EntityPermission edge %s", name)
}

// EntitySkillMutation represents an operation that mutates the EntitySkill nodes in the graph.
type EntitySkillMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	entity_type            *entityskill.EntityType
	order_id               *int
	addorder_id            *int
	clearedFields          map[string]struct{}
	skill_edge             *uuid.UUID
	clearedskill_edge      bool
	hiring_job_edge        *uuid.UUID
	clearedhiring_job_edge bool
	candidate_edge         *uuid.UUID
	clearedcandidate_edge  bool
	done                   bool
	oldValue               func(context.Context) (*EntitySkill, error)
	predicates             []predicate.EntitySkill
}

var _ ent.Mutation = (*EntitySkillMutation)(nil)

// entityskillOption allows management of the mutation configuration using functional options.
type entityskillOption func(*EntitySkillMutation)

// newEntitySkillMutation creates new mutation for the EntitySkill entity.
func newEntitySkillMutation(c config, op Op, opts ...entityskillOption) *EntitySkillMutation {
	m := &EntitySkillMutation{
		config:        c,
		op:            op,
		typ:           TypeEntitySkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEntitySkillID sets the ID field of the mutation.
func withEntitySkillID(id uuid.UUID) entityskillOption {
	return func(m *EntitySkillMutation) {
		var (
			err   error
			once  sync.Once
			value *EntitySkill
		)
		m.oldValue = func(ctx context.Context) (*EntitySkill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EntitySkill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEntitySkill sets the old EntitySkill of the mutation.
func withEntitySkill(node *EntitySkill) entityskillOption {
	return func(m *EntitySkillMutation) {
		m.oldValue = func(context.Context) (*EntitySkill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EntitySkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EntitySkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EntitySkill entities.
func (m *EntitySkillMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EntitySkillMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EntitySkillMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EntitySkill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EntitySkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EntitySkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EntitySkill entity.
// If the EntitySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitySkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EntitySkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EntitySkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EntitySkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EntitySkill entity.
// If the EntitySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitySkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EntitySkillMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[entityskill.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EntitySkillMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[entityskill.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EntitySkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, entityskill.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EntitySkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EntitySkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EntitySkill entity.
// If the EntitySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitySkillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EntitySkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[entityskill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EntitySkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[entityskill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EntitySkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, entityskill.FieldDeletedAt)
}

// SetEntityType sets the "entity_type" field.
func (m *EntitySkillMutation) SetEntityType(et entityskill.EntityType) {
	m.entity_type = &et
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *EntitySkillMutation) EntityType() (r entityskill.EntityType, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the EntitySkill entity.
// If the EntitySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitySkillMutation) OldEntityType(ctx context.Context) (v entityskill.EntityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *EntitySkillMutation) ResetEntityType() {
	m.entity_type = nil
}

// SetEntityID sets the "entity_id" field.
func (m *EntitySkillMutation) SetEntityID(u uuid.UUID) {
	m.hiring_job_edge = &u
}

// EntityID returns the value of the "entity_id" field in the mutation.
func (m *EntitySkillMutation) EntityID() (r uuid.UUID, exists bool) {
	v := m.hiring_job_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityID returns the old "entity_id" field's value of the EntitySkill entity.
// If the EntitySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitySkillMutation) OldEntityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityID: %w", err)
	}
	return oldValue.EntityID, nil
}

// ClearEntityID clears the value of the "entity_id" field.
func (m *EntitySkillMutation) ClearEntityID() {
	m.hiring_job_edge = nil
	m.clearedFields[entityskill.FieldEntityID] = struct{}{}
}

// EntityIDCleared returns if the "entity_id" field was cleared in this mutation.
func (m *EntitySkillMutation) EntityIDCleared() bool {
	_, ok := m.clearedFields[entityskill.FieldEntityID]
	return ok
}

// ResetEntityID resets all changes to the "entity_id" field.
func (m *EntitySkillMutation) ResetEntityID() {
	m.hiring_job_edge = nil
	delete(m.clearedFields, entityskill.FieldEntityID)
}

// SetSkillID sets the "skill_id" field.
func (m *EntitySkillMutation) SetSkillID(u uuid.UUID) {
	m.skill_edge = &u
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *EntitySkillMutation) SkillID() (r uuid.UUID, exists bool) {
	v := m.skill_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the EntitySkill entity.
// If the EntitySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitySkillMutation) OldSkillID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ClearSkillID clears the value of the "skill_id" field.
func (m *EntitySkillMutation) ClearSkillID() {
	m.skill_edge = nil
	m.clearedFields[entityskill.FieldSkillID] = struct{}{}
}

// SkillIDCleared returns if the "skill_id" field was cleared in this mutation.
func (m *EntitySkillMutation) SkillIDCleared() bool {
	_, ok := m.clearedFields[entityskill.FieldSkillID]
	return ok
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *EntitySkillMutation) ResetSkillID() {
	m.skill_edge = nil
	delete(m.clearedFields, entityskill.FieldSkillID)
}

// SetOrderID sets the "order_id" field.
func (m *EntitySkillMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *EntitySkillMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the EntitySkill entity.
// If the EntitySkill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EntitySkillMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *EntitySkillMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *EntitySkillMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *EntitySkillMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[entityskill.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *EntitySkillMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[entityskill.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *EntitySkillMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, entityskill.FieldOrderID)
}

// SetSkillEdgeID sets the "skill_edge" edge to the Skill entity by id.
func (m *EntitySkillMutation) SetSkillEdgeID(id uuid.UUID) {
	m.skill_edge = &id
}

// ClearSkillEdge clears the "skill_edge" edge to the Skill entity.
func (m *EntitySkillMutation) ClearSkillEdge() {
	m.clearedskill_edge = true
}

// SkillEdgeCleared reports if the "skill_edge" edge to the Skill entity was cleared.
func (m *EntitySkillMutation) SkillEdgeCleared() bool {
	return m.SkillIDCleared() || m.clearedskill_edge
}

// SkillEdgeID returns the "skill_edge" edge ID in the mutation.
func (m *EntitySkillMutation) SkillEdgeID() (id uuid.UUID, exists bool) {
	if m.skill_edge != nil {
		return *m.skill_edge, true
	}
	return
}

// SkillEdgeIDs returns the "skill_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillEdgeID instead. It exists only for internal usage by the builders.
func (m *EntitySkillMutation) SkillEdgeIDs() (ids []uuid.UUID) {
	if id := m.skill_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkillEdge resets all changes to the "skill_edge" edge.
func (m *EntitySkillMutation) ResetSkillEdge() {
	m.skill_edge = nil
	m.clearedskill_edge = false
}

// SetHiringJobEdgeID sets the "hiring_job_edge" edge to the HiringJob entity by id.
func (m *EntitySkillMutation) SetHiringJobEdgeID(id uuid.UUID) {
	m.hiring_job_edge = &id
}

// ClearHiringJobEdge clears the "hiring_job_edge" edge to the HiringJob entity.
func (m *EntitySkillMutation) ClearHiringJobEdge() {
	m.clearedhiring_job_edge = true
}

// HiringJobEdgeCleared reports if the "hiring_job_edge" edge to the HiringJob entity was cleared.
func (m *EntitySkillMutation) HiringJobEdgeCleared() bool {
	return m.EntityIDCleared() || m.clearedhiring_job_edge
}

// HiringJobEdgeID returns the "hiring_job_edge" edge ID in the mutation.
func (m *EntitySkillMutation) HiringJobEdgeID() (id uuid.UUID, exists bool) {
	if m.hiring_job_edge != nil {
		return *m.hiring_job_edge, true
	}
	return
}

// HiringJobEdgeIDs returns the "hiring_job_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HiringJobEdgeID instead. It exists only for internal usage by the builders.
func (m *EntitySkillMutation) HiringJobEdgeIDs() (ids []uuid.UUID) {
	if id := m.hiring_job_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHiringJobEdge resets all changes to the "hiring_job_edge" edge.
func (m *EntitySkillMutation) ResetHiringJobEdge() {
	m.hiring_job_edge = nil
	m.clearedhiring_job_edge = false
}

// SetCandidateEdgeID sets the "candidate_edge" edge to the Candidate entity by id.
func (m *EntitySkillMutation) SetCandidateEdgeID(id uuid.UUID) {
	m.candidate_edge = &id
}

// ClearCandidateEdge clears the "candidate_edge" edge to the Candidate entity.
func (m *EntitySkillMutation) ClearCandidateEdge() {
	m.clearedcandidate_edge = true
}

// CandidateEdgeCleared reports if the "candidate_edge" edge to the Candidate entity was cleared.
func (m *EntitySkillMutation) CandidateEdgeCleared() bool {
	return m.EntityIDCleared() || m.clearedcandidate_edge
}

// CandidateEdgeID returns the "candidate_edge" edge ID in the mutation.
func (m *EntitySkillMutation) CandidateEdgeID() (id uuid.UUID, exists bool) {
	if m.candidate_edge != nil {
		return *m.candidate_edge, true
	}
	return
}

// CandidateEdgeIDs returns the "candidate_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateEdgeID instead. It exists only for internal usage by the builders.
func (m *EntitySkillMutation) CandidateEdgeIDs() (ids []uuid.UUID) {
	if id := m.candidate_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateEdge resets all changes to the "candidate_edge" edge.
func (m *EntitySkillMutation) ResetCandidateEdge() {
	m.candidate_edge = nil
	m.clearedcandidate_edge = false
}

// Where appends a list predicates to the EntitySkillMutation builder.
func (m *EntitySkillMutation) Where(ps ...predicate.EntitySkill) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EntitySkillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EntitySkill).
func (m *EntitySkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EntitySkillMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, entityskill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, entityskill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, entityskill.FieldDeletedAt)
	}
	if m.entity_type != nil {
		fields = append(fields, entityskill.FieldEntityType)
	}
	if m.hiring_job_edge != nil {
		fields = append(fields, entityskill.FieldEntityID)
	}
	if m.skill_edge != nil {
		fields = append(fields, entityskill.FieldSkillID)
	}
	if m.order_id != nil {
		fields = append(fields, entityskill.FieldOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EntitySkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case entityskill.FieldCreatedAt:
		return m.CreatedAt()
	case entityskill.FieldUpdatedAt:
		return m.UpdatedAt()
	case entityskill.FieldDeletedAt:
		return m.DeletedAt()
	case entityskill.FieldEntityType:
		return m.EntityType()
	case entityskill.FieldEntityID:
		return m.EntityID()
	case entityskill.FieldSkillID:
		return m.SkillID()
	case entityskill.FieldOrderID:
		return m.OrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EntitySkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case entityskill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case entityskill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case entityskill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case entityskill.FieldEntityType:
		return m.OldEntityType(ctx)
	case entityskill.FieldEntityID:
		return m.OldEntityID(ctx)
	case entityskill.FieldSkillID:
		return m.OldSkillID(ctx)
	case entityskill.FieldOrderID:
		return m.OldOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown EntitySkill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitySkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case entityskill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case entityskill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case entityskill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case entityskill.FieldEntityType:
		v, ok := value.(entityskill.EntityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case entityskill.FieldEntityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityID(v)
		return nil
	case entityskill.FieldSkillID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	case entityskill.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown EntitySkill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EntitySkillMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, entityskill.FieldOrderID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EntitySkillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case entityskill.FieldOrderID:
		return m.AddedOrderID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EntitySkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case entityskill.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown EntitySkill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EntitySkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(entityskill.FieldUpdatedAt) {
		fields = append(fields, entityskill.FieldUpdatedAt)
	}
	if m.FieldCleared(entityskill.FieldDeletedAt) {
		fields = append(fields, entityskill.FieldDeletedAt)
	}
	if m.FieldCleared(entityskill.FieldEntityID) {
		fields = append(fields, entityskill.FieldEntityID)
	}
	if m.FieldCleared(entityskill.FieldSkillID) {
		fields = append(fields, entityskill.FieldSkillID)
	}
	if m.FieldCleared(entityskill.FieldOrderID) {
		fields = append(fields, entityskill.FieldOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EntitySkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EntitySkillMutation) ClearField(name string) error {
	switch name {
	case entityskill.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case entityskill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case entityskill.FieldEntityID:
		m.ClearEntityID()
		return nil
	case entityskill.FieldSkillID:
		m.ClearSkillID()
		return nil
	case entityskill.FieldOrderID:
		m.ClearOrderID()
		return nil
	}
	return fmt.Errorf("unknown EntitySkill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EntitySkillMutation) ResetField(name string) error {
	switch name {
	case entityskill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case entityskill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case entityskill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case entityskill.FieldEntityType:
		m.ResetEntityType()
		return nil
	case entityskill.FieldEntityID:
		m.ResetEntityID()
		return nil
	case entityskill.FieldSkillID:
		m.ResetSkillID()
		return nil
	case entityskill.FieldOrderID:
		m.ResetOrderID()
		return nil
	}
	return fmt.Errorf("unknown EntitySkill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EntitySkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.skill_edge != nil {
		edges = append(edges, entityskill.EdgeSkillEdge)
	}
	if m.hiring_job_edge != nil {
		edges = append(edges, entityskill.EdgeHiringJobEdge)
	}
	if m.candidate_edge != nil {
		edges = append(edges, entityskill.EdgeCandidateEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EntitySkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case entityskill.EdgeSkillEdge:
		if id := m.skill_edge; id != nil {
			return []ent.Value{*id}
		}
	case entityskill.EdgeHiringJobEdge:
		if id := m.hiring_job_edge; id != nil {
			return []ent.Value{*id}
		}
	case entityskill.EdgeCandidateEdge:
		if id := m.candidate_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EntitySkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EntitySkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EntitySkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedskill_edge {
		edges = append(edges, entityskill.EdgeSkillEdge)
	}
	if m.clearedhiring_job_edge {
		edges = append(edges, entityskill.EdgeHiringJobEdge)
	}
	if m.clearedcandidate_edge {
		edges = append(edges, entityskill.EdgeCandidateEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EntitySkillMutation) EdgeCleared(name string) bool {
	switch name {
	case entityskill.EdgeSkillEdge:
		return m.clearedskill_edge
	case entityskill.EdgeHiringJobEdge:
		return m.clearedhiring_job_edge
	case entityskill.EdgeCandidateEdge:
		return m.clearedcandidate_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EntitySkillMutation) ClearEdge(name string) error {
	switch name {
	case entityskill.EdgeSkillEdge:
		m.ClearSkillEdge()
		return nil
	case entityskill.EdgeHiringJobEdge:
		m.ClearHiringJobEdge()
		return nil
	case entityskill.EdgeCandidateEdge:
		m.ClearCandidateEdge()
		return nil
	}
	return fmt.Errorf("unknown EntitySkill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EntitySkillMutation) ResetEdge(name string) error {
	switch name {
	case entityskill.EdgeSkillEdge:
		m.ResetSkillEdge()
		return nil
	case entityskill.EdgeHiringJobEdge:
		m.ResetHiringJobEdge()
		return nil
	case entityskill.EdgeCandidateEdge:
		m.ResetCandidateEdge()
		return nil
	}
	return fmt.Errorf("unknown EntitySkill edge %s", name)
}

// HiringJobMutation represents an operation that mutates the HiringJob nodes in the graph.
type HiringJobMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	deleted_at                    *time.Time
	slug                          *string
	name                          *string
	description                   *string
	amount                        *int
	addamount                     *int
	status                        *hiringjob.Status
	location                      *hiringjob.Location
	salary_type                   *hiringjob.SalaryType
	salary_from                   *int
	addsalary_from                *int
	salary_to                     *int
	addsalary_to                  *int
	currency                      *hiringjob.Currency
	last_apply_date               *time.Time
	priority                      *int
	addpriority                   *int
	clearedFields                 map[string]struct{}
	owner_edge                    *uuid.UUID
	clearedowner_edge             bool
	team_edge                     *uuid.UUID
	clearedteam_edge              bool
	candidate_job_edges           map[uuid.UUID]struct{}
	removedcandidate_job_edges    map[uuid.UUID]struct{}
	clearedcandidate_job_edges    bool
	hiring_job_skill_edges        map[uuid.UUID]struct{}
	removedhiring_job_skill_edges map[uuid.UUID]struct{}
	clearedhiring_job_skill_edges bool
	hiring_team_edge              *uuid.UUID
	clearedhiring_team_edge       bool
	done                          bool
	oldValue                      func(context.Context) (*HiringJob, error)
	predicates                    []predicate.HiringJob
}

var _ ent.Mutation = (*HiringJobMutation)(nil)

// hiringjobOption allows management of the mutation configuration using functional options.
type hiringjobOption func(*HiringJobMutation)

// newHiringJobMutation creates new mutation for the HiringJob entity.
func newHiringJobMutation(c config, op Op, opts ...hiringjobOption) *HiringJobMutation {
	m := &HiringJobMutation{
		config:        c,
		op:            op,
		typ:           TypeHiringJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHiringJobID sets the ID field of the mutation.
func withHiringJobID(id uuid.UUID) hiringjobOption {
	return func(m *HiringJobMutation) {
		var (
			err   error
			once  sync.Once
			value *HiringJob
		)
		m.oldValue = func(ctx context.Context) (*HiringJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HiringJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHiringJob sets the old HiringJob of the mutation.
func withHiringJob(node *HiringJob) hiringjobOption {
	return func(m *HiringJobMutation) {
		m.oldValue = func(context.Context) (*HiringJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HiringJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HiringJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HiringJob entities.
func (m *HiringJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HiringJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HiringJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HiringJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HiringJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HiringJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HiringJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HiringJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HiringJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HiringJobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hiringjob.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HiringJobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HiringJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hiringjob.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HiringJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HiringJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HiringJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hiringjob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HiringJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HiringJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hiringjob.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *HiringJobMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *HiringJobMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *HiringJobMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *HiringJobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HiringJobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HiringJobMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HiringJobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HiringJobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HiringJobMutation) ResetDescription() {
	m.description = nil
}

// SetAmount sets the "amount" field.
func (m *HiringJobMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *HiringJobMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *HiringJobMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *HiringJobMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *HiringJobMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *HiringJobMutation) SetStatus(h hiringjob.Status) {
	m.status = &h
}

// Status returns the value of the "status" field in the mutation.
func (m *HiringJobMutation) Status() (r hiringjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldStatus(ctx context.Context) (v hiringjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HiringJobMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *HiringJobMutation) SetCreatedBy(u uuid.UUID) {
	m.owner_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HiringJobMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.owner_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HiringJobMutation) ClearCreatedBy() {
	m.owner_edge = nil
	m.clearedFields[hiringjob.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HiringJobMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HiringJobMutation) ResetCreatedBy() {
	m.owner_edge = nil
	delete(m.clearedFields, hiringjob.FieldCreatedBy)
}

// SetTeamID sets the "team_id" field.
func (m *HiringJobMutation) SetTeamID(u uuid.UUID) {
	m.team_edge = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HiringJobMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *HiringJobMutation) ClearTeamID() {
	m.team_edge = nil
	m.clearedFields[hiringjob.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *HiringJobMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HiringJobMutation) ResetTeamID() {
	m.team_edge = nil
	delete(m.clearedFields, hiringjob.FieldTeamID)
}

// SetLocation sets the "location" field.
func (m *HiringJobMutation) SetLocation(h hiringjob.Location) {
	m.location = &h
}

// Location returns the value of the "location" field in the mutation.
func (m *HiringJobMutation) Location() (r hiringjob.Location, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldLocation(ctx context.Context) (v hiringjob.Location, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *HiringJobMutation) ResetLocation() {
	m.location = nil
}

// SetSalaryType sets the "salary_type" field.
func (m *HiringJobMutation) SetSalaryType(ht hiringjob.SalaryType) {
	m.salary_type = &ht
}

// SalaryType returns the value of the "salary_type" field in the mutation.
func (m *HiringJobMutation) SalaryType() (r hiringjob.SalaryType, exists bool) {
	v := m.salary_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryType returns the old "salary_type" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryType(ctx context.Context) (v hiringjob.SalaryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryType: %w", err)
	}
	return oldValue.SalaryType, nil
}

// ResetSalaryType resets all changes to the "salary_type" field.
func (m *HiringJobMutation) ResetSalaryType() {
	m.salary_type = nil
}

// SetSalaryFrom sets the "salary_from" field.
func (m *HiringJobMutation) SetSalaryFrom(i int) {
	m.salary_from = &i
	m.addsalary_from = nil
}

// SalaryFrom returns the value of the "salary_from" field in the mutation.
func (m *HiringJobMutation) SalaryFrom() (r int, exists bool) {
	v := m.salary_from
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryFrom returns the old "salary_from" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryFrom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryFrom: %w", err)
	}
	return oldValue.SalaryFrom, nil
}

// AddSalaryFrom adds i to the "salary_from" field.
func (m *HiringJobMutation) AddSalaryFrom(i int) {
	if m.addsalary_from != nil {
		*m.addsalary_from += i
	} else {
		m.addsalary_from = &i
	}
}

// AddedSalaryFrom returns the value that was added to the "salary_from" field in this mutation.
func (m *HiringJobMutation) AddedSalaryFrom() (r int, exists bool) {
	v := m.addsalary_from
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalaryFrom resets all changes to the "salary_from" field.
func (m *HiringJobMutation) ResetSalaryFrom() {
	m.salary_from = nil
	m.addsalary_from = nil
}

// SetSalaryTo sets the "salary_to" field.
func (m *HiringJobMutation) SetSalaryTo(i int) {
	m.salary_to = &i
	m.addsalary_to = nil
}

// SalaryTo returns the value of the "salary_to" field in the mutation.
func (m *HiringJobMutation) SalaryTo() (r int, exists bool) {
	v := m.salary_to
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryTo returns the old "salary_to" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryTo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryTo: %w", err)
	}
	return oldValue.SalaryTo, nil
}

// AddSalaryTo adds i to the "salary_to" field.
func (m *HiringJobMutation) AddSalaryTo(i int) {
	if m.addsalary_to != nil {
		*m.addsalary_to += i
	} else {
		m.addsalary_to = &i
	}
}

// AddedSalaryTo returns the value that was added to the "salary_to" field in this mutation.
func (m *HiringJobMutation) AddedSalaryTo() (r int, exists bool) {
	v := m.addsalary_to
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalaryTo resets all changes to the "salary_to" field.
func (m *HiringJobMutation) ResetSalaryTo() {
	m.salary_to = nil
	m.addsalary_to = nil
}

// SetCurrency sets the "currency" field.
func (m *HiringJobMutation) SetCurrency(h hiringjob.Currency) {
	m.currency = &h
}

// Currency returns the value of the "currency" field in the mutation.
func (m *HiringJobMutation) Currency() (r hiringjob.Currency, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCurrency(ctx context.Context) (v hiringjob.Currency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *HiringJobMutation) ResetCurrency() {
	m.currency = nil
}

// SetLastApplyDate sets the "last_apply_date" field.
func (m *HiringJobMutation) SetLastApplyDate(t time.Time) {
	m.last_apply_date = &t
}

// LastApplyDate returns the value of the "last_apply_date" field in the mutation.
func (m *HiringJobMutation) LastApplyDate() (r time.Time, exists bool) {
	v := m.last_apply_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastApplyDate returns the old "last_apply_date" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldLastApplyDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastApplyDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastApplyDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastApplyDate: %w", err)
	}
	return oldValue.LastApplyDate, nil
}

// ClearLastApplyDate clears the value of the "last_apply_date" field.
func (m *HiringJobMutation) ClearLastApplyDate() {
	m.last_apply_date = nil
	m.clearedFields[hiringjob.FieldLastApplyDate] = struct{}{}
}

// LastApplyDateCleared returns if the "last_apply_date" field was cleared in this mutation.
func (m *HiringJobMutation) LastApplyDateCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldLastApplyDate]
	return ok
}

// ResetLastApplyDate resets all changes to the "last_apply_date" field.
func (m *HiringJobMutation) ResetLastApplyDate() {
	m.last_apply_date = nil
	delete(m.clearedFields, hiringjob.FieldLastApplyDate)
}

// SetPriority sets the "priority" field.
func (m *HiringJobMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *HiringJobMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *HiringJobMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *HiringJobMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *HiringJobMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetHiringTeamID sets the "hiring_team_id" field.
func (m *HiringJobMutation) SetHiringTeamID(u uuid.UUID) {
	m.hiring_team_edge = &u
}

// HiringTeamID returns the value of the "hiring_team_id" field in the mutation.
func (m *HiringJobMutation) HiringTeamID() (r uuid.UUID, exists bool) {
	v := m.hiring_team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldHiringTeamID returns the old "hiring_team_id" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldHiringTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHiringTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHiringTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiringTeamID: %w", err)
	}
	return oldValue.HiringTeamID, nil
}

// ClearHiringTeamID clears the value of the "hiring_team_id" field.
func (m *HiringJobMutation) ClearHiringTeamID() {
	m.hiring_team_edge = nil
	m.clearedFields[hiringjob.FieldHiringTeamID] = struct{}{}
}

// HiringTeamIDCleared returns if the "hiring_team_id" field was cleared in this mutation.
func (m *HiringJobMutation) HiringTeamIDCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldHiringTeamID]
	return ok
}

// ResetHiringTeamID resets all changes to the "hiring_team_id" field.
func (m *HiringJobMutation) ResetHiringTeamID() {
	m.hiring_team_edge = nil
	delete(m.clearedFields, hiringjob.FieldHiringTeamID)
}

// SetOwnerEdgeID sets the "owner_edge" edge to the User entity by id.
func (m *HiringJobMutation) SetOwnerEdgeID(id uuid.UUID) {
	m.owner_edge = &id
}

// ClearOwnerEdge clears the "owner_edge" edge to the User entity.
func (m *HiringJobMutation) ClearOwnerEdge() {
	m.clearedowner_edge = true
}

// OwnerEdgeCleared reports if the "owner_edge" edge to the User entity was cleared.
func (m *HiringJobMutation) OwnerEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedowner_edge
}

// OwnerEdgeID returns the "owner_edge" edge ID in the mutation.
func (m *HiringJobMutation) OwnerEdgeID() (id uuid.UUID, exists bool) {
	if m.owner_edge != nil {
		return *m.owner_edge, true
	}
	return
}

// OwnerEdgeIDs returns the "owner_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringJobMutation) OwnerEdgeIDs() (ids []uuid.UUID) {
	if id := m.owner_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerEdge resets all changes to the "owner_edge" edge.
func (m *HiringJobMutation) ResetOwnerEdge() {
	m.owner_edge = nil
	m.clearedowner_edge = false
}

// SetTeamEdgeID sets the "team_edge" edge to the Team entity by id.
func (m *HiringJobMutation) SetTeamEdgeID(id uuid.UUID) {
	m.team_edge = &id
}

// ClearTeamEdge clears the "team_edge" edge to the Team entity.
func (m *HiringJobMutation) ClearTeamEdge() {
	m.clearedteam_edge = true
}

// TeamEdgeCleared reports if the "team_edge" edge to the Team entity was cleared.
func (m *HiringJobMutation) TeamEdgeCleared() bool {
	return m.TeamIDCleared() || m.clearedteam_edge
}

// TeamEdgeID returns the "team_edge" edge ID in the mutation.
func (m *HiringJobMutation) TeamEdgeID() (id uuid.UUID, exists bool) {
	if m.team_edge != nil {
		return *m.team_edge, true
	}
	return
}

// TeamEdgeIDs returns the "team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringJobMutation) TeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamEdge resets all changes to the "team_edge" edge.
func (m *HiringJobMutation) ResetTeamEdge() {
	m.team_edge = nil
	m.clearedteam_edge = false
}

// AddCandidateJobEdgeIDs adds the "candidate_job_edges" edge to the CandidateJob entity by ids.
func (m *HiringJobMutation) AddCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_job_edges == nil {
		m.candidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobEdges clears the "candidate_job_edges" edge to the CandidateJob entity.
func (m *HiringJobMutation) ClearCandidateJobEdges() {
	m.clearedcandidate_job_edges = true
}

// CandidateJobEdgesCleared reports if the "candidate_job_edges" edge to the CandidateJob entity was cleared.
func (m *HiringJobMutation) CandidateJobEdgesCleared() bool {
	return m.clearedcandidate_job_edges
}

// RemoveCandidateJobEdgeIDs removes the "candidate_job_edges" edge to the CandidateJob entity by IDs.
func (m *HiringJobMutation) RemoveCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_edges == nil {
		m.removedcandidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_edges, ids[i])
		m.removedcandidate_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobEdges returns the removed IDs of the "candidate_job_edges" edge to the CandidateJob entity.
func (m *HiringJobMutation) RemovedCandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateJobEdgesIDs returns the "candidate_job_edges" edge IDs in the mutation.
func (m *HiringJobMutation) CandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobEdges resets all changes to the "candidate_job_edges" edge.
func (m *HiringJobMutation) ResetCandidateJobEdges() {
	m.candidate_job_edges = nil
	m.clearedcandidate_job_edges = false
	m.removedcandidate_job_edges = nil
}

// AddHiringJobSkillEdgeIDs adds the "hiring_job_skill_edges" edge to the EntitySkill entity by ids.
func (m *HiringJobMutation) AddHiringJobSkillEdgeIDs(ids ...uuid.UUID) {
	if m.hiring_job_skill_edges == nil {
		m.hiring_job_skill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_job_skill_edges[ids[i]] = struct{}{}
	}
}

// ClearHiringJobSkillEdges clears the "hiring_job_skill_edges" edge to the EntitySkill entity.
func (m *HiringJobMutation) ClearHiringJobSkillEdges() {
	m.clearedhiring_job_skill_edges = true
}

// HiringJobSkillEdgesCleared reports if the "hiring_job_skill_edges" edge to the EntitySkill entity was cleared.
func (m *HiringJobMutation) HiringJobSkillEdgesCleared() bool {
	return m.clearedhiring_job_skill_edges
}

// RemoveHiringJobSkillEdgeIDs removes the "hiring_job_skill_edges" edge to the EntitySkill entity by IDs.
func (m *HiringJobMutation) RemoveHiringJobSkillEdgeIDs(ids ...uuid.UUID) {
	if m.removedhiring_job_skill_edges == nil {
		m.removedhiring_job_skill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_job_skill_edges, ids[i])
		m.removedhiring_job_skill_edges[ids[i]] = struct{}{}
	}
}

// RemovedHiringJobSkillEdges returns the removed IDs of the "hiring_job_skill_edges" edge to the EntitySkill entity.
func (m *HiringJobMutation) RemovedHiringJobSkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_job_skill_edges {
		ids = append(ids, id)
	}
	return
}

// HiringJobSkillEdgesIDs returns the "hiring_job_skill_edges" edge IDs in the mutation.
func (m *HiringJobMutation) HiringJobSkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.hiring_job_skill_edges {
		ids = append(ids, id)
	}
	return
}

// ResetHiringJobSkillEdges resets all changes to the "hiring_job_skill_edges" edge.
func (m *HiringJobMutation) ResetHiringJobSkillEdges() {
	m.hiring_job_skill_edges = nil
	m.clearedhiring_job_skill_edges = false
	m.removedhiring_job_skill_edges = nil
}

// SetHiringTeamEdgeID sets the "hiring_team_edge" edge to the HiringTeam entity by id.
func (m *HiringJobMutation) SetHiringTeamEdgeID(id uuid.UUID) {
	m.hiring_team_edge = &id
}

// ClearHiringTeamEdge clears the "hiring_team_edge" edge to the HiringTeam entity.
func (m *HiringJobMutation) ClearHiringTeamEdge() {
	m.clearedhiring_team_edge = true
}

// HiringTeamEdgeCleared reports if the "hiring_team_edge" edge to the HiringTeam entity was cleared.
func (m *HiringJobMutation) HiringTeamEdgeCleared() bool {
	return m.HiringTeamIDCleared() || m.clearedhiring_team_edge
}

// HiringTeamEdgeID returns the "hiring_team_edge" edge ID in the mutation.
func (m *HiringJobMutation) HiringTeamEdgeID() (id uuid.UUID, exists bool) {
	if m.hiring_team_edge != nil {
		return *m.hiring_team_edge, true
	}
	return
}

// HiringTeamEdgeIDs returns the "hiring_team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HiringTeamEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringJobMutation) HiringTeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.hiring_team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHiringTeamEdge resets all changes to the "hiring_team_edge" edge.
func (m *HiringJobMutation) ResetHiringTeamEdge() {
	m.hiring_team_edge = nil
	m.clearedhiring_team_edge = false
}

// Where appends a list predicates to the HiringJobMutation builder.
func (m *HiringJobMutation) Where(ps ...predicate.HiringJob) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HiringJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HiringJob).
func (m *HiringJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HiringJobMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, hiringjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hiringjob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hiringjob.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, hiringjob.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, hiringjob.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hiringjob.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, hiringjob.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, hiringjob.FieldStatus)
	}
	if m.owner_edge != nil {
		fields = append(fields, hiringjob.FieldCreatedBy)
	}
	if m.team_edge != nil {
		fields = append(fields, hiringjob.FieldTeamID)
	}
	if m.location != nil {
		fields = append(fields, hiringjob.FieldLocation)
	}
	if m.salary_type != nil {
		fields = append(fields, hiringjob.FieldSalaryType)
	}
	if m.salary_from != nil {
		fields = append(fields, hiringjob.FieldSalaryFrom)
	}
	if m.salary_to != nil {
		fields = append(fields, hiringjob.FieldSalaryTo)
	}
	if m.currency != nil {
		fields = append(fields, hiringjob.FieldCurrency)
	}
	if m.last_apply_date != nil {
		fields = append(fields, hiringjob.FieldLastApplyDate)
	}
	if m.priority != nil {
		fields = append(fields, hiringjob.FieldPriority)
	}
	if m.hiring_team_edge != nil {
		fields = append(fields, hiringjob.FieldHiringTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HiringJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hiringjob.FieldCreatedAt:
		return m.CreatedAt()
	case hiringjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case hiringjob.FieldDeletedAt:
		return m.DeletedAt()
	case hiringjob.FieldSlug:
		return m.Slug()
	case hiringjob.FieldName:
		return m.Name()
	case hiringjob.FieldDescription:
		return m.Description()
	case hiringjob.FieldAmount:
		return m.Amount()
	case hiringjob.FieldStatus:
		return m.Status()
	case hiringjob.FieldCreatedBy:
		return m.CreatedBy()
	case hiringjob.FieldTeamID:
		return m.TeamID()
	case hiringjob.FieldLocation:
		return m.Location()
	case hiringjob.FieldSalaryType:
		return m.SalaryType()
	case hiringjob.FieldSalaryFrom:
		return m.SalaryFrom()
	case hiringjob.FieldSalaryTo:
		return m.SalaryTo()
	case hiringjob.FieldCurrency:
		return m.Currency()
	case hiringjob.FieldLastApplyDate:
		return m.LastApplyDate()
	case hiringjob.FieldPriority:
		return m.Priority()
	case hiringjob.FieldHiringTeamID:
		return m.HiringTeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HiringJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hiringjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hiringjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hiringjob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hiringjob.FieldSlug:
		return m.OldSlug(ctx)
	case hiringjob.FieldName:
		return m.OldName(ctx)
	case hiringjob.FieldDescription:
		return m.OldDescription(ctx)
	case hiringjob.FieldAmount:
		return m.OldAmount(ctx)
	case hiringjob.FieldStatus:
		return m.OldStatus(ctx)
	case hiringjob.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hiringjob.FieldTeamID:
		return m.OldTeamID(ctx)
	case hiringjob.FieldLocation:
		return m.OldLocation(ctx)
	case hiringjob.FieldSalaryType:
		return m.OldSalaryType(ctx)
	case hiringjob.FieldSalaryFrom:
		return m.OldSalaryFrom(ctx)
	case hiringjob.FieldSalaryTo:
		return m.OldSalaryTo(ctx)
	case hiringjob.FieldCurrency:
		return m.OldCurrency(ctx)
	case hiringjob.FieldLastApplyDate:
		return m.OldLastApplyDate(ctx)
	case hiringjob.FieldPriority:
		return m.OldPriority(ctx)
	case hiringjob.FieldHiringTeamID:
		return m.OldHiringTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown HiringJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hiringjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hiringjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hiringjob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hiringjob.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case hiringjob.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hiringjob.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hiringjob.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case hiringjob.FieldStatus:
		v, ok := value.(hiringjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hiringjob.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hiringjob.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case hiringjob.FieldLocation:
		v, ok := value.(hiringjob.Location)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case hiringjob.FieldSalaryType:
		v, ok := value.(hiringjob.SalaryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryType(v)
		return nil
	case hiringjob.FieldSalaryFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryFrom(v)
		return nil
	case hiringjob.FieldSalaryTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryTo(v)
		return nil
	case hiringjob.FieldCurrency:
		v, ok := value.(hiringjob.Currency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case hiringjob.FieldLastApplyDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastApplyDate(v)
		return nil
	case hiringjob.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case hiringjob.FieldHiringTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiringTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown HiringJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HiringJobMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, hiringjob.FieldAmount)
	}
	if m.addsalary_from != nil {
		fields = append(fields, hiringjob.FieldSalaryFrom)
	}
	if m.addsalary_to != nil {
		fields = append(fields, hiringjob.FieldSalaryTo)
	}
	if m.addpriority != nil {
		fields = append(fields, hiringjob.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HiringJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hiringjob.FieldAmount:
		return m.AddedAmount()
	case hiringjob.FieldSalaryFrom:
		return m.AddedSalaryFrom()
	case hiringjob.FieldSalaryTo:
		return m.AddedSalaryTo()
	case hiringjob.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hiringjob.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case hiringjob.FieldSalaryFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryFrom(v)
		return nil
	case hiringjob.FieldSalaryTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryTo(v)
		return nil
	case hiringjob.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown HiringJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HiringJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hiringjob.FieldUpdatedAt) {
		fields = append(fields, hiringjob.FieldUpdatedAt)
	}
	if m.FieldCleared(hiringjob.FieldDeletedAt) {
		fields = append(fields, hiringjob.FieldDeletedAt)
	}
	if m.FieldCleared(hiringjob.FieldCreatedBy) {
		fields = append(fields, hiringjob.FieldCreatedBy)
	}
	if m.FieldCleared(hiringjob.FieldTeamID) {
		fields = append(fields, hiringjob.FieldTeamID)
	}
	if m.FieldCleared(hiringjob.FieldLastApplyDate) {
		fields = append(fields, hiringjob.FieldLastApplyDate)
	}
	if m.FieldCleared(hiringjob.FieldHiringTeamID) {
		fields = append(fields, hiringjob.FieldHiringTeamID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HiringJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HiringJobMutation) ClearField(name string) error {
	switch name {
	case hiringjob.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hiringjob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case hiringjob.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case hiringjob.FieldTeamID:
		m.ClearTeamID()
		return nil
	case hiringjob.FieldLastApplyDate:
		m.ClearLastApplyDate()
		return nil
	case hiringjob.FieldHiringTeamID:
		m.ClearHiringTeamID()
		return nil
	}
	return fmt.Errorf("unknown HiringJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HiringJobMutation) ResetField(name string) error {
	switch name {
	case hiringjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hiringjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hiringjob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hiringjob.FieldSlug:
		m.ResetSlug()
		return nil
	case hiringjob.FieldName:
		m.ResetName()
		return nil
	case hiringjob.FieldDescription:
		m.ResetDescription()
		return nil
	case hiringjob.FieldAmount:
		m.ResetAmount()
		return nil
	case hiringjob.FieldStatus:
		m.ResetStatus()
		return nil
	case hiringjob.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hiringjob.FieldTeamID:
		m.ResetTeamID()
		return nil
	case hiringjob.FieldLocation:
		m.ResetLocation()
		return nil
	case hiringjob.FieldSalaryType:
		m.ResetSalaryType()
		return nil
	case hiringjob.FieldSalaryFrom:
		m.ResetSalaryFrom()
		return nil
	case hiringjob.FieldSalaryTo:
		m.ResetSalaryTo()
		return nil
	case hiringjob.FieldCurrency:
		m.ResetCurrency()
		return nil
	case hiringjob.FieldLastApplyDate:
		m.ResetLastApplyDate()
		return nil
	case hiringjob.FieldPriority:
		m.ResetPriority()
		return nil
	case hiringjob.FieldHiringTeamID:
		m.ResetHiringTeamID()
		return nil
	}
	return fmt.Errorf("unknown HiringJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HiringJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner_edge != nil {
		edges = append(edges, hiringjob.EdgeOwnerEdge)
	}
	if m.team_edge != nil {
		edges = append(edges, hiringjob.EdgeTeamEdge)
	}
	if m.candidate_job_edges != nil {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	if m.hiring_job_skill_edges != nil {
		edges = append(edges, hiringjob.EdgeHiringJobSkillEdges)
	}
	if m.hiring_team_edge != nil {
		edges = append(edges, hiringjob.EdgeHiringTeamEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HiringJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		if id := m.owner_edge; id != nil {
			return []ent.Value{*id}
		}
	case hiringjob.EdgeTeamEdge:
		if id := m.team_edge; id != nil {
			return []ent.Value{*id}
		}
	case hiringjob.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.candidate_job_edges))
		for id := range m.candidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case hiringjob.EdgeHiringJobSkillEdges:
		ids := make([]ent.Value, 0, len(m.hiring_job_skill_edges))
		for id := range m.hiring_job_skill_edges {
			ids = append(ids, id)
		}
		return ids
	case hiringjob.EdgeHiringTeamEdge:
		if id := m.hiring_team_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HiringJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcandidate_job_edges != nil {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	if m.removedhiring_job_skill_edges != nil {
		edges = append(edges, hiringjob.EdgeHiringJobSkillEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HiringJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hiringjob.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_edges))
		for id := range m.removedcandidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case hiringjob.EdgeHiringJobSkillEdges:
		ids := make([]ent.Value, 0, len(m.removedhiring_job_skill_edges))
		for id := range m.removedhiring_job_skill_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HiringJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner_edge {
		edges = append(edges, hiringjob.EdgeOwnerEdge)
	}
	if m.clearedteam_edge {
		edges = append(edges, hiringjob.EdgeTeamEdge)
	}
	if m.clearedcandidate_job_edges {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	if m.clearedhiring_job_skill_edges {
		edges = append(edges, hiringjob.EdgeHiringJobSkillEdges)
	}
	if m.clearedhiring_team_edge {
		edges = append(edges, hiringjob.EdgeHiringTeamEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HiringJobMutation) EdgeCleared(name string) bool {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		return m.clearedowner_edge
	case hiringjob.EdgeTeamEdge:
		return m.clearedteam_edge
	case hiringjob.EdgeCandidateJobEdges:
		return m.clearedcandidate_job_edges
	case hiringjob.EdgeHiringJobSkillEdges:
		return m.clearedhiring_job_skill_edges
	case hiringjob.EdgeHiringTeamEdge:
		return m.clearedhiring_team_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HiringJobMutation) ClearEdge(name string) error {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		m.ClearOwnerEdge()
		return nil
	case hiringjob.EdgeTeamEdge:
		m.ClearTeamEdge()
		return nil
	case hiringjob.EdgeHiringTeamEdge:
		m.ClearHiringTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown HiringJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HiringJobMutation) ResetEdge(name string) error {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		m.ResetOwnerEdge()
		return nil
	case hiringjob.EdgeTeamEdge:
		m.ResetTeamEdge()
		return nil
	case hiringjob.EdgeCandidateJobEdges:
		m.ResetCandidateJobEdges()
		return nil
	case hiringjob.EdgeHiringJobSkillEdges:
		m.ResetHiringJobSkillEdges()
		return nil
	case hiringjob.EdgeHiringTeamEdge:
		m.ResetHiringTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown HiringJob edge %s", name)
}

// HiringTeamMutation represents an operation that mutates the HiringTeam nodes in the graph.
type HiringTeamMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	slug                         *string
	name                         *string
	clearedFields                map[string]struct{}
	user_edges                   map[uuid.UUID]struct{}
	removeduser_edges            map[uuid.UUID]struct{}
	cleareduser_edges            bool
	hiring_team_job_edges        map[uuid.UUID]struct{}
	removedhiring_team_job_edges map[uuid.UUID]struct{}
	clearedhiring_team_job_edges bool
	user_hiring_teams            map[uuid.UUID]struct{}
	removeduser_hiring_teams     map[uuid.UUID]struct{}
	cleareduser_hiring_teams     bool
	done                         bool
	oldValue                     func(context.Context) (*HiringTeam, error)
	predicates                   []predicate.HiringTeam
}

var _ ent.Mutation = (*HiringTeamMutation)(nil)

// hiringteamOption allows management of the mutation configuration using functional options.
type hiringteamOption func(*HiringTeamMutation)

// newHiringTeamMutation creates new mutation for the HiringTeam entity.
func newHiringTeamMutation(c config, op Op, opts ...hiringteamOption) *HiringTeamMutation {
	m := &HiringTeamMutation{
		config:        c,
		op:            op,
		typ:           TypeHiringTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHiringTeamID sets the ID field of the mutation.
func withHiringTeamID(id uuid.UUID) hiringteamOption {
	return func(m *HiringTeamMutation) {
		var (
			err   error
			once  sync.Once
			value *HiringTeam
		)
		m.oldValue = func(ctx context.Context) (*HiringTeam, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HiringTeam.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHiringTeam sets the old HiringTeam of the mutation.
func withHiringTeam(node *HiringTeam) hiringteamOption {
	return func(m *HiringTeamMutation) {
		m.oldValue = func(context.Context) (*HiringTeam, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HiringTeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HiringTeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HiringTeam entities.
func (m *HiringTeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HiringTeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HiringTeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HiringTeam.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HiringTeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HiringTeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HiringTeam entity.
// If the HiringTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HiringTeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HiringTeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HiringTeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HiringTeam entity.
// If the HiringTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HiringTeamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hiringteam.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HiringTeamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hiringteam.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HiringTeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hiringteam.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HiringTeamMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HiringTeamMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HiringTeam entity.
// If the HiringTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HiringTeamMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hiringteam.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HiringTeamMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hiringteam.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HiringTeamMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hiringteam.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *HiringTeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *HiringTeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the HiringTeam entity.
// If the HiringTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *HiringTeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *HiringTeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HiringTeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HiringTeam entity.
// If the HiringTeam object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HiringTeamMutation) ResetName() {
	m.name = nil
}

// AddUserEdgeIDs adds the "user_edges" edge to the User entity by ids.
func (m *HiringTeamMutation) AddUserEdgeIDs(ids ...uuid.UUID) {
	if m.user_edges == nil {
		m.user_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_edges[ids[i]] = struct{}{}
	}
}

// ClearUserEdges clears the "user_edges" edge to the User entity.
func (m *HiringTeamMutation) ClearUserEdges() {
	m.cleareduser_edges = true
}

// UserEdgesCleared reports if the "user_edges" edge to the User entity was cleared.
func (m *HiringTeamMutation) UserEdgesCleared() bool {
	return m.cleareduser_edges
}

// RemoveUserEdgeIDs removes the "user_edges" edge to the User entity by IDs.
func (m *HiringTeamMutation) RemoveUserEdgeIDs(ids ...uuid.UUID) {
	if m.removeduser_edges == nil {
		m.removeduser_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_edges, ids[i])
		m.removeduser_edges[ids[i]] = struct{}{}
	}
}

// RemovedUserEdges returns the removed IDs of the "user_edges" edge to the User entity.
func (m *HiringTeamMutation) RemovedUserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_edges {
		ids = append(ids, id)
	}
	return
}

// UserEdgesIDs returns the "user_edges" edge IDs in the mutation.
func (m *HiringTeamMutation) UserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.user_edges {
		ids = append(ids, id)
	}
	return
}

// ResetUserEdges resets all changes to the "user_edges" edge.
func (m *HiringTeamMutation) ResetUserEdges() {
	m.user_edges = nil
	m.cleareduser_edges = false
	m.removeduser_edges = nil
}

// AddHiringTeamJobEdgeIDs adds the "hiring_team_job_edges" edge to the HiringJob entity by ids.
func (m *HiringTeamMutation) AddHiringTeamJobEdgeIDs(ids ...uuid.UUID) {
	if m.hiring_team_job_edges == nil {
		m.hiring_team_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_team_job_edges[ids[i]] = struct{}{}
	}
}

// ClearHiringTeamJobEdges clears the "hiring_team_job_edges" edge to the HiringJob entity.
func (m *HiringTeamMutation) ClearHiringTeamJobEdges() {
	m.clearedhiring_team_job_edges = true
}

// HiringTeamJobEdgesCleared reports if the "hiring_team_job_edges" edge to the HiringJob entity was cleared.
func (m *HiringTeamMutation) HiringTeamJobEdgesCleared() bool {
	return m.clearedhiring_team_job_edges
}

// RemoveHiringTeamJobEdgeIDs removes the "hiring_team_job_edges" edge to the HiringJob entity by IDs.
func (m *HiringTeamMutation) RemoveHiringTeamJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedhiring_team_job_edges == nil {
		m.removedhiring_team_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_team_job_edges, ids[i])
		m.removedhiring_team_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedHiringTeamJobEdges returns the removed IDs of the "hiring_team_job_edges" edge to the HiringJob entity.
func (m *HiringTeamMutation) RemovedHiringTeamJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_team_job_edges {
		ids = append(ids, id)
	}
	return
}

// HiringTeamJobEdgesIDs returns the "hiring_team_job_edges" edge IDs in the mutation.
func (m *HiringTeamMutation) HiringTeamJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.hiring_team_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetHiringTeamJobEdges resets all changes to the "hiring_team_job_edges" edge.
func (m *HiringTeamMutation) ResetHiringTeamJobEdges() {
	m.hiring_team_job_edges = nil
	m.clearedhiring_team_job_edges = false
	m.removedhiring_team_job_edges = nil
}

// AddUserHiringTeamIDs adds the "user_hiring_teams" edge to the HiringTeamManager entity by ids.
func (m *HiringTeamMutation) AddUserHiringTeamIDs(ids ...uuid.UUID) {
	if m.user_hiring_teams == nil {
		m.user_hiring_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_hiring_teams[ids[i]] = struct{}{}
	}
}

// ClearUserHiringTeams clears the "user_hiring_teams" edge to the HiringTeamManager entity.
func (m *HiringTeamMutation) ClearUserHiringTeams() {
	m.cleareduser_hiring_teams = true
}

// UserHiringTeamsCleared reports if the "user_hiring_teams" edge to the HiringTeamManager entity was cleared.
func (m *HiringTeamMutation) UserHiringTeamsCleared() bool {
	return m.cleareduser_hiring_teams
}

// RemoveUserHiringTeamIDs removes the "user_hiring_teams" edge to the HiringTeamManager entity by IDs.
func (m *HiringTeamMutation) RemoveUserHiringTeamIDs(ids ...uuid.UUID) {
	if m.removeduser_hiring_teams == nil {
		m.removeduser_hiring_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_hiring_teams, ids[i])
		m.removeduser_hiring_teams[ids[i]] = struct{}{}
	}
}

// RemovedUserHiringTeams returns the removed IDs of the "user_hiring_teams" edge to the HiringTeamManager entity.
func (m *HiringTeamMutation) RemovedUserHiringTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_hiring_teams {
		ids = append(ids, id)
	}
	return
}

// UserHiringTeamsIDs returns the "user_hiring_teams" edge IDs in the mutation.
func (m *HiringTeamMutation) UserHiringTeamsIDs() (ids []uuid.UUID) {
	for id := range m.user_hiring_teams {
		ids = append(ids, id)
	}
	return
}

// ResetUserHiringTeams resets all changes to the "user_hiring_teams" edge.
func (m *HiringTeamMutation) ResetUserHiringTeams() {
	m.user_hiring_teams = nil
	m.cleareduser_hiring_teams = false
	m.removeduser_hiring_teams = nil
}

// Where appends a list predicates to the HiringTeamMutation builder.
func (m *HiringTeamMutation) Where(ps ...predicate.HiringTeam) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HiringTeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HiringTeam).
func (m *HiringTeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HiringTeamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, hiringteam.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hiringteam.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hiringteam.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, hiringteam.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, hiringteam.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HiringTeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hiringteam.FieldCreatedAt:
		return m.CreatedAt()
	case hiringteam.FieldUpdatedAt:
		return m.UpdatedAt()
	case hiringteam.FieldDeletedAt:
		return m.DeletedAt()
	case hiringteam.FieldSlug:
		return m.Slug()
	case hiringteam.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HiringTeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hiringteam.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hiringteam.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hiringteam.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hiringteam.FieldSlug:
		return m.OldSlug(ctx)
	case hiringteam.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown HiringTeam field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringTeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hiringteam.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hiringteam.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hiringteam.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hiringteam.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case hiringteam.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown HiringTeam field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HiringTeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HiringTeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringTeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HiringTeam numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HiringTeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hiringteam.FieldUpdatedAt) {
		fields = append(fields, hiringteam.FieldUpdatedAt)
	}
	if m.FieldCleared(hiringteam.FieldDeletedAt) {
		fields = append(fields, hiringteam.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HiringTeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HiringTeamMutation) ClearField(name string) error {
	switch name {
	case hiringteam.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hiringteam.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown HiringTeam nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HiringTeamMutation) ResetField(name string) error {
	switch name {
	case hiringteam.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hiringteam.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hiringteam.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hiringteam.FieldSlug:
		m.ResetSlug()
		return nil
	case hiringteam.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown HiringTeam field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HiringTeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user_edges != nil {
		edges = append(edges, hiringteam.EdgeUserEdges)
	}
	if m.hiring_team_job_edges != nil {
		edges = append(edges, hiringteam.EdgeHiringTeamJobEdges)
	}
	if m.user_hiring_teams != nil {
		edges = append(edges, hiringteam.EdgeUserHiringTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HiringTeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hiringteam.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.user_edges))
		for id := range m.user_edges {
			ids = append(ids, id)
		}
		return ids
	case hiringteam.EdgeHiringTeamJobEdges:
		ids := make([]ent.Value, 0, len(m.hiring_team_job_edges))
		for id := range m.hiring_team_job_edges {
			ids = append(ids, id)
		}
		return ids
	case hiringteam.EdgeUserHiringTeams:
		ids := make([]ent.Value, 0, len(m.user_hiring_teams))
		for id := range m.user_hiring_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HiringTeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_edges != nil {
		edges = append(edges, hiringteam.EdgeUserEdges)
	}
	if m.removedhiring_team_job_edges != nil {
		edges = append(edges, hiringteam.EdgeHiringTeamJobEdges)
	}
	if m.removeduser_hiring_teams != nil {
		edges = append(edges, hiringteam.EdgeUserHiringTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HiringTeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hiringteam.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.removeduser_edges))
		for id := range m.removeduser_edges {
			ids = append(ids, id)
		}
		return ids
	case hiringteam.EdgeHiringTeamJobEdges:
		ids := make([]ent.Value, 0, len(m.removedhiring_team_job_edges))
		for id := range m.removedhiring_team_job_edges {
			ids = append(ids, id)
		}
		return ids
	case hiringteam.EdgeUserHiringTeams:
		ids := make([]ent.Value, 0, len(m.removeduser_hiring_teams))
		for id := range m.removeduser_hiring_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HiringTeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser_edges {
		edges = append(edges, hiringteam.EdgeUserEdges)
	}
	if m.clearedhiring_team_job_edges {
		edges = append(edges, hiringteam.EdgeHiringTeamJobEdges)
	}
	if m.cleareduser_hiring_teams {
		edges = append(edges, hiringteam.EdgeUserHiringTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HiringTeamMutation) EdgeCleared(name string) bool {
	switch name {
	case hiringteam.EdgeUserEdges:
		return m.cleareduser_edges
	case hiringteam.EdgeHiringTeamJobEdges:
		return m.clearedhiring_team_job_edges
	case hiringteam.EdgeUserHiringTeams:
		return m.cleareduser_hiring_teams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HiringTeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HiringTeam unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HiringTeamMutation) ResetEdge(name string) error {
	switch name {
	case hiringteam.EdgeUserEdges:
		m.ResetUserEdges()
		return nil
	case hiringteam.EdgeHiringTeamJobEdges:
		m.ResetHiringTeamJobEdges()
		return nil
	case hiringteam.EdgeUserHiringTeams:
		m.ResetUserHiringTeams()
		return nil
	}
	return fmt.Errorf("unknown HiringTeam edge %s", name)
}

// HiringTeamManagerMutation represents an operation that mutates the HiringTeamManager nodes in the graph.
type HiringTeamManagerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	clearedFields           map[string]struct{}
	user_edge               *uuid.UUID
	cleareduser_edge        bool
	hiring_team_edge        *uuid.UUID
	clearedhiring_team_edge bool
	done                    bool
	oldValue                func(context.Context) (*HiringTeamManager, error)
	predicates              []predicate.HiringTeamManager
}

var _ ent.Mutation = (*HiringTeamManagerMutation)(nil)

// hiringteammanagerOption allows management of the mutation configuration using functional options.
type hiringteammanagerOption func(*HiringTeamManagerMutation)

// newHiringTeamManagerMutation creates new mutation for the HiringTeamManager entity.
func newHiringTeamManagerMutation(c config, op Op, opts ...hiringteammanagerOption) *HiringTeamManagerMutation {
	m := &HiringTeamManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeHiringTeamManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHiringTeamManagerID sets the ID field of the mutation.
func withHiringTeamManagerID(id uuid.UUID) hiringteammanagerOption {
	return func(m *HiringTeamManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *HiringTeamManager
		)
		m.oldValue = func(ctx context.Context) (*HiringTeamManager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HiringTeamManager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHiringTeamManager sets the old HiringTeamManager of the mutation.
func withHiringTeamManager(node *HiringTeamManager) hiringteammanagerOption {
	return func(m *HiringTeamManagerMutation) {
		m.oldValue = func(context.Context) (*HiringTeamManager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HiringTeamManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HiringTeamManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HiringTeamManager entities.
func (m *HiringTeamManagerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HiringTeamManagerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HiringTeamManagerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HiringTeamManager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HiringTeamManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HiringTeamManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HiringTeamManager entity.
// If the HiringTeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HiringTeamManagerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HiringTeamManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HiringTeamManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HiringTeamManager entity.
// If the HiringTeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HiringTeamManagerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hiringteammanager.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HiringTeamManagerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hiringteammanager.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HiringTeamManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hiringteammanager.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HiringTeamManagerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HiringTeamManagerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HiringTeamManager entity.
// If the HiringTeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamManagerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HiringTeamManagerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hiringteammanager.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HiringTeamManagerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hiringteammanager.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HiringTeamManagerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hiringteammanager.FieldDeletedAt)
}

// SetHiringTeamID sets the "hiring_team_id" field.
func (m *HiringTeamManagerMutation) SetHiringTeamID(u uuid.UUID) {
	m.hiring_team_edge = &u
}

// HiringTeamID returns the value of the "hiring_team_id" field in the mutation.
func (m *HiringTeamManagerMutation) HiringTeamID() (r uuid.UUID, exists bool) {
	v := m.hiring_team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldHiringTeamID returns the old "hiring_team_id" field's value of the HiringTeamManager entity.
// If the HiringTeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamManagerMutation) OldHiringTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHiringTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHiringTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiringTeamID: %w", err)
	}
	return oldValue.HiringTeamID, nil
}

// ResetHiringTeamID resets all changes to the "hiring_team_id" field.
func (m *HiringTeamManagerMutation) ResetHiringTeamID() {
	m.hiring_team_edge = nil
}

// SetUserID sets the "user_id" field.
func (m *HiringTeamManagerMutation) SetUserID(u uuid.UUID) {
	m.user_edge = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *HiringTeamManagerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the HiringTeamManager entity.
// If the HiringTeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringTeamManagerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *HiringTeamManagerMutation) ResetUserID() {
	m.user_edge = nil
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *HiringTeamManagerMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *HiringTeamManagerMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *HiringTeamManagerMutation) UserEdgeCleared() bool {
	return m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *HiringTeamManagerMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringTeamManagerMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *HiringTeamManagerMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetHiringTeamEdgeID sets the "hiring_team_edge" edge to the HiringTeam entity by id.
func (m *HiringTeamManagerMutation) SetHiringTeamEdgeID(id uuid.UUID) {
	m.hiring_team_edge = &id
}

// ClearHiringTeamEdge clears the "hiring_team_edge" edge to the HiringTeam entity.
func (m *HiringTeamManagerMutation) ClearHiringTeamEdge() {
	m.clearedhiring_team_edge = true
}

// HiringTeamEdgeCleared reports if the "hiring_team_edge" edge to the HiringTeam entity was cleared.
func (m *HiringTeamManagerMutation) HiringTeamEdgeCleared() bool {
	return m.clearedhiring_team_edge
}

// HiringTeamEdgeID returns the "hiring_team_edge" edge ID in the mutation.
func (m *HiringTeamManagerMutation) HiringTeamEdgeID() (id uuid.UUID, exists bool) {
	if m.hiring_team_edge != nil {
		return *m.hiring_team_edge, true
	}
	return
}

// HiringTeamEdgeIDs returns the "hiring_team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HiringTeamEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringTeamManagerMutation) HiringTeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.hiring_team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHiringTeamEdge resets all changes to the "hiring_team_edge" edge.
func (m *HiringTeamManagerMutation) ResetHiringTeamEdge() {
	m.hiring_team_edge = nil
	m.clearedhiring_team_edge = false
}

// Where appends a list predicates to the HiringTeamManagerMutation builder.
func (m *HiringTeamManagerMutation) Where(ps ...predicate.HiringTeamManager) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HiringTeamManagerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HiringTeamManager).
func (m *HiringTeamManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HiringTeamManagerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, hiringteammanager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hiringteammanager.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hiringteammanager.FieldDeletedAt)
	}
	if m.hiring_team_edge != nil {
		fields = append(fields, hiringteammanager.FieldHiringTeamID)
	}
	if m.user_edge != nil {
		fields = append(fields, hiringteammanager.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HiringTeamManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hiringteammanager.FieldCreatedAt:
		return m.CreatedAt()
	case hiringteammanager.FieldUpdatedAt:
		return m.UpdatedAt()
	case hiringteammanager.FieldDeletedAt:
		return m.DeletedAt()
	case hiringteammanager.FieldHiringTeamID:
		return m.HiringTeamID()
	case hiringteammanager.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HiringTeamManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hiringteammanager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hiringteammanager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hiringteammanager.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hiringteammanager.FieldHiringTeamID:
		return m.OldHiringTeamID(ctx)
	case hiringteammanager.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown HiringTeamManager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringTeamManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hiringteammanager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hiringteammanager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hiringteammanager.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hiringteammanager.FieldHiringTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiringTeamID(v)
		return nil
	case hiringteammanager.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown HiringTeamManager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HiringTeamManagerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HiringTeamManagerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringTeamManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HiringTeamManager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HiringTeamManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hiringteammanager.FieldUpdatedAt) {
		fields = append(fields, hiringteammanager.FieldUpdatedAt)
	}
	if m.FieldCleared(hiringteammanager.FieldDeletedAt) {
		fields = append(fields, hiringteammanager.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HiringTeamManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HiringTeamManagerMutation) ClearField(name string) error {
	switch name {
	case hiringteammanager.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hiringteammanager.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown HiringTeamManager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HiringTeamManagerMutation) ResetField(name string) error {
	switch name {
	case hiringteammanager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hiringteammanager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hiringteammanager.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hiringteammanager.FieldHiringTeamID:
		m.ResetHiringTeamID()
		return nil
	case hiringteammanager.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown HiringTeamManager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HiringTeamManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_edge != nil {
		edges = append(edges, hiringteammanager.EdgeUserEdge)
	}
	if m.hiring_team_edge != nil {
		edges = append(edges, hiringteammanager.EdgeHiringTeamEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HiringTeamManagerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hiringteammanager.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case hiringteammanager.EdgeHiringTeamEdge:
		if id := m.hiring_team_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HiringTeamManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HiringTeamManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HiringTeamManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_edge {
		edges = append(edges, hiringteammanager.EdgeUserEdge)
	}
	if m.clearedhiring_team_edge {
		edges = append(edges, hiringteammanager.EdgeHiringTeamEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HiringTeamManagerMutation) EdgeCleared(name string) bool {
	switch name {
	case hiringteammanager.EdgeUserEdge:
		return m.cleareduser_edge
	case hiringteammanager.EdgeHiringTeamEdge:
		return m.clearedhiring_team_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HiringTeamManagerMutation) ClearEdge(name string) error {
	switch name {
	case hiringteammanager.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case hiringteammanager.EdgeHiringTeamEdge:
		m.ClearHiringTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown HiringTeamManager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HiringTeamManagerMutation) ResetEdge(name string) error {
	switch name {
	case hiringteammanager.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case hiringteammanager.EdgeHiringTeamEdge:
		m.ResetHiringTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown HiringTeamManager edge %s", name)
}

// JobPositionMutation represents an operation that mutates the JobPosition nodes in the graph.
type JobPositionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*JobPosition, error)
	predicates    []predicate.JobPosition
}

var _ ent.Mutation = (*JobPositionMutation)(nil)

// jobpositionOption allows management of the mutation configuration using functional options.
type jobpositionOption func(*JobPositionMutation)

// newJobPositionMutation creates new mutation for the JobPosition entity.
func newJobPositionMutation(c config, op Op, opts ...jobpositionOption) *JobPositionMutation {
	m := &JobPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeJobPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobPositionID sets the ID field of the mutation.
func withJobPositionID(id uuid.UUID) jobpositionOption {
	return func(m *JobPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *JobPosition
		)
		m.oldValue = func(ctx context.Context) (*JobPosition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobPosition sets the old JobPosition of the mutation.
func withJobPosition(node *JobPosition) jobpositionOption {
	return func(m *JobPositionMutation) {
		m.oldValue = func(context.Context) (*JobPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobPosition entities.
func (m *JobPositionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobPositionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobPositionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobPosition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobPositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobPositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobPositionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobPositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobPositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *JobPositionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[jobposition.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *JobPositionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobPositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, jobposition.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobPositionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobPositionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobPositionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[jobposition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobPositionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobPositionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, jobposition.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *JobPositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JobPositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JobPositionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *JobPositionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobPositionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JobPosition entity.
// If the JobPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPositionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *JobPositionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[jobposition.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *JobPositionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[jobposition.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *JobPositionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, jobposition.FieldDescription)
}

// Where appends a list predicates to the JobPositionMutation builder.
func (m *JobPositionMutation) Where(ps ...predicate.JobPosition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *JobPositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (JobPosition).
func (m *JobPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobPositionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, jobposition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobposition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, jobposition.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, jobposition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, jobposition.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobposition.FieldCreatedAt:
		return m.CreatedAt()
	case jobposition.FieldUpdatedAt:
		return m.UpdatedAt()
	case jobposition.FieldDeletedAt:
		return m.DeletedAt()
	case jobposition.FieldName:
		return m.Name()
	case jobposition.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobposition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobposition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case jobposition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case jobposition.FieldName:
		return m.OldName(ctx)
	case jobposition.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown JobPosition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobposition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobposition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case jobposition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case jobposition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobposition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown JobPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobPositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobPositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobposition.FieldUpdatedAt) {
		fields = append(fields, jobposition.FieldUpdatedAt)
	}
	if m.FieldCleared(jobposition.FieldDeletedAt) {
		fields = append(fields, jobposition.FieldDeletedAt)
	}
	if m.FieldCleared(jobposition.FieldDescription) {
		fields = append(fields, jobposition.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobPositionMutation) ClearField(name string) error {
	switch name {
	case jobposition.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case jobposition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case jobposition.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown JobPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobPositionMutation) ResetField(name string) error {
	switch name {
	case jobposition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobposition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case jobposition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case jobposition.FieldName:
		m.ResetName()
		return nil
	case jobposition.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown JobPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobPositionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobPositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobPositionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobPositionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown JobPosition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobPositionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown JobPosition edge %s", name)
}

// OutgoingEmailMutation represents an operation that mutates the OutgoingEmail nodes in the graph.
type OutgoingEmailMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	to                *[]string
	appendto          []string
	cc                *[]string
	appendcc          []string
	bcc               *[]string
	appendbcc         []string
	subject           *string
	content           *string
	signature         *string
	email_template_id *uuid.UUID
	status            *outgoingemail.Status
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*OutgoingEmail, error)
	predicates        []predicate.OutgoingEmail
}

var _ ent.Mutation = (*OutgoingEmailMutation)(nil)

// outgoingemailOption allows management of the mutation configuration using functional options.
type outgoingemailOption func(*OutgoingEmailMutation)

// newOutgoingEmailMutation creates new mutation for the OutgoingEmail entity.
func newOutgoingEmailMutation(c config, op Op, opts ...outgoingemailOption) *OutgoingEmailMutation {
	m := &OutgoingEmailMutation{
		config:        c,
		op:            op,
		typ:           TypeOutgoingEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutgoingEmailID sets the ID field of the mutation.
func withOutgoingEmailID(id uuid.UUID) outgoingemailOption {
	return func(m *OutgoingEmailMutation) {
		var (
			err   error
			once  sync.Once
			value *OutgoingEmail
		)
		m.oldValue = func(ctx context.Context) (*OutgoingEmail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutgoingEmail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutgoingEmail sets the old OutgoingEmail of the mutation.
func withOutgoingEmail(node *OutgoingEmail) outgoingemailOption {
	return func(m *OutgoingEmailMutation) {
		m.oldValue = func(context.Context) (*OutgoingEmail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutgoingEmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutgoingEmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OutgoingEmail entities.
func (m *OutgoingEmailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutgoingEmailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutgoingEmailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutgoingEmail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OutgoingEmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OutgoingEmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OutgoingEmailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OutgoingEmailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OutgoingEmailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OutgoingEmailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[outgoingemail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OutgoingEmailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[outgoingemail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OutgoingEmailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, outgoingemail.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OutgoingEmailMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OutgoingEmailMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OutgoingEmailMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[outgoingemail.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OutgoingEmailMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[outgoingemail.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OutgoingEmailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, outgoingemail.FieldDeletedAt)
}

// SetTo sets the "to" field.
func (m *OutgoingEmailMutation) SetTo(s []string) {
	m.to = &s
	m.appendto = nil
}

// To returns the value of the "to" field in the mutation.
func (m *OutgoingEmailMutation) To() (r []string, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldTo(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// AppendTo adds s to the "to" field.
func (m *OutgoingEmailMutation) AppendTo(s []string) {
	m.appendto = append(m.appendto, s...)
}

// AppendedTo returns the list of values that were appended to the "to" field in this mutation.
func (m *OutgoingEmailMutation) AppendedTo() ([]string, bool) {
	if len(m.appendto) == 0 {
		return nil, false
	}
	return m.appendto, true
}

// ResetTo resets all changes to the "to" field.
func (m *OutgoingEmailMutation) ResetTo() {
	m.to = nil
	m.appendto = nil
}

// SetCc sets the "cc" field.
func (m *OutgoingEmailMutation) SetCc(s []string) {
	m.cc = &s
	m.appendcc = nil
}

// Cc returns the value of the "cc" field in the mutation.
func (m *OutgoingEmailMutation) Cc() (r []string, exists bool) {
	v := m.cc
	if v == nil {
		return
	}
	return *v, true
}

// OldCc returns the old "cc" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldCc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCc: %w", err)
	}
	return oldValue.Cc, nil
}

// AppendCc adds s to the "cc" field.
func (m *OutgoingEmailMutation) AppendCc(s []string) {
	m.appendcc = append(m.appendcc, s...)
}

// AppendedCc returns the list of values that were appended to the "cc" field in this mutation.
func (m *OutgoingEmailMutation) AppendedCc() ([]string, bool) {
	if len(m.appendcc) == 0 {
		return nil, false
	}
	return m.appendcc, true
}

// ResetCc resets all changes to the "cc" field.
func (m *OutgoingEmailMutation) ResetCc() {
	m.cc = nil
	m.appendcc = nil
}

// SetBcc sets the "bcc" field.
func (m *OutgoingEmailMutation) SetBcc(s []string) {
	m.bcc = &s
	m.appendbcc = nil
}

// Bcc returns the value of the "bcc" field in the mutation.
func (m *OutgoingEmailMutation) Bcc() (r []string, exists bool) {
	v := m.bcc
	if v == nil {
		return
	}
	return *v, true
}

// OldBcc returns the old "bcc" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldBcc(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBcc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBcc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBcc: %w", err)
	}
	return oldValue.Bcc, nil
}

// AppendBcc adds s to the "bcc" field.
func (m *OutgoingEmailMutation) AppendBcc(s []string) {
	m.appendbcc = append(m.appendbcc, s...)
}

// AppendedBcc returns the list of values that were appended to the "bcc" field in this mutation.
func (m *OutgoingEmailMutation) AppendedBcc() ([]string, bool) {
	if len(m.appendbcc) == 0 {
		return nil, false
	}
	return m.appendbcc, true
}

// ResetBcc resets all changes to the "bcc" field.
func (m *OutgoingEmailMutation) ResetBcc() {
	m.bcc = nil
	m.appendbcc = nil
}

// SetSubject sets the "subject" field.
func (m *OutgoingEmailMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *OutgoingEmailMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *OutgoingEmailMutation) ResetSubject() {
	m.subject = nil
}

// SetContent sets the "content" field.
func (m *OutgoingEmailMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *OutgoingEmailMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *OutgoingEmailMutation) ResetContent() {
	m.content = nil
}

// SetSignature sets the "signature" field.
func (m *OutgoingEmailMutation) SetSignature(s string) {
	m.signature = &s
}

// Signature returns the value of the "signature" field in the mutation.
func (m *OutgoingEmailMutation) Signature() (r string, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ResetSignature resets all changes to the "signature" field.
func (m *OutgoingEmailMutation) ResetSignature() {
	m.signature = nil
}

// SetEmailTemplateID sets the "email_template_id" field.
func (m *OutgoingEmailMutation) SetEmailTemplateID(u uuid.UUID) {
	m.email_template_id = &u
}

// EmailTemplateID returns the value of the "email_template_id" field in the mutation.
func (m *OutgoingEmailMutation) EmailTemplateID() (r uuid.UUID, exists bool) {
	v := m.email_template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailTemplateID returns the old "email_template_id" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldEmailTemplateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailTemplateID: %w", err)
	}
	return oldValue.EmailTemplateID, nil
}

// ClearEmailTemplateID clears the value of the "email_template_id" field.
func (m *OutgoingEmailMutation) ClearEmailTemplateID() {
	m.email_template_id = nil
	m.clearedFields[outgoingemail.FieldEmailTemplateID] = struct{}{}
}

// EmailTemplateIDCleared returns if the "email_template_id" field was cleared in this mutation.
func (m *OutgoingEmailMutation) EmailTemplateIDCleared() bool {
	_, ok := m.clearedFields[outgoingemail.FieldEmailTemplateID]
	return ok
}

// ResetEmailTemplateID resets all changes to the "email_template_id" field.
func (m *OutgoingEmailMutation) ResetEmailTemplateID() {
	m.email_template_id = nil
	delete(m.clearedFields, outgoingemail.FieldEmailTemplateID)
}

// SetStatus sets the "status" field.
func (m *OutgoingEmailMutation) SetStatus(o outgoingemail.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OutgoingEmailMutation) Status() (r outgoingemail.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OutgoingEmail entity.
// If the OutgoingEmail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutgoingEmailMutation) OldStatus(ctx context.Context) (v outgoingemail.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OutgoingEmailMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the OutgoingEmailMutation builder.
func (m *OutgoingEmailMutation) Where(ps ...predicate.OutgoingEmail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutgoingEmailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutgoingEmail).
func (m *OutgoingEmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutgoingEmailMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, outgoingemail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, outgoingemail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, outgoingemail.FieldDeletedAt)
	}
	if m.to != nil {
		fields = append(fields, outgoingemail.FieldTo)
	}
	if m.cc != nil {
		fields = append(fields, outgoingemail.FieldCc)
	}
	if m.bcc != nil {
		fields = append(fields, outgoingemail.FieldBcc)
	}
	if m.subject != nil {
		fields = append(fields, outgoingemail.FieldSubject)
	}
	if m.content != nil {
		fields = append(fields, outgoingemail.FieldContent)
	}
	if m.signature != nil {
		fields = append(fields, outgoingemail.FieldSignature)
	}
	if m.email_template_id != nil {
		fields = append(fields, outgoingemail.FieldEmailTemplateID)
	}
	if m.status != nil {
		fields = append(fields, outgoingemail.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutgoingEmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outgoingemail.FieldCreatedAt:
		return m.CreatedAt()
	case outgoingemail.FieldUpdatedAt:
		return m.UpdatedAt()
	case outgoingemail.FieldDeletedAt:
		return m.DeletedAt()
	case outgoingemail.FieldTo:
		return m.To()
	case outgoingemail.FieldCc:
		return m.Cc()
	case outgoingemail.FieldBcc:
		return m.Bcc()
	case outgoingemail.FieldSubject:
		return m.Subject()
	case outgoingemail.FieldContent:
		return m.Content()
	case outgoingemail.FieldSignature:
		return m.Signature()
	case outgoingemail.FieldEmailTemplateID:
		return m.EmailTemplateID()
	case outgoingemail.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutgoingEmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outgoingemail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case outgoingemail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case outgoingemail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case outgoingemail.FieldTo:
		return m.OldTo(ctx)
	case outgoingemail.FieldCc:
		return m.OldCc(ctx)
	case outgoingemail.FieldBcc:
		return m.OldBcc(ctx)
	case outgoingemail.FieldSubject:
		return m.OldSubject(ctx)
	case outgoingemail.FieldContent:
		return m.OldContent(ctx)
	case outgoingemail.FieldSignature:
		return m.OldSignature(ctx)
	case outgoingemail.FieldEmailTemplateID:
		return m.OldEmailTemplateID(ctx)
	case outgoingemail.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OutgoingEmail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutgoingEmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outgoingemail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case outgoingemail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case outgoingemail.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case outgoingemail.FieldTo:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	case outgoingemail.FieldCc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCc(v)
		return nil
	case outgoingemail.FieldBcc:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBcc(v)
		return nil
	case outgoingemail.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case outgoingemail.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case outgoingemail.FieldSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case outgoingemail.FieldEmailTemplateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailTemplateID(v)
		return nil
	case outgoingemail.FieldStatus:
		v, ok := value.(outgoingemail.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OutgoingEmail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutgoingEmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutgoingEmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutgoingEmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutgoingEmail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutgoingEmailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(outgoingemail.FieldUpdatedAt) {
		fields = append(fields, outgoingemail.FieldUpdatedAt)
	}
	if m.FieldCleared(outgoingemail.FieldDeletedAt) {
		fields = append(fields, outgoingemail.FieldDeletedAt)
	}
	if m.FieldCleared(outgoingemail.FieldEmailTemplateID) {
		fields = append(fields, outgoingemail.FieldEmailTemplateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutgoingEmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutgoingEmailMutation) ClearField(name string) error {
	switch name {
	case outgoingemail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case outgoingemail.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case outgoingemail.FieldEmailTemplateID:
		m.ClearEmailTemplateID()
		return nil
	}
	return fmt.Errorf("unknown OutgoingEmail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutgoingEmailMutation) ResetField(name string) error {
	switch name {
	case outgoingemail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case outgoingemail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case outgoingemail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case outgoingemail.FieldTo:
		m.ResetTo()
		return nil
	case outgoingemail.FieldCc:
		m.ResetCc()
		return nil
	case outgoingemail.FieldBcc:
		m.ResetBcc()
		return nil
	case outgoingemail.FieldSubject:
		m.ResetSubject()
		return nil
	case outgoingemail.FieldContent:
		m.ResetContent()
		return nil
	case outgoingemail.FieldSignature:
		m.ResetSignature()
		return nil
	case outgoingemail.FieldEmailTemplateID:
		m.ResetEmailTemplateID()
		return nil
	case outgoingemail.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown OutgoingEmail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutgoingEmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutgoingEmailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutgoingEmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutgoingEmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutgoingEmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutgoingEmailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutgoingEmailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OutgoingEmail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutgoingEmailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OutgoingEmail edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	title                        *string
	for_owner                    *bool
	for_team                     *bool
	for_all                      *bool
	operation_name               *string
	parent_id                    *uuid.UUID
	order_id                     *int
	addorder_id                  *int
	clearedFields                map[string]struct{}
	group_permission_edge        *uuid.UUID
	clearedgroup_permission_edge bool
	user_permission_edge         map[uuid.UUID]struct{}
	removeduser_permission_edge  map[uuid.UUID]struct{}
	cleareduser_permission_edge  bool
	done                         bool
	oldValue                     func(context.Context) (*Permission, error)
	predicates                   []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id uuid.UUID) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permission.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permission.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *PermissionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PermissionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PermissionMutation) ResetTitle() {
	m.title = nil
}

// SetGroupID sets the "group_id" field.
func (m *PermissionMutation) SetGroupID(u uuid.UUID) {
	m.group_permission_edge = &u
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *PermissionMutation) GroupID() (r uuid.UUID, exists bool) {
	v := m.group_permission_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldGroupID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *PermissionMutation) ClearGroupID() {
	m.group_permission_edge = nil
	m.clearedFields[permission.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *PermissionMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *PermissionMutation) ResetGroupID() {
	m.group_permission_edge = nil
	delete(m.clearedFields, permission.FieldGroupID)
}

// SetForOwner sets the "for_owner" field.
func (m *PermissionMutation) SetForOwner(b bool) {
	m.for_owner = &b
}

// ForOwner returns the value of the "for_owner" field in the mutation.
func (m *PermissionMutation) ForOwner() (r bool, exists bool) {
	v := m.for_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldForOwner returns the old "for_owner" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldForOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForOwner: %w", err)
	}
	return oldValue.ForOwner, nil
}

// ResetForOwner resets all changes to the "for_owner" field.
func (m *PermissionMutation) ResetForOwner() {
	m.for_owner = nil
}

// SetForTeam sets the "for_team" field.
func (m *PermissionMutation) SetForTeam(b bool) {
	m.for_team = &b
}

// ForTeam returns the value of the "for_team" field in the mutation.
func (m *PermissionMutation) ForTeam() (r bool, exists bool) {
	v := m.for_team
	if v == nil {
		return
	}
	return *v, true
}

// OldForTeam returns the old "for_team" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldForTeam(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForTeam: %w", err)
	}
	return oldValue.ForTeam, nil
}

// ResetForTeam resets all changes to the "for_team" field.
func (m *PermissionMutation) ResetForTeam() {
	m.for_team = nil
}

// SetForAll sets the "for_all" field.
func (m *PermissionMutation) SetForAll(b bool) {
	m.for_all = &b
}

// ForAll returns the value of the "for_all" field in the mutation.
func (m *PermissionMutation) ForAll() (r bool, exists bool) {
	v := m.for_all
	if v == nil {
		return
	}
	return *v, true
}

// OldForAll returns the old "for_all" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldForAll(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForAll is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForAll requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForAll: %w", err)
	}
	return oldValue.ForAll, nil
}

// ResetForAll resets all changes to the "for_all" field.
func (m *PermissionMutation) ResetForAll() {
	m.for_all = nil
}

// SetOperationName sets the "operation_name" field.
func (m *PermissionMutation) SetOperationName(s string) {
	m.operation_name = &s
}

// OperationName returns the value of the "operation_name" field in the mutation.
func (m *PermissionMutation) OperationName() (r string, exists bool) {
	v := m.operation_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationName returns the old "operation_name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldOperationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationName: %w", err)
	}
	return oldValue.OperationName, nil
}

// ClearOperationName clears the value of the "operation_name" field.
func (m *PermissionMutation) ClearOperationName() {
	m.operation_name = nil
	m.clearedFields[permission.FieldOperationName] = struct{}{}
}

// OperationNameCleared returns if the "operation_name" field was cleared in this mutation.
func (m *PermissionMutation) OperationNameCleared() bool {
	_, ok := m.clearedFields[permission.FieldOperationName]
	return ok
}

// ResetOperationName resets all changes to the "operation_name" field.
func (m *PermissionMutation) ResetOperationName() {
	m.operation_name = nil
	delete(m.clearedFields, permission.FieldOperationName)
}

// SetParentID sets the "parent_id" field.
func (m *PermissionMutation) SetParentID(u uuid.UUID) {
	m.parent_id = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *PermissionMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *PermissionMutation) ClearParentID() {
	m.parent_id = nil
	m.clearedFields[permission.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *PermissionMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *PermissionMutation) ResetParentID() {
	m.parent_id = nil
	delete(m.clearedFields, permission.FieldParentID)
}

// SetOrderID sets the "order_id" field.
func (m *PermissionMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PermissionMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *PermissionMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *PermissionMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PermissionMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetGroupPermissionEdgeID sets the "group_permission_edge" edge to the PermissionGroup entity by id.
func (m *PermissionMutation) SetGroupPermissionEdgeID(id uuid.UUID) {
	m.group_permission_edge = &id
}

// ClearGroupPermissionEdge clears the "group_permission_edge" edge to the PermissionGroup entity.
func (m *PermissionMutation) ClearGroupPermissionEdge() {
	m.clearedgroup_permission_edge = true
}

// GroupPermissionEdgeCleared reports if the "group_permission_edge" edge to the PermissionGroup entity was cleared.
func (m *PermissionMutation) GroupPermissionEdgeCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup_permission_edge
}

// GroupPermissionEdgeID returns the "group_permission_edge" edge ID in the mutation.
func (m *PermissionMutation) GroupPermissionEdgeID() (id uuid.UUID, exists bool) {
	if m.group_permission_edge != nil {
		return *m.group_permission_edge, true
	}
	return
}

// GroupPermissionEdgeIDs returns the "group_permission_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupPermissionEdgeID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) GroupPermissionEdgeIDs() (ids []uuid.UUID) {
	if id := m.group_permission_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupPermissionEdge resets all changes to the "group_permission_edge" edge.
func (m *PermissionMutation) ResetGroupPermissionEdge() {
	m.group_permission_edge = nil
	m.clearedgroup_permission_edge = false
}

// AddUserPermissionEdgeIDs adds the "user_permission_edge" edge to the EntityPermission entity by ids.
func (m *PermissionMutation) AddUserPermissionEdgeIDs(ids ...uuid.UUID) {
	if m.user_permission_edge == nil {
		m.user_permission_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_permission_edge[ids[i]] = struct{}{}
	}
}

// ClearUserPermissionEdge clears the "user_permission_edge" edge to the EntityPermission entity.
func (m *PermissionMutation) ClearUserPermissionEdge() {
	m.cleareduser_permission_edge = true
}

// UserPermissionEdgeCleared reports if the "user_permission_edge" edge to the EntityPermission entity was cleared.
func (m *PermissionMutation) UserPermissionEdgeCleared() bool {
	return m.cleareduser_permission_edge
}

// RemoveUserPermissionEdgeIDs removes the "user_permission_edge" edge to the EntityPermission entity by IDs.
func (m *PermissionMutation) RemoveUserPermissionEdgeIDs(ids ...uuid.UUID) {
	if m.removeduser_permission_edge == nil {
		m.removeduser_permission_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_permission_edge, ids[i])
		m.removeduser_permission_edge[ids[i]] = struct{}{}
	}
}

// RemovedUserPermissionEdge returns the removed IDs of the "user_permission_edge" edge to the EntityPermission entity.
func (m *PermissionMutation) RemovedUserPermissionEdgeIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_permission_edge {
		ids = append(ids, id)
	}
	return
}

// UserPermissionEdgeIDs returns the "user_permission_edge" edge IDs in the mutation.
func (m *PermissionMutation) UserPermissionEdgeIDs() (ids []uuid.UUID) {
	for id := range m.user_permission_edge {
		ids = append(ids, id)
	}
	return
}

// ResetUserPermissionEdge resets all changes to the "user_permission_edge" edge.
func (m *PermissionMutation) ResetUserPermissionEdge() {
	m.user_permission_edge = nil
	m.cleareduser_permission_edge = false
	m.removeduser_permission_edge = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, permission.FieldTitle)
	}
	if m.group_permission_edge != nil {
		fields = append(fields, permission.FieldGroupID)
	}
	if m.for_owner != nil {
		fields = append(fields, permission.FieldForOwner)
	}
	if m.for_team != nil {
		fields = append(fields, permission.FieldForTeam)
	}
	if m.for_all != nil {
		fields = append(fields, permission.FieldForAll)
	}
	if m.operation_name != nil {
		fields = append(fields, permission.FieldOperationName)
	}
	if m.parent_id != nil {
		fields = append(fields, permission.FieldParentID)
	}
	if m.order_id != nil {
		fields = append(fields, permission.FieldOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldDeletedAt:
		return m.DeletedAt()
	case permission.FieldTitle:
		return m.Title()
	case permission.FieldGroupID:
		return m.GroupID()
	case permission.FieldForOwner:
		return m.ForOwner()
	case permission.FieldForTeam:
		return m.ForTeam()
	case permission.FieldForAll:
		return m.ForAll()
	case permission.FieldOperationName:
		return m.OperationName()
	case permission.FieldParentID:
		return m.ParentID()
	case permission.FieldOrderID:
		return m.OrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permission.FieldTitle:
		return m.OldTitle(ctx)
	case permission.FieldGroupID:
		return m.OldGroupID(ctx)
	case permission.FieldForOwner:
		return m.OldForOwner(ctx)
	case permission.FieldForTeam:
		return m.OldForTeam(ctx)
	case permission.FieldForAll:
		return m.OldForAll(ctx)
	case permission.FieldOperationName:
		return m.OldOperationName(ctx)
	case permission.FieldParentID:
		return m.OldParentID(ctx)
	case permission.FieldOrderID:
		return m.OldOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permission.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case permission.FieldGroupID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case permission.FieldForOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForOwner(v)
		return nil
	case permission.FieldForTeam:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForTeam(v)
		return nil
	case permission.FieldForAll:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForAll(v)
		return nil
	case permission.FieldOperationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationName(v)
		return nil
	case permission.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case permission.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, permission.FieldOrderID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldOrderID:
		return m.AddedOrderID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldUpdatedAt) {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.FieldCleared(permission.FieldDeletedAt) {
		fields = append(fields, permission.FieldDeletedAt)
	}
	if m.FieldCleared(permission.FieldGroupID) {
		fields = append(fields, permission.FieldGroupID)
	}
	if m.FieldCleared(permission.FieldOperationName) {
		fields = append(fields, permission.FieldOperationName)
	}
	if m.FieldCleared(permission.FieldParentID) {
		fields = append(fields, permission.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permission.FieldGroupID:
		m.ClearGroupID()
		return nil
	case permission.FieldOperationName:
		m.ClearOperationName()
		return nil
	case permission.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permission.FieldTitle:
		m.ResetTitle()
		return nil
	case permission.FieldGroupID:
		m.ResetGroupID()
		return nil
	case permission.FieldForOwner:
		m.ResetForOwner()
		return nil
	case permission.FieldForTeam:
		m.ResetForTeam()
		return nil
	case permission.FieldForAll:
		m.ResetForAll()
		return nil
	case permission.FieldOperationName:
		m.ResetOperationName()
		return nil
	case permission.FieldParentID:
		m.ResetParentID()
		return nil
	case permission.FieldOrderID:
		m.ResetOrderID()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group_permission_edge != nil {
		edges = append(edges, permission.EdgeGroupPermissionEdge)
	}
	if m.user_permission_edge != nil {
		edges = append(edges, permission.EdgeUserPermissionEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeGroupPermissionEdge:
		if id := m.group_permission_edge; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeUserPermissionEdge:
		ids := make([]ent.Value, 0, len(m.user_permission_edge))
		for id := range m.user_permission_edge {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_permission_edge != nil {
		edges = append(edges, permission.EdgeUserPermissionEdge)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeUserPermissionEdge:
		ids := make([]ent.Value, 0, len(m.removeduser_permission_edge))
		for id := range m.removeduser_permission_edge {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup_permission_edge {
		edges = append(edges, permission.EdgeGroupPermissionEdge)
	}
	if m.cleareduser_permission_edge {
		edges = append(edges, permission.EdgeUserPermissionEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeGroupPermissionEdge:
		return m.clearedgroup_permission_edge
	case permission.EdgeUserPermissionEdge:
		return m.cleareduser_permission_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeGroupPermissionEdge:
		m.ClearGroupPermissionEdge()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeGroupPermissionEdge:
		m.ResetGroupPermissionEdge()
		return nil
	case permission.EdgeUserPermissionEdge:
		m.ResetUserPermissionEdge()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// PermissionGroupMutation represents an operation that mutates the PermissionGroup nodes in the graph.
type PermissionGroupMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	title                            *string
	group_type                       *permissiongroup.GroupType
	order_id                         *int
	addorder_id                      *int
	clearedFields                    map[string]struct{}
	group_permission_parent          *uuid.UUID
	clearedgroup_permission_parent   bool
	group_permission_children        map[uuid.UUID]struct{}
	removedgroup_permission_children map[uuid.UUID]struct{}
	clearedgroup_permission_children bool
	permission_edges                 map[uuid.UUID]struct{}
	removedpermission_edges          map[uuid.UUID]struct{}
	clearedpermission_edges          bool
	done                             bool
	oldValue                         func(context.Context) (*PermissionGroup, error)
	predicates                       []predicate.PermissionGroup
}

var _ ent.Mutation = (*PermissionGroupMutation)(nil)

// permissiongroupOption allows management of the mutation configuration using functional options.
type permissiongroupOption func(*PermissionGroupMutation)

// newPermissionGroupMutation creates new mutation for the PermissionGroup entity.
func newPermissionGroupMutation(c config, op Op, opts ...permissiongroupOption) *PermissionGroupMutation {
	m := &PermissionGroupMutation{
		config:        c,
		op:            op,
		typ:           TypePermissionGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionGroupID sets the ID field of the mutation.
func withPermissionGroupID(id uuid.UUID) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *PermissionGroup
		)
		m.oldValue = func(ctx context.Context) (*PermissionGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PermissionGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermissionGroup sets the old PermissionGroup of the mutation.
func withPermissionGroup(node *PermissionGroup) permissiongroupOption {
	return func(m *PermissionGroupMutation) {
		m.oldValue = func(context.Context) (*PermissionGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PermissionGroup entities.
func (m *PermissionGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionGroupMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PermissionGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionGroupMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permissiongroup.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionGroupMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permissiongroup.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PermissionGroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PermissionGroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PermissionGroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[permissiongroup.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PermissionGroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PermissionGroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, permissiongroup.FieldDeletedAt)
}

// SetTitle sets the "title" field.
func (m *PermissionGroupMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PermissionGroupMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PermissionGroupMutation) ResetTitle() {
	m.title = nil
}

// SetParentID sets the "parent_id" field.
func (m *PermissionGroupMutation) SetParentID(u uuid.UUID) {
	m.group_permission_parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *PermissionGroupMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.group_permission_parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *PermissionGroupMutation) ClearParentID() {
	m.group_permission_parent = nil
	m.clearedFields[permissiongroup.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *PermissionGroupMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[permissiongroup.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *PermissionGroupMutation) ResetParentID() {
	m.group_permission_parent = nil
	delete(m.clearedFields, permissiongroup.FieldParentID)
}

// SetGroupType sets the "group_type" field.
func (m *PermissionGroupMutation) SetGroupType(pt permissiongroup.GroupType) {
	m.group_type = &pt
}

// GroupType returns the value of the "group_type" field in the mutation.
func (m *PermissionGroupMutation) GroupType() (r permissiongroup.GroupType, exists bool) {
	v := m.group_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupType returns the old "group_type" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldGroupType(ctx context.Context) (v permissiongroup.GroupType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupType: %w", err)
	}
	return oldValue.GroupType, nil
}

// ResetGroupType resets all changes to the "group_type" field.
func (m *PermissionGroupMutation) ResetGroupType() {
	m.group_type = nil
}

// SetOrderID sets the "order_id" field.
func (m *PermissionGroupMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PermissionGroupMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the PermissionGroup entity.
// If the PermissionGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionGroupMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *PermissionGroupMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *PermissionGroupMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PermissionGroupMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetGroupPermissionParentID sets the "group_permission_parent" edge to the PermissionGroup entity by id.
func (m *PermissionGroupMutation) SetGroupPermissionParentID(id uuid.UUID) {
	m.group_permission_parent = &id
}

// ClearGroupPermissionParent clears the "group_permission_parent" edge to the PermissionGroup entity.
func (m *PermissionGroupMutation) ClearGroupPermissionParent() {
	m.clearedgroup_permission_parent = true
}

// GroupPermissionParentCleared reports if the "group_permission_parent" edge to the PermissionGroup entity was cleared.
func (m *PermissionGroupMutation) GroupPermissionParentCleared() bool {
	return m.ParentIDCleared() || m.clearedgroup_permission_parent
}

// GroupPermissionParentID returns the "group_permission_parent" edge ID in the mutation.
func (m *PermissionGroupMutation) GroupPermissionParentID() (id uuid.UUID, exists bool) {
	if m.group_permission_parent != nil {
		return *m.group_permission_parent, true
	}
	return
}

// GroupPermissionParentIDs returns the "group_permission_parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupPermissionParentID instead. It exists only for internal usage by the builders.
func (m *PermissionGroupMutation) GroupPermissionParentIDs() (ids []uuid.UUID) {
	if id := m.group_permission_parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupPermissionParent resets all changes to the "group_permission_parent" edge.
func (m *PermissionGroupMutation) ResetGroupPermissionParent() {
	m.group_permission_parent = nil
	m.clearedgroup_permission_parent = false
}

// AddGroupPermissionChildIDs adds the "group_permission_children" edge to the PermissionGroup entity by ids.
func (m *PermissionGroupMutation) AddGroupPermissionChildIDs(ids ...uuid.UUID) {
	if m.group_permission_children == nil {
		m.group_permission_children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.group_permission_children[ids[i]] = struct{}{}
	}
}

// ClearGroupPermissionChildren clears the "group_permission_children" edge to the PermissionGroup entity.
func (m *PermissionGroupMutation) ClearGroupPermissionChildren() {
	m.clearedgroup_permission_children = true
}

// GroupPermissionChildrenCleared reports if the "group_permission_children" edge to the PermissionGroup entity was cleared.
func (m *PermissionGroupMutation) GroupPermissionChildrenCleared() bool {
	return m.clearedgroup_permission_children
}

// RemoveGroupPermissionChildIDs removes the "group_permission_children" edge to the PermissionGroup entity by IDs.
func (m *PermissionGroupMutation) RemoveGroupPermissionChildIDs(ids ...uuid.UUID) {
	if m.removedgroup_permission_children == nil {
		m.removedgroup_permission_children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.group_permission_children, ids[i])
		m.removedgroup_permission_children[ids[i]] = struct{}{}
	}
}

// RemovedGroupPermissionChildren returns the removed IDs of the "group_permission_children" edge to the PermissionGroup entity.
func (m *PermissionGroupMutation) RemovedGroupPermissionChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedgroup_permission_children {
		ids = append(ids, id)
	}
	return
}

// GroupPermissionChildrenIDs returns the "group_permission_children" edge IDs in the mutation.
func (m *PermissionGroupMutation) GroupPermissionChildrenIDs() (ids []uuid.UUID) {
	for id := range m.group_permission_children {
		ids = append(ids, id)
	}
	return
}

// ResetGroupPermissionChildren resets all changes to the "group_permission_children" edge.
func (m *PermissionGroupMutation) ResetGroupPermissionChildren() {
	m.group_permission_children = nil
	m.clearedgroup_permission_children = false
	m.removedgroup_permission_children = nil
}

// AddPermissionEdgeIDs adds the "permission_edges" edge to the Permission entity by ids.
func (m *PermissionGroupMutation) AddPermissionEdgeIDs(ids ...uuid.UUID) {
	if m.permission_edges == nil {
		m.permission_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.permission_edges[ids[i]] = struct{}{}
	}
}

// ClearPermissionEdges clears the "permission_edges" edge to the Permission entity.
func (m *PermissionGroupMutation) ClearPermissionEdges() {
	m.clearedpermission_edges = true
}

// PermissionEdgesCleared reports if the "permission_edges" edge to the Permission entity was cleared.
func (m *PermissionGroupMutation) PermissionEdgesCleared() bool {
	return m.clearedpermission_edges
}

// RemovePermissionEdgeIDs removes the "permission_edges" edge to the Permission entity by IDs.
func (m *PermissionGroupMutation) RemovePermissionEdgeIDs(ids ...uuid.UUID) {
	if m.removedpermission_edges == nil {
		m.removedpermission_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.permission_edges, ids[i])
		m.removedpermission_edges[ids[i]] = struct{}{}
	}
}

// RemovedPermissionEdges returns the removed IDs of the "permission_edges" edge to the Permission entity.
func (m *PermissionGroupMutation) RemovedPermissionEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedpermission_edges {
		ids = append(ids, id)
	}
	return
}

// PermissionEdgesIDs returns the "permission_edges" edge IDs in the mutation.
func (m *PermissionGroupMutation) PermissionEdgesIDs() (ids []uuid.UUID) {
	for id := range m.permission_edges {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionEdges resets all changes to the "permission_edges" edge.
func (m *PermissionGroupMutation) ResetPermissionEdges() {
	m.permission_edges = nil
	m.clearedpermission_edges = false
	m.removedpermission_edges = nil
}

// Where appends a list predicates to the PermissionGroupMutation builder.
func (m *PermissionGroupMutation) Where(ps ...predicate.PermissionGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PermissionGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PermissionGroup).
func (m *PermissionGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionGroupMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, permissiongroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permissiongroup.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, permissiongroup.FieldDeletedAt)
	}
	if m.title != nil {
		fields = append(fields, permissiongroup.FieldTitle)
	}
	if m.group_permission_parent != nil {
		fields = append(fields, permissiongroup.FieldParentID)
	}
	if m.group_type != nil {
		fields = append(fields, permissiongroup.FieldGroupType)
	}
	if m.order_id != nil {
		fields = append(fields, permissiongroup.FieldOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldCreatedAt:
		return m.CreatedAt()
	case permissiongroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case permissiongroup.FieldDeletedAt:
		return m.DeletedAt()
	case permissiongroup.FieldTitle:
		return m.Title()
	case permissiongroup.FieldParentID:
		return m.ParentID()
	case permissiongroup.FieldGroupType:
		return m.GroupType()
	case permissiongroup.FieldOrderID:
		return m.OrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permissiongroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permissiongroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permissiongroup.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case permissiongroup.FieldTitle:
		return m.OldTitle(ctx)
	case permissiongroup.FieldParentID:
		return m.OldParentID(ctx)
	case permissiongroup.FieldGroupType:
		return m.OldGroupType(ctx)
	case permissiongroup.FieldOrderID:
		return m.OldOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown PermissionGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permissiongroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permissiongroup.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case permissiongroup.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case permissiongroup.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case permissiongroup.FieldGroupType:
		v, ok := value.(permissiongroup.GroupType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupType(v)
		return nil
	case permissiongroup.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionGroupMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, permissiongroup.FieldOrderID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permissiongroup.FieldOrderID:
		return m.AddedOrderID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permissiongroup.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permissiongroup.FieldUpdatedAt) {
		fields = append(fields, permissiongroup.FieldUpdatedAt)
	}
	if m.FieldCleared(permissiongroup.FieldDeletedAt) {
		fields = append(fields, permissiongroup.FieldDeletedAt)
	}
	if m.FieldCleared(permissiongroup.FieldParentID) {
		fields = append(fields, permissiongroup.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ClearField(name string) error {
	switch name {
	case permissiongroup.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permissiongroup.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case permissiongroup.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionGroupMutation) ResetField(name string) error {
	switch name {
	case permissiongroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permissiongroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permissiongroup.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case permissiongroup.FieldTitle:
		m.ResetTitle()
		return nil
	case permissiongroup.FieldParentID:
		m.ResetParentID()
		return nil
	case permissiongroup.FieldGroupType:
		m.ResetGroupType()
		return nil
	case permissiongroup.FieldOrderID:
		m.ResetOrderID()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.group_permission_parent != nil {
		edges = append(edges, permissiongroup.EdgeGroupPermissionParent)
	}
	if m.group_permission_children != nil {
		edges = append(edges, permissiongroup.EdgeGroupPermissionChildren)
	}
	if m.permission_edges != nil {
		edges = append(edges, permissiongroup.EdgePermissionEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permissiongroup.EdgeGroupPermissionParent:
		if id := m.group_permission_parent; id != nil {
			return []ent.Value{*id}
		}
	case permissiongroup.EdgeGroupPermissionChildren:
		ids := make([]ent.Value, 0, len(m.group_permission_children))
		for id := range m.group_permission_children {
			ids = append(ids, id)
		}
		return ids
	case permissiongroup.EdgePermissionEdges:
		ids := make([]ent.Value, 0, len(m.permission_edges))
		for id := range m.permission_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgroup_permission_children != nil {
		edges = append(edges, permissiongroup.EdgeGroupPermissionChildren)
	}
	if m.removedpermission_edges != nil {
		edges = append(edges, permissiongroup.EdgePermissionEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permissiongroup.EdgeGroupPermissionChildren:
		ids := make([]ent.Value, 0, len(m.removedgroup_permission_children))
		for id := range m.removedgroup_permission_children {
			ids = append(ids, id)
		}
		return ids
	case permissiongroup.EdgePermissionEdges:
		ids := make([]ent.Value, 0, len(m.removedpermission_edges))
		for id := range m.removedpermission_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgroup_permission_parent {
		edges = append(edges, permissiongroup.EdgeGroupPermissionParent)
	}
	if m.clearedgroup_permission_children {
		edges = append(edges, permissiongroup.EdgeGroupPermissionChildren)
	}
	if m.clearedpermission_edges {
		edges = append(edges, permissiongroup.EdgePermissionEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case permissiongroup.EdgeGroupPermissionParent:
		return m.clearedgroup_permission_parent
	case permissiongroup.EdgeGroupPermissionChildren:
		return m.clearedgroup_permission_children
	case permissiongroup.EdgePermissionEdges:
		return m.clearedpermission_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionGroupMutation) ClearEdge(name string) error {
	switch name {
	case permissiongroup.EdgeGroupPermissionParent:
		m.ClearGroupPermissionParent()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionGroupMutation) ResetEdge(name string) error {
	switch name {
	case permissiongroup.EdgeGroupPermissionParent:
		m.ResetGroupPermissionParent()
		return nil
	case permissiongroup.EdgeGroupPermissionChildren:
		m.ResetGroupPermissionChildren()
		return nil
	case permissiongroup.EdgePermissionEdges:
		m.ResetPermissionEdges()
		return nil
	}
	return fmt.Errorf("unknown PermissionGroup edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	name                         *string
	description                  *string
	clearedFields                map[string]struct{}
	role_permission_edges        map[uuid.UUID]struct{}
	removedrole_permission_edges map[uuid.UUID]struct{}
	clearedrole_permission_edges bool
	user_edges                   map[uuid.UUID]struct{}
	removeduser_edges            map[uuid.UUID]struct{}
	cleareduser_edges            bool
	email_template_edges         map[uuid.UUID]struct{}
	removedemail_template_edges  map[uuid.UUID]struct{}
	clearedemail_template_edges  bool
	user_roles                   map[uuid.UUID]struct{}
	removeduser_roles            map[uuid.UUID]struct{}
	cleareduser_roles            bool
	email_template_roles         map[uuid.UUID]struct{}
	removedemail_template_roles  map[uuid.UUID]struct{}
	clearedemail_template_roles  bool
	done                         bool
	oldValue                     func(context.Context) (*Role, error)
	predicates                   []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[role.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, role.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
}

// AddRolePermissionEdgeIDs adds the "role_permission_edges" edge to the EntityPermission entity by ids.
func (m *RoleMutation) AddRolePermissionEdgeIDs(ids ...uuid.UUID) {
	if m.role_permission_edges == nil {
		m.role_permission_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_permission_edges[ids[i]] = struct{}{}
	}
}

// ClearRolePermissionEdges clears the "role_permission_edges" edge to the EntityPermission entity.
func (m *RoleMutation) ClearRolePermissionEdges() {
	m.clearedrole_permission_edges = true
}

// RolePermissionEdgesCleared reports if the "role_permission_edges" edge to the EntityPermission entity was cleared.
func (m *RoleMutation) RolePermissionEdgesCleared() bool {
	return m.clearedrole_permission_edges
}

// RemoveRolePermissionEdgeIDs removes the "role_permission_edges" edge to the EntityPermission entity by IDs.
func (m *RoleMutation) RemoveRolePermissionEdgeIDs(ids ...uuid.UUID) {
	if m.removedrole_permission_edges == nil {
		m.removedrole_permission_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_permission_edges, ids[i])
		m.removedrole_permission_edges[ids[i]] = struct{}{}
	}
}

// RemovedRolePermissionEdges returns the removed IDs of the "role_permission_edges" edge to the EntityPermission entity.
func (m *RoleMutation) RemovedRolePermissionEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_permission_edges {
		ids = append(ids, id)
	}
	return
}

// RolePermissionEdgesIDs returns the "role_permission_edges" edge IDs in the mutation.
func (m *RoleMutation) RolePermissionEdgesIDs() (ids []uuid.UUID) {
	for id := range m.role_permission_edges {
		ids = append(ids, id)
	}
	return
}

// ResetRolePermissionEdges resets all changes to the "role_permission_edges" edge.
func (m *RoleMutation) ResetRolePermissionEdges() {
	m.role_permission_edges = nil
	m.clearedrole_permission_edges = false
	m.removedrole_permission_edges = nil
}

// AddUserEdgeIDs adds the "user_edges" edge to the User entity by ids.
func (m *RoleMutation) AddUserEdgeIDs(ids ...uuid.UUID) {
	if m.user_edges == nil {
		m.user_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_edges[ids[i]] = struct{}{}
	}
}

// ClearUserEdges clears the "user_edges" edge to the User entity.
func (m *RoleMutation) ClearUserEdges() {
	m.cleareduser_edges = true
}

// UserEdgesCleared reports if the "user_edges" edge to the User entity was cleared.
func (m *RoleMutation) UserEdgesCleared() bool {
	return m.cleareduser_edges
}

// RemoveUserEdgeIDs removes the "user_edges" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserEdgeIDs(ids ...uuid.UUID) {
	if m.removeduser_edges == nil {
		m.removeduser_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_edges, ids[i])
		m.removeduser_edges[ids[i]] = struct{}{}
	}
}

// RemovedUserEdges returns the removed IDs of the "user_edges" edge to the User entity.
func (m *RoleMutation) RemovedUserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_edges {
		ids = append(ids, id)
	}
	return
}

// UserEdgesIDs returns the "user_edges" edge IDs in the mutation.
func (m *RoleMutation) UserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.user_edges {
		ids = append(ids, id)
	}
	return
}

// ResetUserEdges resets all changes to the "user_edges" edge.
func (m *RoleMutation) ResetUserEdges() {
	m.user_edges = nil
	m.cleareduser_edges = false
	m.removeduser_edges = nil
}

// AddEmailTemplateEdgeIDs adds the "email_template_edges" edge to the EmailTemplate entity by ids.
func (m *RoleMutation) AddEmailTemplateEdgeIDs(ids ...uuid.UUID) {
	if m.email_template_edges == nil {
		m.email_template_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.email_template_edges[ids[i]] = struct{}{}
	}
}

// ClearEmailTemplateEdges clears the "email_template_edges" edge to the EmailTemplate entity.
func (m *RoleMutation) ClearEmailTemplateEdges() {
	m.clearedemail_template_edges = true
}

// EmailTemplateEdgesCleared reports if the "email_template_edges" edge to the EmailTemplate entity was cleared.
func (m *RoleMutation) EmailTemplateEdgesCleared() bool {
	return m.clearedemail_template_edges
}

// RemoveEmailTemplateEdgeIDs removes the "email_template_edges" edge to the EmailTemplate entity by IDs.
func (m *RoleMutation) RemoveEmailTemplateEdgeIDs(ids ...uuid.UUID) {
	if m.removedemail_template_edges == nil {
		m.removedemail_template_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.email_template_edges, ids[i])
		m.removedemail_template_edges[ids[i]] = struct{}{}
	}
}

// RemovedEmailTemplateEdges returns the removed IDs of the "email_template_edges" edge to the EmailTemplate entity.
func (m *RoleMutation) RemovedEmailTemplateEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedemail_template_edges {
		ids = append(ids, id)
	}
	return
}

// EmailTemplateEdgesIDs returns the "email_template_edges" edge IDs in the mutation.
func (m *RoleMutation) EmailTemplateEdgesIDs() (ids []uuid.UUID) {
	for id := range m.email_template_edges {
		ids = append(ids, id)
	}
	return
}

// ResetEmailTemplateEdges resets all changes to the "email_template_edges" edge.
func (m *RoleMutation) ResetEmailTemplateEdges() {
	m.email_template_edges = nil
	m.clearedemail_template_edges = false
	m.removedemail_template_edges = nil
}

// AddUserRoleIDs adds the "user_roles" edge to the UserRole entity by ids.
func (m *RoleMutation) AddUserRoleIDs(ids ...uuid.UUID) {
	if m.user_roles == nil {
		m.user_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_roles[ids[i]] = struct{}{}
	}
}

// ClearUserRoles clears the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) ClearUserRoles() {
	m.cleareduser_roles = true
}

// UserRolesCleared reports if the "user_roles" edge to the UserRole entity was cleared.
func (m *RoleMutation) UserRolesCleared() bool {
	return m.cleareduser_roles
}

// RemoveUserRoleIDs removes the "user_roles" edge to the UserRole entity by IDs.
func (m *RoleMutation) RemoveUserRoleIDs(ids ...uuid.UUID) {
	if m.removeduser_roles == nil {
		m.removeduser_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_roles, ids[i])
		m.removeduser_roles[ids[i]] = struct{}{}
	}
}

// RemovedUserRoles returns the removed IDs of the "user_roles" edge to the UserRole entity.
func (m *RoleMutation) RemovedUserRolesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_roles {
		ids = append(ids, id)
	}
	return
}

// UserRolesIDs returns the "user_roles" edge IDs in the mutation.
func (m *RoleMutation) UserRolesIDs() (ids []uuid.UUID) {
	for id := range m.user_roles {
		ids = append(ids, id)
	}
	return
}

// ResetUserRoles resets all changes to the "user_roles" edge.
func (m *RoleMutation) ResetUserRoles() {
	m.user_roles = nil
	m.cleareduser_roles = false
	m.removeduser_roles = nil
}

// AddEmailTemplateRoleIDs adds the "email_template_roles" edge to the EmailRoleAttribute entity by ids.
func (m *RoleMutation) AddEmailTemplateRoleIDs(ids ...uuid.UUID) {
	if m.email_template_roles == nil {
		m.email_template_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.email_template_roles[ids[i]] = struct{}{}
	}
}

// ClearEmailTemplateRoles clears the "email_template_roles" edge to the EmailRoleAttribute entity.
func (m *RoleMutation) ClearEmailTemplateRoles() {
	m.clearedemail_template_roles = true
}

// EmailTemplateRolesCleared reports if the "email_template_roles" edge to the EmailRoleAttribute entity was cleared.
func (m *RoleMutation) EmailTemplateRolesCleared() bool {
	return m.clearedemail_template_roles
}

// RemoveEmailTemplateRoleIDs removes the "email_template_roles" edge to the EmailRoleAttribute entity by IDs.
func (m *RoleMutation) RemoveEmailTemplateRoleIDs(ids ...uuid.UUID) {
	if m.removedemail_template_roles == nil {
		m.removedemail_template_roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.email_template_roles, ids[i])
		m.removedemail_template_roles[ids[i]] = struct{}{}
	}
}

// RemovedEmailTemplateRoles returns the removed IDs of the "email_template_roles" edge to the EmailRoleAttribute entity.
func (m *RoleMutation) RemovedEmailTemplateRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedemail_template_roles {
		ids = append(ids, id)
	}
	return
}

// EmailTemplateRolesIDs returns the "email_template_roles" edge IDs in the mutation.
func (m *RoleMutation) EmailTemplateRolesIDs() (ids []uuid.UUID) {
	for id := range m.email_template_roles {
		ids = append(ids, id)
	}
	return
}

// ResetEmailTemplateRoles resets all changes to the "email_template_roles" edge.
func (m *RoleMutation) ResetEmailTemplateRoles() {
	m.email_template_roles = nil
	m.clearedemail_template_roles = false
	m.removedemail_template_roles = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldUpdatedAt) {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.role_permission_edges != nil {
		edges = append(edges, role.EdgeRolePermissionEdges)
	}
	if m.user_edges != nil {
		edges = append(edges, role.EdgeUserEdges)
	}
	if m.email_template_edges != nil {
		edges = append(edges, role.EdgeEmailTemplateEdges)
	}
	if m.user_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	if m.email_template_roles != nil {
		edges = append(edges, role.EdgeEmailTemplateRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRolePermissionEdges:
		ids := make([]ent.Value, 0, len(m.role_permission_edges))
		for id := range m.role_permission_edges {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.user_edges))
		for id := range m.user_edges {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeEmailTemplateEdges:
		ids := make([]ent.Value, 0, len(m.email_template_edges))
		for id := range m.email_template_edges {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.user_roles))
		for id := range m.user_roles {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeEmailTemplateRoles:
		ids := make([]ent.Value, 0, len(m.email_template_roles))
		for id := range m.email_template_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrole_permission_edges != nil {
		edges = append(edges, role.EdgeRolePermissionEdges)
	}
	if m.removeduser_edges != nil {
		edges = append(edges, role.EdgeUserEdges)
	}
	if m.removedemail_template_edges != nil {
		edges = append(edges, role.EdgeEmailTemplateEdges)
	}
	if m.removeduser_roles != nil {
		edges = append(edges, role.EdgeUserRoles)
	}
	if m.removedemail_template_roles != nil {
		edges = append(edges, role.EdgeEmailTemplateRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeRolePermissionEdges:
		ids := make([]ent.Value, 0, len(m.removedrole_permission_edges))
		for id := range m.removedrole_permission_edges {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.removeduser_edges))
		for id := range m.removeduser_edges {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeEmailTemplateEdges:
		ids := make([]ent.Value, 0, len(m.removedemail_template_edges))
		for id := range m.removedemail_template_edges {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUserRoles:
		ids := make([]ent.Value, 0, len(m.removeduser_roles))
		for id := range m.removeduser_roles {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeEmailTemplateRoles:
		ids := make([]ent.Value, 0, len(m.removedemail_template_roles))
		for id := range m.removedemail_template_roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrole_permission_edges {
		edges = append(edges, role.EdgeRolePermissionEdges)
	}
	if m.cleareduser_edges {
		edges = append(edges, role.EdgeUserEdges)
	}
	if m.clearedemail_template_edges {
		edges = append(edges, role.EdgeEmailTemplateEdges)
	}
	if m.cleareduser_roles {
		edges = append(edges, role.EdgeUserRoles)
	}
	if m.clearedemail_template_roles {
		edges = append(edges, role.EdgeEmailTemplateRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeRolePermissionEdges:
		return m.clearedrole_permission_edges
	case role.EdgeUserEdges:
		return m.cleareduser_edges
	case role.EdgeEmailTemplateEdges:
		return m.clearedemail_template_edges
	case role.EdgeUserRoles:
		return m.cleareduser_roles
	case role.EdgeEmailTemplateRoles:
		return m.clearedemail_template_roles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeRolePermissionEdges:
		m.ResetRolePermissionEdges()
		return nil
	case role.EdgeUserEdges:
		m.ResetUserEdges()
		return nil
	case role.EdgeEmailTemplateEdges:
		m.ResetEmailTemplateEdges()
		return nil
	case role.EdgeUserRoles:
		m.ResetUserRoles()
		return nil
	case role.EdgeEmailTemplateRoles:
		m.ResetEmailTemplateRoles()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	name                      *string
	description               *string
	clearedFields             map[string]struct{}
	skill_type_edge           *uuid.UUID
	clearedskill_type_edge    bool
	entity_skill_edges        map[uuid.UUID]struct{}
	removedentity_skill_edges map[uuid.UUID]struct{}
	clearedentity_skill_edges bool
	done                      bool
	oldValue                  func(context.Context) (*Skill, error)
	predicates                []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id uuid.UUID) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Skill entities.
func (m *SkillMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SkillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SkillMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[skill.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SkillMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[skill.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, skill.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SkillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SkillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SkillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[skill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SkillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[skill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SkillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, skill.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SkillMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SkillMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SkillMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[skill.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SkillMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[skill.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SkillMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, skill.FieldDescription)
}

// SetSkillTypeID sets the "skill_type_id" field.
func (m *SkillMutation) SetSkillTypeID(u uuid.UUID) {
	m.skill_type_edge = &u
}

// SkillTypeID returns the value of the "skill_type_id" field in the mutation.
func (m *SkillMutation) SkillTypeID() (r uuid.UUID, exists bool) {
	v := m.skill_type_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillTypeID returns the old "skill_type_id" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldSkillTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillTypeID: %w", err)
	}
	return oldValue.SkillTypeID, nil
}

// ClearSkillTypeID clears the value of the "skill_type_id" field.
func (m *SkillMutation) ClearSkillTypeID() {
	m.skill_type_edge = nil
	m.clearedFields[skill.FieldSkillTypeID] = struct{}{}
}

// SkillTypeIDCleared returns if the "skill_type_id" field was cleared in this mutation.
func (m *SkillMutation) SkillTypeIDCleared() bool {
	_, ok := m.clearedFields[skill.FieldSkillTypeID]
	return ok
}

// ResetSkillTypeID resets all changes to the "skill_type_id" field.
func (m *SkillMutation) ResetSkillTypeID() {
	m.skill_type_edge = nil
	delete(m.clearedFields, skill.FieldSkillTypeID)
}

// SetSkillTypeEdgeID sets the "skill_type_edge" edge to the SkillType entity by id.
func (m *SkillMutation) SetSkillTypeEdgeID(id uuid.UUID) {
	m.skill_type_edge = &id
}

// ClearSkillTypeEdge clears the "skill_type_edge" edge to the SkillType entity.
func (m *SkillMutation) ClearSkillTypeEdge() {
	m.clearedskill_type_edge = true
}

// SkillTypeEdgeCleared reports if the "skill_type_edge" edge to the SkillType entity was cleared.
func (m *SkillMutation) SkillTypeEdgeCleared() bool {
	return m.SkillTypeIDCleared() || m.clearedskill_type_edge
}

// SkillTypeEdgeID returns the "skill_type_edge" edge ID in the mutation.
func (m *SkillMutation) SkillTypeEdgeID() (id uuid.UUID, exists bool) {
	if m.skill_type_edge != nil {
		return *m.skill_type_edge, true
	}
	return
}

// SkillTypeEdgeIDs returns the "skill_type_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillTypeEdgeID instead. It exists only for internal usage by the builders.
func (m *SkillMutation) SkillTypeEdgeIDs() (ids []uuid.UUID) {
	if id := m.skill_type_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkillTypeEdge resets all changes to the "skill_type_edge" edge.
func (m *SkillMutation) ResetSkillTypeEdge() {
	m.skill_type_edge = nil
	m.clearedskill_type_edge = false
}

// AddEntitySkillEdgeIDs adds the "entity_skill_edges" edge to the EntitySkill entity by ids.
func (m *SkillMutation) AddEntitySkillEdgeIDs(ids ...uuid.UUID) {
	if m.entity_skill_edges == nil {
		m.entity_skill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.entity_skill_edges[ids[i]] = struct{}{}
	}
}

// ClearEntitySkillEdges clears the "entity_skill_edges" edge to the EntitySkill entity.
func (m *SkillMutation) ClearEntitySkillEdges() {
	m.clearedentity_skill_edges = true
}

// EntitySkillEdgesCleared reports if the "entity_skill_edges" edge to the EntitySkill entity was cleared.
func (m *SkillMutation) EntitySkillEdgesCleared() bool {
	return m.clearedentity_skill_edges
}

// RemoveEntitySkillEdgeIDs removes the "entity_skill_edges" edge to the EntitySkill entity by IDs.
func (m *SkillMutation) RemoveEntitySkillEdgeIDs(ids ...uuid.UUID) {
	if m.removedentity_skill_edges == nil {
		m.removedentity_skill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.entity_skill_edges, ids[i])
		m.removedentity_skill_edges[ids[i]] = struct{}{}
	}
}

// RemovedEntitySkillEdges returns the removed IDs of the "entity_skill_edges" edge to the EntitySkill entity.
func (m *SkillMutation) RemovedEntitySkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedentity_skill_edges {
		ids = append(ids, id)
	}
	return
}

// EntitySkillEdgesIDs returns the "entity_skill_edges" edge IDs in the mutation.
func (m *SkillMutation) EntitySkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.entity_skill_edges {
		ids = append(ids, id)
	}
	return
}

// ResetEntitySkillEdges resets all changes to the "entity_skill_edges" edge.
func (m *SkillMutation) ResetEntitySkillEdges() {
	m.entity_skill_edges = nil
	m.clearedentity_skill_edges = false
	m.removedentity_skill_edges = nil
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, skill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, skill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, skill.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.description != nil {
		fields = append(fields, skill.FieldDescription)
	}
	if m.skill_type_edge != nil {
		fields = append(fields, skill.FieldSkillTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldCreatedAt:
		return m.CreatedAt()
	case skill.FieldUpdatedAt:
		return m.UpdatedAt()
	case skill.FieldDeletedAt:
		return m.DeletedAt()
	case skill.FieldName:
		return m.Name()
	case skill.FieldDescription:
		return m.Description()
	case skill.FieldSkillTypeID:
		return m.SkillTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case skill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case skill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldDescription:
		return m.OldDescription(ctx)
	case skill.FieldSkillTypeID:
		return m.OldSkillTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case skill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case skill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case skill.FieldSkillTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skill.FieldUpdatedAt) {
		fields = append(fields, skill.FieldUpdatedAt)
	}
	if m.FieldCleared(skill.FieldDeletedAt) {
		fields = append(fields, skill.FieldDeletedAt)
	}
	if m.FieldCleared(skill.FieldDescription) {
		fields = append(fields, skill.FieldDescription)
	}
	if m.FieldCleared(skill.FieldSkillTypeID) {
		fields = append(fields, skill.FieldSkillTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	switch name {
	case skill.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case skill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case skill.FieldDescription:
		m.ClearDescription()
		return nil
	case skill.FieldSkillTypeID:
		m.ClearSkillTypeID()
		return nil
	}
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case skill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case skill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldDescription:
		m.ResetDescription()
		return nil
	case skill.FieldSkillTypeID:
		m.ResetSkillTypeID()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.skill_type_edge != nil {
		edges = append(edges, skill.EdgeSkillTypeEdge)
	}
	if m.entity_skill_edges != nil {
		edges = append(edges, skill.EdgeEntitySkillEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeSkillTypeEdge:
		if id := m.skill_type_edge; id != nil {
			return []ent.Value{*id}
		}
	case skill.EdgeEntitySkillEdges:
		ids := make([]ent.Value, 0, len(m.entity_skill_edges))
		for id := range m.entity_skill_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedentity_skill_edges != nil {
		edges = append(edges, skill.EdgeEntitySkillEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeEntitySkillEdges:
		ids := make([]ent.Value, 0, len(m.removedentity_skill_edges))
		for id := range m.removedentity_skill_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedskill_type_edge {
		edges = append(edges, skill.EdgeSkillTypeEdge)
	}
	if m.clearedentity_skill_edges {
		edges = append(edges, skill.EdgeEntitySkillEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeSkillTypeEdge:
		return m.clearedskill_type_edge
	case skill.EdgeEntitySkillEdges:
		return m.clearedentity_skill_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	case skill.EdgeSkillTypeEdge:
		m.ClearSkillTypeEdge()
		return nil
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeSkillTypeEdge:
		m.ResetSkillTypeEdge()
		return nil
	case skill.EdgeEntitySkillEdges:
		m.ResetEntitySkillEdges()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// SkillTypeMutation represents an operation that mutates the SkillType nodes in the graph.
type SkillTypeMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	name               *string
	description        *string
	clearedFields      map[string]struct{}
	skill_edges        map[uuid.UUID]struct{}
	removedskill_edges map[uuid.UUID]struct{}
	clearedskill_edges bool
	done               bool
	oldValue           func(context.Context) (*SkillType, error)
	predicates         []predicate.SkillType
}

var _ ent.Mutation = (*SkillTypeMutation)(nil)

// skilltypeOption allows management of the mutation configuration using functional options.
type skilltypeOption func(*SkillTypeMutation)

// newSkillTypeMutation creates new mutation for the SkillType entity.
func newSkillTypeMutation(c config, op Op, opts ...skilltypeOption) *SkillTypeMutation {
	m := &SkillTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSkillType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillTypeID sets the ID field of the mutation.
func withSkillTypeID(id uuid.UUID) skilltypeOption {
	return func(m *SkillTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SkillType
		)
		m.oldValue = func(ctx context.Context) (*SkillType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkillType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkillType sets the old SkillType of the mutation.
func withSkillType(node *SkillType) skilltypeOption {
	return func(m *SkillTypeMutation) {
		m.oldValue = func(context.Context) (*SkillType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SkillType entities.
func (m *SkillTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SkillType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SkillTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SkillTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SkillType entity.
// If the SkillType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SkillTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SkillTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SkillTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SkillType entity.
// If the SkillType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SkillTypeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[skilltype.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SkillTypeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[skilltype.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SkillTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, skilltype.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SkillTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SkillTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SkillType entity.
// If the SkillType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillTypeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SkillTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[skilltype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SkillTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[skilltype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SkillTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, skilltype.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SkillTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SkillType entity.
// If the SkillType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SkillTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SkillTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SkillType entity.
// If the SkillType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SkillTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[skilltype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SkillTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[skilltype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SkillTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, skilltype.FieldDescription)
}

// AddSkillEdgeIDs adds the "skill_edges" edge to the Skill entity by ids.
func (m *SkillTypeMutation) AddSkillEdgeIDs(ids ...uuid.UUID) {
	if m.skill_edges == nil {
		m.skill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.skill_edges[ids[i]] = struct{}{}
	}
}

// ClearSkillEdges clears the "skill_edges" edge to the Skill entity.
func (m *SkillTypeMutation) ClearSkillEdges() {
	m.clearedskill_edges = true
}

// SkillEdgesCleared reports if the "skill_edges" edge to the Skill entity was cleared.
func (m *SkillTypeMutation) SkillEdgesCleared() bool {
	return m.clearedskill_edges
}

// RemoveSkillEdgeIDs removes the "skill_edges" edge to the Skill entity by IDs.
func (m *SkillTypeMutation) RemoveSkillEdgeIDs(ids ...uuid.UUID) {
	if m.removedskill_edges == nil {
		m.removedskill_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.skill_edges, ids[i])
		m.removedskill_edges[ids[i]] = struct{}{}
	}
}

// RemovedSkillEdges returns the removed IDs of the "skill_edges" edge to the Skill entity.
func (m *SkillTypeMutation) RemovedSkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedskill_edges {
		ids = append(ids, id)
	}
	return
}

// SkillEdgesIDs returns the "skill_edges" edge IDs in the mutation.
func (m *SkillTypeMutation) SkillEdgesIDs() (ids []uuid.UUID) {
	for id := range m.skill_edges {
		ids = append(ids, id)
	}
	return
}

// ResetSkillEdges resets all changes to the "skill_edges" edge.
func (m *SkillTypeMutation) ResetSkillEdges() {
	m.skill_edges = nil
	m.clearedskill_edges = false
	m.removedskill_edges = nil
}

// Where appends a list predicates to the SkillTypeMutation builder.
func (m *SkillTypeMutation) Where(ps ...predicate.SkillType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkillTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SkillType).
func (m *SkillTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, skilltype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, skilltype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, skilltype.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, skilltype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, skilltype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skilltype.FieldCreatedAt:
		return m.CreatedAt()
	case skilltype.FieldUpdatedAt:
		return m.UpdatedAt()
	case skilltype.FieldDeletedAt:
		return m.DeletedAt()
	case skilltype.FieldName:
		return m.Name()
	case skilltype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skilltype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case skilltype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case skilltype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case skilltype.FieldName:
		return m.OldName(ctx)
	case skilltype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SkillType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skilltype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case skilltype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case skilltype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case skilltype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skilltype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SkillType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SkillType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skilltype.FieldUpdatedAt) {
		fields = append(fields, skilltype.FieldUpdatedAt)
	}
	if m.FieldCleared(skilltype.FieldDeletedAt) {
		fields = append(fields, skilltype.FieldDeletedAt)
	}
	if m.FieldCleared(skilltype.FieldDescription) {
		fields = append(fields, skilltype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillTypeMutation) ClearField(name string) error {
	switch name {
	case skilltype.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case skilltype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case skilltype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SkillType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillTypeMutation) ResetField(name string) error {
	switch name {
	case skilltype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case skilltype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case skilltype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case skilltype.FieldName:
		m.ResetName()
		return nil
	case skilltype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SkillType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.skill_edges != nil {
		edges = append(edges, skilltype.EdgeSkillEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skilltype.EdgeSkillEdges:
		ids := make([]ent.Value, 0, len(m.skill_edges))
		for id := range m.skill_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedskill_edges != nil {
		edges = append(edges, skilltype.EdgeSkillEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case skilltype.EdgeSkillEdges:
		ids := make([]ent.Value, 0, len(m.removedskill_edges))
		for id := range m.removedskill_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedskill_edges {
		edges = append(edges, skilltype.EdgeSkillEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case skilltype.EdgeSkillEdges:
		return m.clearedskill_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SkillType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillTypeMutation) ResetEdge(name string) error {
	switch name {
	case skilltype.EdgeSkillEdges:
		m.ResetSkillEdges()
		return nil
	}
	return fmt.Errorf("unknown SkillType edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	slug                  *string
	name                  *string
	clearedFields         map[string]struct{}
	user_edges            map[uuid.UUID]struct{}
	removeduser_edges     map[uuid.UUID]struct{}
	cleareduser_edges     bool
	team_job_edges        map[uuid.UUID]struct{}
	removedteam_job_edges map[uuid.UUID]struct{}
	clearedteam_job_edges bool
	member_edges          map[uuid.UUID]struct{}
	removedmember_edges   map[uuid.UUID]struct{}
	clearedmember_edges   bool
	user_teams            map[uuid.UUID]struct{}
	removeduser_teams     map[uuid.UUID]struct{}
	cleareduser_teams     bool
	done                  bool
	oldValue              func(context.Context) (*Team, error)
	predicates            []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[team.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, team.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeamMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeamMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeamMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[team.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeamMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeamMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, team.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *TeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// AddUserEdgeIDs adds the "user_edges" edge to the User entity by ids.
func (m *TeamMutation) AddUserEdgeIDs(ids ...uuid.UUID) {
	if m.user_edges == nil {
		m.user_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_edges[ids[i]] = struct{}{}
	}
}

// ClearUserEdges clears the "user_edges" edge to the User entity.
func (m *TeamMutation) ClearUserEdges() {
	m.cleareduser_edges = true
}

// UserEdgesCleared reports if the "user_edges" edge to the User entity was cleared.
func (m *TeamMutation) UserEdgesCleared() bool {
	return m.cleareduser_edges
}

// RemoveUserEdgeIDs removes the "user_edges" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserEdgeIDs(ids ...uuid.UUID) {
	if m.removeduser_edges == nil {
		m.removeduser_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_edges, ids[i])
		m.removeduser_edges[ids[i]] = struct{}{}
	}
}

// RemovedUserEdges returns the removed IDs of the "user_edges" edge to the User entity.
func (m *TeamMutation) RemovedUserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_edges {
		ids = append(ids, id)
	}
	return
}

// UserEdgesIDs returns the "user_edges" edge IDs in the mutation.
func (m *TeamMutation) UserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.user_edges {
		ids = append(ids, id)
	}
	return
}

// ResetUserEdges resets all changes to the "user_edges" edge.
func (m *TeamMutation) ResetUserEdges() {
	m.user_edges = nil
	m.cleareduser_edges = false
	m.removeduser_edges = nil
}

// AddTeamJobEdgeIDs adds the "team_job_edges" edge to the HiringJob entity by ids.
func (m *TeamMutation) AddTeamJobEdgeIDs(ids ...uuid.UUID) {
	if m.team_job_edges == nil {
		m.team_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_job_edges[ids[i]] = struct{}{}
	}
}

// ClearTeamJobEdges clears the "team_job_edges" edge to the HiringJob entity.
func (m *TeamMutation) ClearTeamJobEdges() {
	m.clearedteam_job_edges = true
}

// TeamJobEdgesCleared reports if the "team_job_edges" edge to the HiringJob entity was cleared.
func (m *TeamMutation) TeamJobEdgesCleared() bool {
	return m.clearedteam_job_edges
}

// RemoveTeamJobEdgeIDs removes the "team_job_edges" edge to the HiringJob entity by IDs.
func (m *TeamMutation) RemoveTeamJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedteam_job_edges == nil {
		m.removedteam_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_job_edges, ids[i])
		m.removedteam_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedTeamJobEdges returns the removed IDs of the "team_job_edges" edge to the HiringJob entity.
func (m *TeamMutation) RemovedTeamJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_job_edges {
		ids = append(ids, id)
	}
	return
}

// TeamJobEdgesIDs returns the "team_job_edges" edge IDs in the mutation.
func (m *TeamMutation) TeamJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.team_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetTeamJobEdges resets all changes to the "team_job_edges" edge.
func (m *TeamMutation) ResetTeamJobEdges() {
	m.team_job_edges = nil
	m.clearedteam_job_edges = false
	m.removedteam_job_edges = nil
}

// AddMemberEdgeIDs adds the "member_edges" edge to the User entity by ids.
func (m *TeamMutation) AddMemberEdgeIDs(ids ...uuid.UUID) {
	if m.member_edges == nil {
		m.member_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.member_edges[ids[i]] = struct{}{}
	}
}

// ClearMemberEdges clears the "member_edges" edge to the User entity.
func (m *TeamMutation) ClearMemberEdges() {
	m.clearedmember_edges = true
}

// MemberEdgesCleared reports if the "member_edges" edge to the User entity was cleared.
func (m *TeamMutation) MemberEdgesCleared() bool {
	return m.clearedmember_edges
}

// RemoveMemberEdgeIDs removes the "member_edges" edge to the User entity by IDs.
func (m *TeamMutation) RemoveMemberEdgeIDs(ids ...uuid.UUID) {
	if m.removedmember_edges == nil {
		m.removedmember_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.member_edges, ids[i])
		m.removedmember_edges[ids[i]] = struct{}{}
	}
}

// RemovedMemberEdges returns the removed IDs of the "member_edges" edge to the User entity.
func (m *TeamMutation) RemovedMemberEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedmember_edges {
		ids = append(ids, id)
	}
	return
}

// MemberEdgesIDs returns the "member_edges" edge IDs in the mutation.
func (m *TeamMutation) MemberEdgesIDs() (ids []uuid.UUID) {
	for id := range m.member_edges {
		ids = append(ids, id)
	}
	return
}

// ResetMemberEdges resets all changes to the "member_edges" edge.
func (m *TeamMutation) ResetMemberEdges() {
	m.member_edges = nil
	m.clearedmember_edges = false
	m.removedmember_edges = nil
}

// AddUserTeamIDs adds the "user_teams" edge to the TeamManager entity by ids.
func (m *TeamMutation) AddUserTeamIDs(ids ...uuid.UUID) {
	if m.user_teams == nil {
		m.user_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_teams[ids[i]] = struct{}{}
	}
}

// ClearUserTeams clears the "user_teams" edge to the TeamManager entity.
func (m *TeamMutation) ClearUserTeams() {
	m.cleareduser_teams = true
}

// UserTeamsCleared reports if the "user_teams" edge to the TeamManager entity was cleared.
func (m *TeamMutation) UserTeamsCleared() bool {
	return m.cleareduser_teams
}

// RemoveUserTeamIDs removes the "user_teams" edge to the TeamManager entity by IDs.
func (m *TeamMutation) RemoveUserTeamIDs(ids ...uuid.UUID) {
	if m.removeduser_teams == nil {
		m.removeduser_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_teams, ids[i])
		m.removeduser_teams[ids[i]] = struct{}{}
	}
}

// RemovedUserTeams returns the removed IDs of the "user_teams" edge to the TeamManager entity.
func (m *TeamMutation) RemovedUserTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_teams {
		ids = append(ids, id)
	}
	return
}

// UserTeamsIDs returns the "user_teams" edge IDs in the mutation.
func (m *TeamMutation) UserTeamsIDs() (ids []uuid.UUID) {
	for id := range m.user_teams {
		ids = append(ids, id)
	}
	return
}

// ResetUserTeams resets all changes to the "user_teams" edge.
func (m *TeamMutation) ResetUserTeams() {
	m.user_teams = nil
	m.cleareduser_teams = false
	m.removeduser_teams = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, team.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, team.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	case team.FieldDeletedAt:
		return m.DeletedAt()
	case team.FieldSlug:
		return m.Slug()
	case team.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case team.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case team.FieldSlug:
		return m.OldSlug(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case team.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case team.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldUpdatedAt) {
		fields = append(fields, team.FieldUpdatedAt)
	}
	if m.FieldCleared(team.FieldDeletedAt) {
		fields = append(fields, team.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case team.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case team.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case team.FieldSlug:
		m.ResetSlug()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user_edges != nil {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.team_job_edges != nil {
		edges = append(edges, team.EdgeTeamJobEdges)
	}
	if m.member_edges != nil {
		edges = append(edges, team.EdgeMemberEdges)
	}
	if m.user_teams != nil {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.user_edges))
		for id := range m.user_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamJobEdges:
		ids := make([]ent.Value, 0, len(m.team_job_edges))
		for id := range m.team_job_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeMemberEdges:
		ids := make([]ent.Value, 0, len(m.member_edges))
		for id := range m.member_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUserTeams:
		ids := make([]ent.Value, 0, len(m.user_teams))
		for id := range m.user_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser_edges != nil {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.removedteam_job_edges != nil {
		edges = append(edges, team.EdgeTeamJobEdges)
	}
	if m.removedmember_edges != nil {
		edges = append(edges, team.EdgeMemberEdges)
	}
	if m.removeduser_teams != nil {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.removeduser_edges))
		for id := range m.removeduser_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamJobEdges:
		ids := make([]ent.Value, 0, len(m.removedteam_job_edges))
		for id := range m.removedteam_job_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeMemberEdges:
		ids := make([]ent.Value, 0, len(m.removedmember_edges))
		for id := range m.removedmember_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUserTeams:
		ids := make([]ent.Value, 0, len(m.removeduser_teams))
		for id := range m.removeduser_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser_edges {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.clearedteam_job_edges {
		edges = append(edges, team.EdgeTeamJobEdges)
	}
	if m.clearedmember_edges {
		edges = append(edges, team.EdgeMemberEdges)
	}
	if m.cleareduser_teams {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeUserEdges:
		return m.cleareduser_edges
	case team.EdgeTeamJobEdges:
		return m.clearedteam_job_edges
	case team.EdgeMemberEdges:
		return m.clearedmember_edges
	case team.EdgeUserTeams:
		return m.cleareduser_teams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeUserEdges:
		m.ResetUserEdges()
		return nil
	case team.EdgeTeamJobEdges:
		m.ResetTeamJobEdges()
		return nil
	case team.EdgeMemberEdges:
		m.ResetMemberEdges()
		return nil
	case team.EdgeUserTeams:
		m.ResetUserTeams()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamManagerMutation represents an operation that mutates the TeamManager nodes in the graph.
type TeamManagerMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	user_edge        *uuid.UUID
	cleareduser_edge bool
	team_edge        *uuid.UUID
	clearedteam_edge bool
	done             bool
	oldValue         func(context.Context) (*TeamManager, error)
	predicates       []predicate.TeamManager
}

var _ ent.Mutation = (*TeamManagerMutation)(nil)

// teammanagerOption allows management of the mutation configuration using functional options.
type teammanagerOption func(*TeamManagerMutation)

// newTeamManagerMutation creates new mutation for the TeamManager entity.
func newTeamManagerMutation(c config, op Op, opts ...teammanagerOption) *TeamManagerMutation {
	m := &TeamManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamManagerID sets the ID field of the mutation.
func withTeamManagerID(id uuid.UUID) teammanagerOption {
	return func(m *TeamManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamManager
		)
		m.oldValue = func(ctx context.Context) (*TeamManager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamManager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamManager sets the old TeamManager of the mutation.
func withTeamManager(node *TeamManager) teammanagerOption {
	return func(m *TeamManagerMutation) {
		m.oldValue = func(context.Context) (*TeamManager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamManager entities.
func (m *TeamManagerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamManagerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamManagerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamManager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamManagerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamManagerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[teammanager.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamManagerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[teammanager.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, teammanager.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeamManagerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeamManagerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeamManagerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[teammanager.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeamManagerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[teammanager.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeamManagerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, teammanager.FieldDeletedAt)
}

// SetTeamID sets the "team_id" field.
func (m *TeamManagerMutation) SetTeamID(u uuid.UUID) {
	m.team_edge = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TeamManagerMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TeamManagerMutation) ResetTeamID() {
	m.team_edge = nil
}

// SetUserID sets the "user_id" field.
func (m *TeamManagerMutation) SetUserID(u uuid.UUID) {
	m.user_edge = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TeamManagerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TeamManagerMutation) ResetUserID() {
	m.user_edge = nil
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *TeamManagerMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *TeamManagerMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *TeamManagerMutation) UserEdgeCleared() bool {
	return m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *TeamManagerMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *TeamManagerMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *TeamManagerMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetTeamEdgeID sets the "team_edge" edge to the Team entity by id.
func (m *TeamManagerMutation) SetTeamEdgeID(id uuid.UUID) {
	m.team_edge = &id
}

// ClearTeamEdge clears the "team_edge" edge to the Team entity.
func (m *TeamManagerMutation) ClearTeamEdge() {
	m.clearedteam_edge = true
}

// TeamEdgeCleared reports if the "team_edge" edge to the Team entity was cleared.
func (m *TeamManagerMutation) TeamEdgeCleared() bool {
	return m.clearedteam_edge
}

// TeamEdgeID returns the "team_edge" edge ID in the mutation.
func (m *TeamManagerMutation) TeamEdgeID() (id uuid.UUID, exists bool) {
	if m.team_edge != nil {
		return *m.team_edge, true
	}
	return
}

// TeamEdgeIDs returns the "team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamEdgeID instead. It exists only for internal usage by the builders.
func (m *TeamManagerMutation) TeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamEdge resets all changes to the "team_edge" edge.
func (m *TeamManagerMutation) ResetTeamEdge() {
	m.team_edge = nil
	m.clearedteam_edge = false
}

// Where appends a list predicates to the TeamManagerMutation builder.
func (m *TeamManagerMutation) Where(ps ...predicate.TeamManager) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamManagerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeamManager).
func (m *TeamManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamManagerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, teammanager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammanager.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, teammanager.FieldDeletedAt)
	}
	if m.team_edge != nil {
		fields = append(fields, teammanager.FieldTeamID)
	}
	if m.user_edge != nil {
		fields = append(fields, teammanager.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammanager.FieldCreatedAt:
		return m.CreatedAt()
	case teammanager.FieldUpdatedAt:
		return m.UpdatedAt()
	case teammanager.FieldDeletedAt:
		return m.DeletedAt()
	case teammanager.FieldTeamID:
		return m.TeamID()
	case teammanager.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammanager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammanager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teammanager.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case teammanager.FieldTeamID:
		return m.OldTeamID(ctx)
	case teammanager.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown TeamManager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammanager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammanager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teammanager.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case teammanager.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case teammanager.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown TeamManager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamManagerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamManagerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamManager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teammanager.FieldUpdatedAt) {
		fields = append(fields, teammanager.FieldUpdatedAt)
	}
	if m.FieldCleared(teammanager.FieldDeletedAt) {
		fields = append(fields, teammanager.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamManagerMutation) ClearField(name string) error {
	switch name {
	case teammanager.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case teammanager.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamManager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamManagerMutation) ResetField(name string) error {
	switch name {
	case teammanager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammanager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teammanager.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case teammanager.FieldTeamID:
		m.ResetTeamID()
		return nil
	case teammanager.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown TeamManager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_edge != nil {
		edges = append(edges, teammanager.EdgeUserEdge)
	}
	if m.team_edge != nil {
		edges = append(edges, teammanager.EdgeTeamEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamManagerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammanager.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case teammanager.EdgeTeamEdge:
		if id := m.team_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_edge {
		edges = append(edges, teammanager.EdgeUserEdge)
	}
	if m.clearedteam_edge {
		edges = append(edges, teammanager.EdgeTeamEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamManagerMutation) EdgeCleared(name string) bool {
	switch name {
	case teammanager.EdgeUserEdge:
		return m.cleareduser_edge
	case teammanager.EdgeTeamEdge:
		return m.clearedteam_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamManagerMutation) ClearEdge(name string) error {
	switch name {
	case teammanager.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case teammanager.EdgeTeamEdge:
		m.ClearTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown TeamManager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamManagerMutation) ResetEdge(name string) error {
	switch name {
	case teammanager.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case teammanager.EdgeTeamEdge:
		m.ResetTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown TeamManager edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	deleted_at                       *time.Time
	name                             *string
	work_email                       *string
	status                           *user.Status
	oid                              *string
	location                         *string
	clearedFields                    map[string]struct{}
	audit_edge                       map[uuid.UUID]struct{}
	removedaudit_edge                map[uuid.UUID]struct{}
	clearedaudit_edge                bool
	hiring_owner                     map[uuid.UUID]struct{}
	removedhiring_owner              map[uuid.UUID]struct{}
	clearedhiring_owner              bool
	team_edges                       map[uuid.UUID]struct{}
	removedteam_edges                map[uuid.UUID]struct{}
	clearedteam_edges                bool
	candidate_job_feedback           map[uuid.UUID]struct{}
	removedcandidate_job_feedback    map[uuid.UUID]struct{}
	clearedcandidate_job_feedback    bool
	interview_edges                  map[uuid.UUID]struct{}
	removedinterview_edges           map[uuid.UUID]struct{}
	clearedinterview_edges           bool
	candidate_job_edges              map[uuid.UUID]struct{}
	removedcandidate_job_edges       map[uuid.UUID]struct{}
	clearedcandidate_job_edges       bool
	candidate_interview_edges        map[uuid.UUID]struct{}
	removedcandidate_interview_edges map[uuid.UUID]struct{}
	clearedcandidate_interview_edges bool
	candidate_reference_edges        map[uuid.UUID]struct{}
	removedcandidate_reference_edges map[uuid.UUID]struct{}
	clearedcandidate_reference_edges bool
	user_permission_edges            map[uuid.UUID]struct{}
	removeduser_permission_edges     map[uuid.UUID]struct{}
	cleareduser_permission_edges     bool
	role_edges                       map[uuid.UUID]struct{}
	removedrole_edges                map[uuid.UUID]struct{}
	clearedrole_edges                bool
	member_of_team_edges             *uuid.UUID
	clearedmember_of_team_edges      bool
	hiring_team_edges                map[uuid.UUID]struct{}
	removedhiring_team_edges         map[uuid.UUID]struct{}
	clearedhiring_team_edges         bool
	team_users                       map[uuid.UUID]struct{}
	removedteam_users                map[uuid.UUID]struct{}
	clearedteam_users                bool
	interview_users                  map[uuid.UUID]struct{}
	removedinterview_users           map[uuid.UUID]struct{}
	clearedinterview_users           bool
	role_users                       map[uuid.UUID]struct{}
	removedrole_users                map[uuid.UUID]struct{}
	clearedrole_users                bool
	hiring_team_users                map[uuid.UUID]struct{}
	removedhiring_team_users         map[uuid.UUID]struct{}
	clearedhiring_team_users         bool
	done                             bool
	oldValue                         func(context.Context) (*User, error)
	predicates                       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetWorkEmail sets the "work_email" field.
func (m *UserMutation) SetWorkEmail(s string) {
	m.work_email = &s
}

// WorkEmail returns the value of the "work_email" field in the mutation.
func (m *UserMutation) WorkEmail() (r string, exists bool) {
	v := m.work_email
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEmail returns the old "work_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWorkEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEmail: %w", err)
	}
	return oldValue.WorkEmail, nil
}

// ResetWorkEmail resets all changes to the "work_email" field.
func (m *UserMutation) ResetWorkEmail() {
	m.work_email = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetOid sets the "oid" field.
func (m *UserMutation) SetOid(s string) {
	m.oid = &s
}

// Oid returns the value of the "oid" field in the mutation.
func (m *UserMutation) Oid() (r string, exists bool) {
	v := m.oid
	if v == nil {
		return
	}
	return *v, true
}

// OldOid returns the old "oid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOid: %w", err)
	}
	return oldValue.Oid, nil
}

// ResetOid resets all changes to the "oid" field.
func (m *UserMutation) ResetOid() {
	m.oid = nil
}

// SetTeamID sets the "team_id" field.
func (m *UserMutation) SetTeamID(u uuid.UUID) {
	m.member_of_team_edges = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *UserMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.member_of_team_edges
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *UserMutation) ClearTeamID() {
	m.member_of_team_edges = nil
	m.clearedFields[user.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *UserMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[user.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *UserMutation) ResetTeamID() {
	m.member_of_team_edges = nil
	delete(m.clearedFields, user.FieldTeamID)
}

// SetLocation sets the "location" field.
func (m *UserMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UserMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[user.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UserMutation) LocationCleared() bool {
	_, ok := m.clearedFields[user.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UserMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, user.FieldLocation)
}

// AddAuditEdgeIDs adds the "audit_edge" edge to the AuditTrail entity by ids.
func (m *UserMutation) AddAuditEdgeIDs(ids ...uuid.UUID) {
	if m.audit_edge == nil {
		m.audit_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.audit_edge[ids[i]] = struct{}{}
	}
}

// ClearAuditEdge clears the "audit_edge" edge to the AuditTrail entity.
func (m *UserMutation) ClearAuditEdge() {
	m.clearedaudit_edge = true
}

// AuditEdgeCleared reports if the "audit_edge" edge to the AuditTrail entity was cleared.
func (m *UserMutation) AuditEdgeCleared() bool {
	return m.clearedaudit_edge
}

// RemoveAuditEdgeIDs removes the "audit_edge" edge to the AuditTrail entity by IDs.
func (m *UserMutation) RemoveAuditEdgeIDs(ids ...uuid.UUID) {
	if m.removedaudit_edge == nil {
		m.removedaudit_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.audit_edge, ids[i])
		m.removedaudit_edge[ids[i]] = struct{}{}
	}
}

// RemovedAuditEdge returns the removed IDs of the "audit_edge" edge to the AuditTrail entity.
func (m *UserMutation) RemovedAuditEdgeIDs() (ids []uuid.UUID) {
	for id := range m.removedaudit_edge {
		ids = append(ids, id)
	}
	return
}

// AuditEdgeIDs returns the "audit_edge" edge IDs in the mutation.
func (m *UserMutation) AuditEdgeIDs() (ids []uuid.UUID) {
	for id := range m.audit_edge {
		ids = append(ids, id)
	}
	return
}

// ResetAuditEdge resets all changes to the "audit_edge" edge.
func (m *UserMutation) ResetAuditEdge() {
	m.audit_edge = nil
	m.clearedaudit_edge = false
	m.removedaudit_edge = nil
}

// AddHiringOwnerIDs adds the "hiring_owner" edge to the HiringJob entity by ids.
func (m *UserMutation) AddHiringOwnerIDs(ids ...uuid.UUID) {
	if m.hiring_owner == nil {
		m.hiring_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_owner[ids[i]] = struct{}{}
	}
}

// ClearHiringOwner clears the "hiring_owner" edge to the HiringJob entity.
func (m *UserMutation) ClearHiringOwner() {
	m.clearedhiring_owner = true
}

// HiringOwnerCleared reports if the "hiring_owner" edge to the HiringJob entity was cleared.
func (m *UserMutation) HiringOwnerCleared() bool {
	return m.clearedhiring_owner
}

// RemoveHiringOwnerIDs removes the "hiring_owner" edge to the HiringJob entity by IDs.
func (m *UserMutation) RemoveHiringOwnerIDs(ids ...uuid.UUID) {
	if m.removedhiring_owner == nil {
		m.removedhiring_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_owner, ids[i])
		m.removedhiring_owner[ids[i]] = struct{}{}
	}
}

// RemovedHiringOwner returns the removed IDs of the "hiring_owner" edge to the HiringJob entity.
func (m *UserMutation) RemovedHiringOwnerIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_owner {
		ids = append(ids, id)
	}
	return
}

// HiringOwnerIDs returns the "hiring_owner" edge IDs in the mutation.
func (m *UserMutation) HiringOwnerIDs() (ids []uuid.UUID) {
	for id := range m.hiring_owner {
		ids = append(ids, id)
	}
	return
}

// ResetHiringOwner resets all changes to the "hiring_owner" edge.
func (m *UserMutation) ResetHiringOwner() {
	m.hiring_owner = nil
	m.clearedhiring_owner = false
	m.removedhiring_owner = nil
}

// AddTeamEdgeIDs adds the "team_edges" edge to the Team entity by ids.
func (m *UserMutation) AddTeamEdgeIDs(ids ...uuid.UUID) {
	if m.team_edges == nil {
		m.team_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_edges[ids[i]] = struct{}{}
	}
}

// ClearTeamEdges clears the "team_edges" edge to the Team entity.
func (m *UserMutation) ClearTeamEdges() {
	m.clearedteam_edges = true
}

// TeamEdgesCleared reports if the "team_edges" edge to the Team entity was cleared.
func (m *UserMutation) TeamEdgesCleared() bool {
	return m.clearedteam_edges
}

// RemoveTeamEdgeIDs removes the "team_edges" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamEdgeIDs(ids ...uuid.UUID) {
	if m.removedteam_edges == nil {
		m.removedteam_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_edges, ids[i])
		m.removedteam_edges[ids[i]] = struct{}{}
	}
}

// RemovedTeamEdges returns the removed IDs of the "team_edges" edge to the Team entity.
func (m *UserMutation) RemovedTeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_edges {
		ids = append(ids, id)
	}
	return
}

// TeamEdgesIDs returns the "team_edges" edge IDs in the mutation.
func (m *UserMutation) TeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.team_edges {
		ids = append(ids, id)
	}
	return
}

// ResetTeamEdges resets all changes to the "team_edges" edge.
func (m *UserMutation) ResetTeamEdges() {
	m.team_edges = nil
	m.clearedteam_edges = false
	m.removedteam_edges = nil
}

// AddCandidateJobFeedbackIDs adds the "candidate_job_feedback" edge to the CandidateJobFeedback entity by ids.
func (m *UserMutation) AddCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.candidate_job_feedback == nil {
		m.candidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_feedback[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobFeedback clears the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *UserMutation) ClearCandidateJobFeedback() {
	m.clearedcandidate_job_feedback = true
}

// CandidateJobFeedbackCleared reports if the "candidate_job_feedback" edge to the CandidateJobFeedback entity was cleared.
func (m *UserMutation) CandidateJobFeedbackCleared() bool {
	return m.clearedcandidate_job_feedback
}

// RemoveCandidateJobFeedbackIDs removes the "candidate_job_feedback" edge to the CandidateJobFeedback entity by IDs.
func (m *UserMutation) RemoveCandidateJobFeedbackIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_feedback == nil {
		m.removedcandidate_job_feedback = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_feedback, ids[i])
		m.removedcandidate_job_feedback[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobFeedback returns the removed IDs of the "candidate_job_feedback" edge to the CandidateJobFeedback entity.
func (m *UserMutation) RemovedCandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// CandidateJobFeedbackIDs returns the "candidate_job_feedback" edge IDs in the mutation.
func (m *UserMutation) CandidateJobFeedbackIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_feedback {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobFeedback resets all changes to the "candidate_job_feedback" edge.
func (m *UserMutation) ResetCandidateJobFeedback() {
	m.candidate_job_feedback = nil
	m.clearedcandidate_job_feedback = false
	m.removedcandidate_job_feedback = nil
}

// AddInterviewEdgeIDs adds the "interview_edges" edge to the CandidateInterview entity by ids.
func (m *UserMutation) AddInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.interview_edges == nil {
		m.interview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interview_edges[ids[i]] = struct{}{}
	}
}

// ClearInterviewEdges clears the "interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) ClearInterviewEdges() {
	m.clearedinterview_edges = true
}

// InterviewEdgesCleared reports if the "interview_edges" edge to the CandidateInterview entity was cleared.
func (m *UserMutation) InterviewEdgesCleared() bool {
	return m.clearedinterview_edges
}

// RemoveInterviewEdgeIDs removes the "interview_edges" edge to the CandidateInterview entity by IDs.
func (m *UserMutation) RemoveInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.removedinterview_edges == nil {
		m.removedinterview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interview_edges, ids[i])
		m.removedinterview_edges[ids[i]] = struct{}{}
	}
}

// RemovedInterviewEdges returns the removed IDs of the "interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) RemovedInterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedinterview_edges {
		ids = append(ids, id)
	}
	return
}

// InterviewEdgesIDs returns the "interview_edges" edge IDs in the mutation.
func (m *UserMutation) InterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.interview_edges {
		ids = append(ids, id)
	}
	return
}

// ResetInterviewEdges resets all changes to the "interview_edges" edge.
func (m *UserMutation) ResetInterviewEdges() {
	m.interview_edges = nil
	m.clearedinterview_edges = false
	m.removedinterview_edges = nil
}

// AddCandidateJobEdgeIDs adds the "candidate_job_edges" edge to the CandidateJob entity by ids.
func (m *UserMutation) AddCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_job_edges == nil {
		m.candidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobEdges clears the "candidate_job_edges" edge to the CandidateJob entity.
func (m *UserMutation) ClearCandidateJobEdges() {
	m.clearedcandidate_job_edges = true
}

// CandidateJobEdgesCleared reports if the "candidate_job_edges" edge to the CandidateJob entity was cleared.
func (m *UserMutation) CandidateJobEdgesCleared() bool {
	return m.clearedcandidate_job_edges
}

// RemoveCandidateJobEdgeIDs removes the "candidate_job_edges" edge to the CandidateJob entity by IDs.
func (m *UserMutation) RemoveCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_edges == nil {
		m.removedcandidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_edges, ids[i])
		m.removedcandidate_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobEdges returns the removed IDs of the "candidate_job_edges" edge to the CandidateJob entity.
func (m *UserMutation) RemovedCandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateJobEdgesIDs returns the "candidate_job_edges" edge IDs in the mutation.
func (m *UserMutation) CandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobEdges resets all changes to the "candidate_job_edges" edge.
func (m *UserMutation) ResetCandidateJobEdges() {
	m.candidate_job_edges = nil
	m.clearedcandidate_job_edges = false
	m.removedcandidate_job_edges = nil
}

// AddCandidateInterviewEdgeIDs adds the "candidate_interview_edges" edge to the CandidateInterview entity by ids.
func (m *UserMutation) AddCandidateInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_interview_edges == nil {
		m.candidate_interview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_interview_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateInterviewEdges clears the "candidate_interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) ClearCandidateInterviewEdges() {
	m.clearedcandidate_interview_edges = true
}

// CandidateInterviewEdgesCleared reports if the "candidate_interview_edges" edge to the CandidateInterview entity was cleared.
func (m *UserMutation) CandidateInterviewEdgesCleared() bool {
	return m.clearedcandidate_interview_edges
}

// RemoveCandidateInterviewEdgeIDs removes the "candidate_interview_edges" edge to the CandidateInterview entity by IDs.
func (m *UserMutation) RemoveCandidateInterviewEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_interview_edges == nil {
		m.removedcandidate_interview_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_interview_edges, ids[i])
		m.removedcandidate_interview_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateInterviewEdges returns the removed IDs of the "candidate_interview_edges" edge to the CandidateInterview entity.
func (m *UserMutation) RemovedCandidateInterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_interview_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateInterviewEdgesIDs returns the "candidate_interview_edges" edge IDs in the mutation.
func (m *UserMutation) CandidateInterviewEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_interview_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateInterviewEdges resets all changes to the "candidate_interview_edges" edge.
func (m *UserMutation) ResetCandidateInterviewEdges() {
	m.candidate_interview_edges = nil
	m.clearedcandidate_interview_edges = false
	m.removedcandidate_interview_edges = nil
}

// AddCandidateReferenceEdgeIDs adds the "candidate_reference_edges" edge to the Candidate entity by ids.
func (m *UserMutation) AddCandidateReferenceEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_reference_edges == nil {
		m.candidate_reference_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_reference_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateReferenceEdges clears the "candidate_reference_edges" edge to the Candidate entity.
func (m *UserMutation) ClearCandidateReferenceEdges() {
	m.clearedcandidate_reference_edges = true
}

// CandidateReferenceEdgesCleared reports if the "candidate_reference_edges" edge to the Candidate entity was cleared.
func (m *UserMutation) CandidateReferenceEdgesCleared() bool {
	return m.clearedcandidate_reference_edges
}

// RemoveCandidateReferenceEdgeIDs removes the "candidate_reference_edges" edge to the Candidate entity by IDs.
func (m *UserMutation) RemoveCandidateReferenceEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_reference_edges == nil {
		m.removedcandidate_reference_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_reference_edges, ids[i])
		m.removedcandidate_reference_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateReferenceEdges returns the removed IDs of the "candidate_reference_edges" edge to the Candidate entity.
func (m *UserMutation) RemovedCandidateReferenceEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_reference_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateReferenceEdgesIDs returns the "candidate_reference_edges" edge IDs in the mutation.
func (m *UserMutation) CandidateReferenceEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_reference_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateReferenceEdges resets all changes to the "candidate_reference_edges" edge.
func (m *UserMutation) ResetCandidateReferenceEdges() {
	m.candidate_reference_edges = nil
	m.clearedcandidate_reference_edges = false
	m.removedcandidate_reference_edges = nil
}

// AddUserPermissionEdgeIDs adds the "user_permission_edges" edge to the EntityPermission entity by ids.
func (m *UserMutation) AddUserPermissionEdgeIDs(ids ...uuid.UUID) {
	if m.user_permission_edges == nil {
		m.user_permission_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_permission_edges[ids[i]] = struct{}{}
	}
}

// ClearUserPermissionEdges clears the "user_permission_edges" edge to the EntityPermission entity.
func (m *UserMutation) ClearUserPermissionEdges() {
	m.cleareduser_permission_edges = true
}

// UserPermissionEdgesCleared reports if the "user_permission_edges" edge to the EntityPermission entity was cleared.
func (m *UserMutation) UserPermissionEdgesCleared() bool {
	return m.cleareduser_permission_edges
}

// RemoveUserPermissionEdgeIDs removes the "user_permission_edges" edge to the EntityPermission entity by IDs.
func (m *UserMutation) RemoveUserPermissionEdgeIDs(ids ...uuid.UUID) {
	if m.removeduser_permission_edges == nil {
		m.removeduser_permission_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_permission_edges, ids[i])
		m.removeduser_permission_edges[ids[i]] = struct{}{}
	}
}

// RemovedUserPermissionEdges returns the removed IDs of the "user_permission_edges" edge to the EntityPermission entity.
func (m *UserMutation) RemovedUserPermissionEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_permission_edges {
		ids = append(ids, id)
	}
	return
}

// UserPermissionEdgesIDs returns the "user_permission_edges" edge IDs in the mutation.
func (m *UserMutation) UserPermissionEdgesIDs() (ids []uuid.UUID) {
	for id := range m.user_permission_edges {
		ids = append(ids, id)
	}
	return
}

// ResetUserPermissionEdges resets all changes to the "user_permission_edges" edge.
func (m *UserMutation) ResetUserPermissionEdges() {
	m.user_permission_edges = nil
	m.cleareduser_permission_edges = false
	m.removeduser_permission_edges = nil
}

// AddRoleEdgeIDs adds the "role_edges" edge to the Role entity by ids.
func (m *UserMutation) AddRoleEdgeIDs(ids ...uuid.UUID) {
	if m.role_edges == nil {
		m.role_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_edges[ids[i]] = struct{}{}
	}
}

// ClearRoleEdges clears the "role_edges" edge to the Role entity.
func (m *UserMutation) ClearRoleEdges() {
	m.clearedrole_edges = true
}

// RoleEdgesCleared reports if the "role_edges" edge to the Role entity was cleared.
func (m *UserMutation) RoleEdgesCleared() bool {
	return m.clearedrole_edges
}

// RemoveRoleEdgeIDs removes the "role_edges" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleEdgeIDs(ids ...uuid.UUID) {
	if m.removedrole_edges == nil {
		m.removedrole_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_edges, ids[i])
		m.removedrole_edges[ids[i]] = struct{}{}
	}
}

// RemovedRoleEdges returns the removed IDs of the "role_edges" edge to the Role entity.
func (m *UserMutation) RemovedRoleEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_edges {
		ids = append(ids, id)
	}
	return
}

// RoleEdgesIDs returns the "role_edges" edge IDs in the mutation.
func (m *UserMutation) RoleEdgesIDs() (ids []uuid.UUID) {
	for id := range m.role_edges {
		ids = append(ids, id)
	}
	return
}

// ResetRoleEdges resets all changes to the "role_edges" edge.
func (m *UserMutation) ResetRoleEdges() {
	m.role_edges = nil
	m.clearedrole_edges = false
	m.removedrole_edges = nil
}

// SetMemberOfTeamEdgesID sets the "member_of_team_edges" edge to the Team entity by id.
func (m *UserMutation) SetMemberOfTeamEdgesID(id uuid.UUID) {
	m.member_of_team_edges = &id
}

// ClearMemberOfTeamEdges clears the "member_of_team_edges" edge to the Team entity.
func (m *UserMutation) ClearMemberOfTeamEdges() {
	m.clearedmember_of_team_edges = true
}

// MemberOfTeamEdgesCleared reports if the "member_of_team_edges" edge to the Team entity was cleared.
func (m *UserMutation) MemberOfTeamEdgesCleared() bool {
	return m.TeamIDCleared() || m.clearedmember_of_team_edges
}

// MemberOfTeamEdgesID returns the "member_of_team_edges" edge ID in the mutation.
func (m *UserMutation) MemberOfTeamEdgesID() (id uuid.UUID, exists bool) {
	if m.member_of_team_edges != nil {
		return *m.member_of_team_edges, true
	}
	return
}

// MemberOfTeamEdgesIDs returns the "member_of_team_edges" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberOfTeamEdgesID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MemberOfTeamEdgesIDs() (ids []uuid.UUID) {
	if id := m.member_of_team_edges; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemberOfTeamEdges resets all changes to the "member_of_team_edges" edge.
func (m *UserMutation) ResetMemberOfTeamEdges() {
	m.member_of_team_edges = nil
	m.clearedmember_of_team_edges = false
}

// AddHiringTeamEdgeIDs adds the "hiring_team_edges" edge to the HiringTeam entity by ids.
func (m *UserMutation) AddHiringTeamEdgeIDs(ids ...uuid.UUID) {
	if m.hiring_team_edges == nil {
		m.hiring_team_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_team_edges[ids[i]] = struct{}{}
	}
}

// ClearHiringTeamEdges clears the "hiring_team_edges" edge to the HiringTeam entity.
func (m *UserMutation) ClearHiringTeamEdges() {
	m.clearedhiring_team_edges = true
}

// HiringTeamEdgesCleared reports if the "hiring_team_edges" edge to the HiringTeam entity was cleared.
func (m *UserMutation) HiringTeamEdgesCleared() bool {
	return m.clearedhiring_team_edges
}

// RemoveHiringTeamEdgeIDs removes the "hiring_team_edges" edge to the HiringTeam entity by IDs.
func (m *UserMutation) RemoveHiringTeamEdgeIDs(ids ...uuid.UUID) {
	if m.removedhiring_team_edges == nil {
		m.removedhiring_team_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_team_edges, ids[i])
		m.removedhiring_team_edges[ids[i]] = struct{}{}
	}
}

// RemovedHiringTeamEdges returns the removed IDs of the "hiring_team_edges" edge to the HiringTeam entity.
func (m *UserMutation) RemovedHiringTeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_team_edges {
		ids = append(ids, id)
	}
	return
}

// HiringTeamEdgesIDs returns the "hiring_team_edges" edge IDs in the mutation.
func (m *UserMutation) HiringTeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.hiring_team_edges {
		ids = append(ids, id)
	}
	return
}

// ResetHiringTeamEdges resets all changes to the "hiring_team_edges" edge.
func (m *UserMutation) ResetHiringTeamEdges() {
	m.hiring_team_edges = nil
	m.clearedhiring_team_edges = false
	m.removedhiring_team_edges = nil
}

// AddTeamUserIDs adds the "team_users" edge to the TeamManager entity by ids.
func (m *UserMutation) AddTeamUserIDs(ids ...uuid.UUID) {
	if m.team_users == nil {
		m.team_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_users[ids[i]] = struct{}{}
	}
}

// ClearTeamUsers clears the "team_users" edge to the TeamManager entity.
func (m *UserMutation) ClearTeamUsers() {
	m.clearedteam_users = true
}

// TeamUsersCleared reports if the "team_users" edge to the TeamManager entity was cleared.
func (m *UserMutation) TeamUsersCleared() bool {
	return m.clearedteam_users
}

// RemoveTeamUserIDs removes the "team_users" edge to the TeamManager entity by IDs.
func (m *UserMutation) RemoveTeamUserIDs(ids ...uuid.UUID) {
	if m.removedteam_users == nil {
		m.removedteam_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_users, ids[i])
		m.removedteam_users[ids[i]] = struct{}{}
	}
}

// RemovedTeamUsers returns the removed IDs of the "team_users" edge to the TeamManager entity.
func (m *UserMutation) RemovedTeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_users {
		ids = append(ids, id)
	}
	return
}

// TeamUsersIDs returns the "team_users" edge IDs in the mutation.
func (m *UserMutation) TeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.team_users {
		ids = append(ids, id)
	}
	return
}

// ResetTeamUsers resets all changes to the "team_users" edge.
func (m *UserMutation) ResetTeamUsers() {
	m.team_users = nil
	m.clearedteam_users = false
	m.removedteam_users = nil
}

// AddInterviewUserIDs adds the "interview_users" edge to the CandidateInterviewer entity by ids.
func (m *UserMutation) AddInterviewUserIDs(ids ...uuid.UUID) {
	if m.interview_users == nil {
		m.interview_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.interview_users[ids[i]] = struct{}{}
	}
}

// ClearInterviewUsers clears the "interview_users" edge to the CandidateInterviewer entity.
func (m *UserMutation) ClearInterviewUsers() {
	m.clearedinterview_users = true
}

// InterviewUsersCleared reports if the "interview_users" edge to the CandidateInterviewer entity was cleared.
func (m *UserMutation) InterviewUsersCleared() bool {
	return m.clearedinterview_users
}

// RemoveInterviewUserIDs removes the "interview_users" edge to the CandidateInterviewer entity by IDs.
func (m *UserMutation) RemoveInterviewUserIDs(ids ...uuid.UUID) {
	if m.removedinterview_users == nil {
		m.removedinterview_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.interview_users, ids[i])
		m.removedinterview_users[ids[i]] = struct{}{}
	}
}

// RemovedInterviewUsers returns the removed IDs of the "interview_users" edge to the CandidateInterviewer entity.
func (m *UserMutation) RemovedInterviewUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedinterview_users {
		ids = append(ids, id)
	}
	return
}

// InterviewUsersIDs returns the "interview_users" edge IDs in the mutation.
func (m *UserMutation) InterviewUsersIDs() (ids []uuid.UUID) {
	for id := range m.interview_users {
		ids = append(ids, id)
	}
	return
}

// ResetInterviewUsers resets all changes to the "interview_users" edge.
func (m *UserMutation) ResetInterviewUsers() {
	m.interview_users = nil
	m.clearedinterview_users = false
	m.removedinterview_users = nil
}

// AddRoleUserIDs adds the "role_users" edge to the UserRole entity by ids.
func (m *UserMutation) AddRoleUserIDs(ids ...uuid.UUID) {
	if m.role_users == nil {
		m.role_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role_users[ids[i]] = struct{}{}
	}
}

// ClearRoleUsers clears the "role_users" edge to the UserRole entity.
func (m *UserMutation) ClearRoleUsers() {
	m.clearedrole_users = true
}

// RoleUsersCleared reports if the "role_users" edge to the UserRole entity was cleared.
func (m *UserMutation) RoleUsersCleared() bool {
	return m.clearedrole_users
}

// RemoveRoleUserIDs removes the "role_users" edge to the UserRole entity by IDs.
func (m *UserMutation) RemoveRoleUserIDs(ids ...uuid.UUID) {
	if m.removedrole_users == nil {
		m.removedrole_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role_users, ids[i])
		m.removedrole_users[ids[i]] = struct{}{}
	}
}

// RemovedRoleUsers returns the removed IDs of the "role_users" edge to the UserRole entity.
func (m *UserMutation) RemovedRoleUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedrole_users {
		ids = append(ids, id)
	}
	return
}

// RoleUsersIDs returns the "role_users" edge IDs in the mutation.
func (m *UserMutation) RoleUsersIDs() (ids []uuid.UUID) {
	for id := range m.role_users {
		ids = append(ids, id)
	}
	return
}

// ResetRoleUsers resets all changes to the "role_users" edge.
func (m *UserMutation) ResetRoleUsers() {
	m.role_users = nil
	m.clearedrole_users = false
	m.removedrole_users = nil
}

// AddHiringTeamUserIDs adds the "hiring_team_users" edge to the HiringTeamManager entity by ids.
func (m *UserMutation) AddHiringTeamUserIDs(ids ...uuid.UUID) {
	if m.hiring_team_users == nil {
		m.hiring_team_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_team_users[ids[i]] = struct{}{}
	}
}

// ClearHiringTeamUsers clears the "hiring_team_users" edge to the HiringTeamManager entity.
func (m *UserMutation) ClearHiringTeamUsers() {
	m.clearedhiring_team_users = true
}

// HiringTeamUsersCleared reports if the "hiring_team_users" edge to the HiringTeamManager entity was cleared.
func (m *UserMutation) HiringTeamUsersCleared() bool {
	return m.clearedhiring_team_users
}

// RemoveHiringTeamUserIDs removes the "hiring_team_users" edge to the HiringTeamManager entity by IDs.
func (m *UserMutation) RemoveHiringTeamUserIDs(ids ...uuid.UUID) {
	if m.removedhiring_team_users == nil {
		m.removedhiring_team_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_team_users, ids[i])
		m.removedhiring_team_users[ids[i]] = struct{}{}
	}
}

// RemovedHiringTeamUsers returns the removed IDs of the "hiring_team_users" edge to the HiringTeamManager entity.
func (m *UserMutation) RemovedHiringTeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_team_users {
		ids = append(ids, id)
	}
	return
}

// HiringTeamUsersIDs returns the "hiring_team_users" edge IDs in the mutation.
func (m *UserMutation) HiringTeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.hiring_team_users {
		ids = append(ids, id)
	}
	return
}

// ResetHiringTeamUsers resets all changes to the "hiring_team_users" edge.
func (m *UserMutation) ResetHiringTeamUsers() {
	m.hiring_team_users = nil
	m.clearedhiring_team_users = false
	m.removedhiring_team_users = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.work_email != nil {
		fields = append(fields, user.FieldWorkEmail)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.oid != nil {
		fields = append(fields, user.FieldOid)
	}
	if m.member_of_team_edges != nil {
		fields = append(fields, user.FieldTeamID)
	}
	if m.location != nil {
		fields = append(fields, user.FieldLocation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldWorkEmail:
		return m.WorkEmail()
	case user.FieldStatus:
		return m.Status()
	case user.FieldOid:
		return m.Oid()
	case user.FieldTeamID:
		return m.TeamID()
	case user.FieldLocation:
		return m.Location()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldWorkEmail:
		return m.OldWorkEmail(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldOid:
		return m.OldOid(ctx)
	case user.FieldTeamID:
		return m.OldTeamID(ctx)
	case user.FieldLocation:
		return m.OldLocation(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldWorkEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEmail(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldOid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOid(v)
		return nil
	case user.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case user.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldTeamID) {
		fields = append(fields, user.FieldTeamID)
	}
	if m.FieldCleared(user.FieldLocation) {
		fields = append(fields, user.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldTeamID:
		m.ClearTeamID()
		return nil
	case user.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldWorkEmail:
		m.ResetWorkEmail()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldOid:
		m.ResetOid()
		return nil
	case user.FieldTeamID:
		m.ResetTeamID()
		return nil
	case user.FieldLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.audit_edge != nil {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.hiring_owner != nil {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.team_edges != nil {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.candidate_job_feedback != nil {
		edges = append(edges, user.EdgeCandidateJobFeedback)
	}
	if m.interview_edges != nil {
		edges = append(edges, user.EdgeInterviewEdges)
	}
	if m.candidate_job_edges != nil {
		edges = append(edges, user.EdgeCandidateJobEdges)
	}
	if m.candidate_interview_edges != nil {
		edges = append(edges, user.EdgeCandidateInterviewEdges)
	}
	if m.candidate_reference_edges != nil {
		edges = append(edges, user.EdgeCandidateReferenceEdges)
	}
	if m.user_permission_edges != nil {
		edges = append(edges, user.EdgeUserPermissionEdges)
	}
	if m.role_edges != nil {
		edges = append(edges, user.EdgeRoleEdges)
	}
	if m.member_of_team_edges != nil {
		edges = append(edges, user.EdgeMemberOfTeamEdges)
	}
	if m.hiring_team_edges != nil {
		edges = append(edges, user.EdgeHiringTeamEdges)
	}
	if m.team_users != nil {
		edges = append(edges, user.EdgeTeamUsers)
	}
	if m.interview_users != nil {
		edges = append(edges, user.EdgeInterviewUsers)
	}
	if m.role_users != nil {
		edges = append(edges, user.EdgeRoleUsers)
	}
	if m.hiring_team_users != nil {
		edges = append(edges, user.EdgeHiringTeamUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuditEdge:
		ids := make([]ent.Value, 0, len(m.audit_edge))
		for id := range m.audit_edge {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringOwner:
		ids := make([]ent.Value, 0, len(m.hiring_owner))
		for id := range m.hiring_owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamEdges:
		ids := make([]ent.Value, 0, len(m.team_edges))
		for id := range m.team_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.candidate_job_feedback))
		for id := range m.candidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewEdges:
		ids := make([]ent.Value, 0, len(m.interview_edges))
		for id := range m.interview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.candidate_job_edges))
		for id := range m.candidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateInterviewEdges:
		ids := make([]ent.Value, 0, len(m.candidate_interview_edges))
		for id := range m.candidate_interview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateReferenceEdges:
		ids := make([]ent.Value, 0, len(m.candidate_reference_edges))
		for id := range m.candidate_reference_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPermissionEdges:
		ids := make([]ent.Value, 0, len(m.user_permission_edges))
		for id := range m.user_permission_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoleEdges:
		ids := make([]ent.Value, 0, len(m.role_edges))
		for id := range m.role_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMemberOfTeamEdges:
		if id := m.member_of_team_edges; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeHiringTeamEdges:
		ids := make([]ent.Value, 0, len(m.hiring_team_edges))
		for id := range m.hiring_team_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamUsers:
		ids := make([]ent.Value, 0, len(m.team_users))
		for id := range m.team_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewUsers:
		ids := make([]ent.Value, 0, len(m.interview_users))
		for id := range m.interview_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoleUsers:
		ids := make([]ent.Value, 0, len(m.role_users))
		for id := range m.role_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringTeamUsers:
		ids := make([]ent.Value, 0, len(m.hiring_team_users))
		for id := range m.hiring_team_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedaudit_edge != nil {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.removedhiring_owner != nil {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.removedteam_edges != nil {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.removedcandidate_job_feedback != nil {
		edges = append(edges, user.EdgeCandidateJobFeedback)
	}
	if m.removedinterview_edges != nil {
		edges = append(edges, user.EdgeInterviewEdges)
	}
	if m.removedcandidate_job_edges != nil {
		edges = append(edges, user.EdgeCandidateJobEdges)
	}
	if m.removedcandidate_interview_edges != nil {
		edges = append(edges, user.EdgeCandidateInterviewEdges)
	}
	if m.removedcandidate_reference_edges != nil {
		edges = append(edges, user.EdgeCandidateReferenceEdges)
	}
	if m.removeduser_permission_edges != nil {
		edges = append(edges, user.EdgeUserPermissionEdges)
	}
	if m.removedrole_edges != nil {
		edges = append(edges, user.EdgeRoleEdges)
	}
	if m.removedhiring_team_edges != nil {
		edges = append(edges, user.EdgeHiringTeamEdges)
	}
	if m.removedteam_users != nil {
		edges = append(edges, user.EdgeTeamUsers)
	}
	if m.removedinterview_users != nil {
		edges = append(edges, user.EdgeInterviewUsers)
	}
	if m.removedrole_users != nil {
		edges = append(edges, user.EdgeRoleUsers)
	}
	if m.removedhiring_team_users != nil {
		edges = append(edges, user.EdgeHiringTeamUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuditEdge:
		ids := make([]ent.Value, 0, len(m.removedaudit_edge))
		for id := range m.removedaudit_edge {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringOwner:
		ids := make([]ent.Value, 0, len(m.removedhiring_owner))
		for id := range m.removedhiring_owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamEdges:
		ids := make([]ent.Value, 0, len(m.removedteam_edges))
		for id := range m.removedteam_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobFeedback:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_feedback))
		for id := range m.removedcandidate_job_feedback {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewEdges:
		ids := make([]ent.Value, 0, len(m.removedinterview_edges))
		for id := range m.removedinterview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_edges))
		for id := range m.removedcandidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateInterviewEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_interview_edges))
		for id := range m.removedcandidate_interview_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCandidateReferenceEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_reference_edges))
		for id := range m.removedcandidate_reference_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPermissionEdges:
		ids := make([]ent.Value, 0, len(m.removeduser_permission_edges))
		for id := range m.removeduser_permission_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoleEdges:
		ids := make([]ent.Value, 0, len(m.removedrole_edges))
		for id := range m.removedrole_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringTeamEdges:
		ids := make([]ent.Value, 0, len(m.removedhiring_team_edges))
		for id := range m.removedhiring_team_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamUsers:
		ids := make([]ent.Value, 0, len(m.removedteam_users))
		for id := range m.removedteam_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInterviewUsers:
		ids := make([]ent.Value, 0, len(m.removedinterview_users))
		for id := range m.removedinterview_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoleUsers:
		ids := make([]ent.Value, 0, len(m.removedrole_users))
		for id := range m.removedrole_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringTeamUsers:
		ids := make([]ent.Value, 0, len(m.removedhiring_team_users))
		for id := range m.removedhiring_team_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedaudit_edge {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.clearedhiring_owner {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.clearedteam_edges {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.clearedcandidate_job_feedback {
		edges = append(edges, user.EdgeCandidateJobFeedback)
	}
	if m.clearedinterview_edges {
		edges = append(edges, user.EdgeInterviewEdges)
	}
	if m.clearedcandidate_job_edges {
		edges = append(edges, user.EdgeCandidateJobEdges)
	}
	if m.clearedcandidate_interview_edges {
		edges = append(edges, user.EdgeCandidateInterviewEdges)
	}
	if m.clearedcandidate_reference_edges {
		edges = append(edges, user.EdgeCandidateReferenceEdges)
	}
	if m.cleareduser_permission_edges {
		edges = append(edges, user.EdgeUserPermissionEdges)
	}
	if m.clearedrole_edges {
		edges = append(edges, user.EdgeRoleEdges)
	}
	if m.clearedmember_of_team_edges {
		edges = append(edges, user.EdgeMemberOfTeamEdges)
	}
	if m.clearedhiring_team_edges {
		edges = append(edges, user.EdgeHiringTeamEdges)
	}
	if m.clearedteam_users {
		edges = append(edges, user.EdgeTeamUsers)
	}
	if m.clearedinterview_users {
		edges = append(edges, user.EdgeInterviewUsers)
	}
	if m.clearedrole_users {
		edges = append(edges, user.EdgeRoleUsers)
	}
	if m.clearedhiring_team_users {
		edges = append(edges, user.EdgeHiringTeamUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAuditEdge:
		return m.clearedaudit_edge
	case user.EdgeHiringOwner:
		return m.clearedhiring_owner
	case user.EdgeTeamEdges:
		return m.clearedteam_edges
	case user.EdgeCandidateJobFeedback:
		return m.clearedcandidate_job_feedback
	case user.EdgeInterviewEdges:
		return m.clearedinterview_edges
	case user.EdgeCandidateJobEdges:
		return m.clearedcandidate_job_edges
	case user.EdgeCandidateInterviewEdges:
		return m.clearedcandidate_interview_edges
	case user.EdgeCandidateReferenceEdges:
		return m.clearedcandidate_reference_edges
	case user.EdgeUserPermissionEdges:
		return m.cleareduser_permission_edges
	case user.EdgeRoleEdges:
		return m.clearedrole_edges
	case user.EdgeMemberOfTeamEdges:
		return m.clearedmember_of_team_edges
	case user.EdgeHiringTeamEdges:
		return m.clearedhiring_team_edges
	case user.EdgeTeamUsers:
		return m.clearedteam_users
	case user.EdgeInterviewUsers:
		return m.clearedinterview_users
	case user.EdgeRoleUsers:
		return m.clearedrole_users
	case user.EdgeHiringTeamUsers:
		return m.clearedhiring_team_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeMemberOfTeamEdges:
		m.ClearMemberOfTeamEdges()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAuditEdge:
		m.ResetAuditEdge()
		return nil
	case user.EdgeHiringOwner:
		m.ResetHiringOwner()
		return nil
	case user.EdgeTeamEdges:
		m.ResetTeamEdges()
		return nil
	case user.EdgeCandidateJobFeedback:
		m.ResetCandidateJobFeedback()
		return nil
	case user.EdgeInterviewEdges:
		m.ResetInterviewEdges()
		return nil
	case user.EdgeCandidateJobEdges:
		m.ResetCandidateJobEdges()
		return nil
	case user.EdgeCandidateInterviewEdges:
		m.ResetCandidateInterviewEdges()
		return nil
	case user.EdgeCandidateReferenceEdges:
		m.ResetCandidateReferenceEdges()
		return nil
	case user.EdgeUserPermissionEdges:
		m.ResetUserPermissionEdges()
		return nil
	case user.EdgeRoleEdges:
		m.ResetRoleEdges()
		return nil
	case user.EdgeMemberOfTeamEdges:
		m.ResetMemberOfTeamEdges()
		return nil
	case user.EdgeHiringTeamEdges:
		m.ResetHiringTeamEdges()
		return nil
	case user.EdgeTeamUsers:
		m.ResetTeamUsers()
		return nil
	case user.EdgeInterviewUsers:
		m.ResetInterviewUsers()
		return nil
	case user.EdgeRoleUsers:
		m.ResetRoleUsers()
		return nil
	case user.EdgeHiringTeamUsers:
		m.ResetHiringTeamUsers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRoleMutation represents an operation that mutates the UserRole nodes in the graph.
type UserRoleMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	user_edge        *uuid.UUID
	cleareduser_edge bool
	role_edge        *uuid.UUID
	clearedrole_edge bool
	done             bool
	oldValue         func(context.Context) (*UserRole, error)
	predicates       []predicate.UserRole
}

var _ ent.Mutation = (*UserRoleMutation)(nil)

// userroleOption allows management of the mutation configuration using functional options.
type userroleOption func(*UserRoleMutation)

// newUserRoleMutation creates new mutation for the UserRole entity.
func newUserRoleMutation(c config, op Op, opts ...userroleOption) *UserRoleMutation {
	m := &UserRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRoleID sets the ID field of the mutation.
func withUserRoleID(id uuid.UUID) userroleOption {
	return func(m *UserRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRole
		)
		m.oldValue = func(ctx context.Context) (*UserRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRole sets the old UserRole of the mutation.
func withUserRole(node *UserRole) userroleOption {
	return func(m *UserRoleMutation) {
		m.oldValue = func(context.Context) (*UserRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserRole entities.
func (m *UserRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userrole.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userrole.FieldDeletedAt)
}

// SetRoleID sets the "role_id" field.
func (m *UserRoleMutation) SetRoleID(u uuid.UUID) {
	m.role_edge = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserRoleMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserRoleMutation) ResetRoleID() {
	m.role_edge = nil
}

// SetUserID sets the "user_id" field.
func (m *UserRoleMutation) SetUserID(u uuid.UUID) {
	m.user_edge = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserRoleMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserRole entity.
// If the UserRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserRoleMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserRoleMutation) ResetUserID() {
	m.user_edge = nil
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *UserRoleMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *UserRoleMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *UserRoleMutation) UserEdgeCleared() bool {
	return m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *UserRoleMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *UserRoleMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetRoleEdgeID sets the "role_edge" edge to the Role entity by id.
func (m *UserRoleMutation) SetRoleEdgeID(id uuid.UUID) {
	m.role_edge = &id
}

// ClearRoleEdge clears the "role_edge" edge to the Role entity.
func (m *UserRoleMutation) ClearRoleEdge() {
	m.clearedrole_edge = true
}

// RoleEdgeCleared reports if the "role_edge" edge to the Role entity was cleared.
func (m *UserRoleMutation) RoleEdgeCleared() bool {
	return m.clearedrole_edge
}

// RoleEdgeID returns the "role_edge" edge ID in the mutation.
func (m *UserRoleMutation) RoleEdgeID() (id uuid.UUID, exists bool) {
	if m.role_edge != nil {
		return *m.role_edge, true
	}
	return
}

// RoleEdgeIDs returns the "role_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleEdgeID instead. It exists only for internal usage by the builders.
func (m *UserRoleMutation) RoleEdgeIDs() (ids []uuid.UUID) {
	if id := m.role_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleEdge resets all changes to the "role_edge" edge.
func (m *UserRoleMutation) ResetRoleEdge() {
	m.role_edge = nil
	m.clearedrole_edge = false
}

// Where appends a list predicates to the UserRoleMutation builder.
func (m *UserRoleMutation) Where(ps ...predicate.UserRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserRole).
func (m *UserRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, userrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	if m.role_edge != nil {
		fields = append(fields, userrole.FieldRoleID)
	}
	if m.user_edge != nil {
		fields = append(fields, userrole.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.CreatedAt()
	case userrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case userrole.FieldDeletedAt:
		return m.DeletedAt()
	case userrole.FieldRoleID:
		return m.RoleID()
	case userrole.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userrole.FieldRoleID:
		return m.OldRoleID(ctx)
	case userrole.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userrole.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case userrole.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userrole.FieldUpdatedAt) {
		fields = append(fields, userrole.FieldUpdatedAt)
	}
	if m.FieldCleared(userrole.FieldDeletedAt) {
		fields = append(fields, userrole.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRoleMutation) ClearField(name string) error {
	switch name {
	case userrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserRoleMutation) ResetField(name string) error {
	switch name {
	case userrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userrole.FieldRoleID:
		m.ResetRoleID()
		return nil
	case userrole.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UserRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_edge != nil {
		edges = append(edges, userrole.EdgeUserEdge)
	}
	if m.role_edge != nil {
		edges = append(edges, userrole.EdgeRoleEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrole.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case userrole.EdgeRoleEdge:
		if id := m.role_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_edge {
		edges = append(edges, userrole.EdgeUserEdge)
	}
	if m.clearedrole_edge {
		edges = append(edges, userrole.EdgeRoleEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case userrole.EdgeUserEdge:
		return m.cleareduser_edge
	case userrole.EdgeRoleEdge:
		return m.clearedrole_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserRoleMutation) ClearEdge(name string) error {
	switch name {
	case userrole.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case userrole.EdgeRoleEdge:
		m.ClearRoleEdge()
		return nil
	}
	return fmt.Errorf("unknown UserRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserRoleMutation) ResetEdge(name string) error {
	switch name {
	case userrole.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case userrole.EdgeRoleEdge:
		m.ResetRoleEdge()
		return nil
	}
	return fmt.Errorf("unknown UserRole edge %s", name)
}
