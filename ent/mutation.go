// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"trec/ent/attachment"
	"trec/ent/audittrail"
	"trec/ent/candidate"
	"trec/ent/candidatejob"
	"trec/ent/hiringjob"
	"trec/ent/predicate"
	"trec/ent/team"
	"trec/ent/teammanager"
	"trec/ent/user"

	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment   = "Attachment"
	TypeAuditTrail   = "AuditTrail"
	TypeCandidate    = "Candidate"
	TypeCandidateJob = "CandidateJob"
	TypeHiringJob    = "HiringJob"
	TypeTeam         = "Team"
	TypeTeamManager  = "TeamManager"
	TypeUser         = "User"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	document_id          *uuid.UUID
	document_name        *string
	relation_type        *attachment.RelationType
	clearedFields        map[string]struct{}
	candidate_job        *uuid.UUID
	clearedcandidate_job bool
	done                 bool
	oldValue             func(context.Context) (*Attachment, error)
	predicates           []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id uuid.UUID) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attachment entities.
func (m *AttachmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AttachmentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[attachment.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AttachmentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, attachment.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttachmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttachmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttachmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attachment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttachmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attachment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttachmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attachment.FieldDeletedAt)
}

// SetDocumentID sets the "document_id" field.
func (m *AttachmentMutation) SetDocumentID(u uuid.UUID) {
	m.document_id = &u
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *AttachmentMutation) DocumentID() (r uuid.UUID, exists bool) {
	v := m.document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDocumentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *AttachmentMutation) ResetDocumentID() {
	m.document_id = nil
}

// SetDocumentName sets the "document_name" field.
func (m *AttachmentMutation) SetDocumentName(s string) {
	m.document_name = &s
}

// DocumentName returns the value of the "document_name" field in the mutation.
func (m *AttachmentMutation) DocumentName() (r string, exists bool) {
	v := m.document_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentName returns the old "document_name" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldDocumentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentName: %w", err)
	}
	return oldValue.DocumentName, nil
}

// ResetDocumentName resets all changes to the "document_name" field.
func (m *AttachmentMutation) ResetDocumentName() {
	m.document_name = nil
}

// SetRelationType sets the "relation_type" field.
func (m *AttachmentMutation) SetRelationType(at attachment.RelationType) {
	m.relation_type = &at
}

// RelationType returns the value of the "relation_type" field in the mutation.
func (m *AttachmentMutation) RelationType() (r attachment.RelationType, exists bool) {
	v := m.relation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationType returns the old "relation_type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldRelationType(ctx context.Context) (v attachment.RelationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationType: %w", err)
	}
	return oldValue.RelationType, nil
}

// ResetRelationType resets all changes to the "relation_type" field.
func (m *AttachmentMutation) ResetRelationType() {
	m.relation_type = nil
}

// SetRelationID sets the "relation_id" field.
func (m *AttachmentMutation) SetRelationID(u uuid.UUID) {
	m.candidate_job = &u
}

// RelationID returns the value of the "relation_id" field in the mutation.
func (m *AttachmentMutation) RelationID() (r uuid.UUID, exists bool) {
	v := m.candidate_job
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationID returns the old "relation_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldRelationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationID: %w", err)
	}
	return oldValue.RelationID, nil
}

// ClearRelationID clears the value of the "relation_id" field.
func (m *AttachmentMutation) ClearRelationID() {
	m.candidate_job = nil
	m.clearedFields[attachment.FieldRelationID] = struct{}{}
}

// RelationIDCleared returns if the "relation_id" field was cleared in this mutation.
func (m *AttachmentMutation) RelationIDCleared() bool {
	_, ok := m.clearedFields[attachment.FieldRelationID]
	return ok
}

// ResetRelationID resets all changes to the "relation_id" field.
func (m *AttachmentMutation) ResetRelationID() {
	m.candidate_job = nil
	delete(m.clearedFields, attachment.FieldRelationID)
}

// SetCandidateJobID sets the "candidate_job" edge to the CandidateJob entity by id.
func (m *AttachmentMutation) SetCandidateJobID(id uuid.UUID) {
	m.candidate_job = &id
}

// ClearCandidateJob clears the "candidate_job" edge to the CandidateJob entity.
func (m *AttachmentMutation) ClearCandidateJob() {
	m.clearedcandidate_job = true
}

// CandidateJobCleared reports if the "candidate_job" edge to the CandidateJob entity was cleared.
func (m *AttachmentMutation) CandidateJobCleared() bool {
	return m.RelationIDCleared() || m.clearedcandidate_job
}

// CandidateJobID returns the "candidate_job" edge ID in the mutation.
func (m *AttachmentMutation) CandidateJobID() (id uuid.UUID, exists bool) {
	if m.candidate_job != nil {
		return *m.candidate_job, true
	}
	return
}

// CandidateJobIDs returns the "candidate_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateJobID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) CandidateJobIDs() (ids []uuid.UUID) {
	if id := m.candidate_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidateJob resets all changes to the "candidate_job" edge.
func (m *AttachmentMutation) ResetCandidateJob() {
	m.candidate_job = nil
	m.clearedcandidate_job = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.document_id != nil {
		fields = append(fields, attachment.FieldDocumentID)
	}
	if m.document_name != nil {
		fields = append(fields, attachment.FieldDocumentName)
	}
	if m.relation_type != nil {
		fields = append(fields, attachment.FieldRelationType)
	}
	if m.candidate_job != nil {
		fields = append(fields, attachment.FieldRelationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldDeletedAt:
		return m.DeletedAt()
	case attachment.FieldDocumentID:
		return m.DocumentID()
	case attachment.FieldDocumentName:
		return m.DocumentName()
	case attachment.FieldRelationType:
		return m.RelationType()
	case attachment.FieldRelationID:
		return m.RelationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attachment.FieldDocumentID:
		return m.OldDocumentID(ctx)
	case attachment.FieldDocumentName:
		return m.OldDocumentName(ctx)
	case attachment.FieldRelationType:
		return m.OldRelationType(ctx)
	case attachment.FieldRelationID:
		return m.OldRelationID(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attachment.FieldDocumentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	case attachment.FieldDocumentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentName(v)
		return nil
	case attachment.FieldRelationType:
		v, ok := value.(attachment.RelationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationType(v)
		return nil
	case attachment.FieldRelationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationID(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldUpdatedAt) {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.FieldCleared(attachment.FieldDeletedAt) {
		fields = append(fields, attachment.FieldDeletedAt)
	}
	if m.FieldCleared(attachment.FieldRelationID) {
		fields = append(fields, attachment.FieldRelationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attachment.FieldRelationID:
		m.ClearRelationID()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attachment.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	case attachment.FieldDocumentName:
		m.ResetDocumentName()
		return nil
	case attachment.FieldRelationType:
		m.ResetRelationType()
		return nil
	case attachment.FieldRelationID:
		m.ResetRelationID()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.candidate_job != nil {
		edges = append(edges, attachment.EdgeCandidateJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeCandidateJob:
		if id := m.candidate_job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcandidate_job {
		edges = append(edges, attachment.EdgeCandidateJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeCandidateJob:
		return m.clearedcandidate_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeCandidateJob:
		m.ClearCandidateJob()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeCandidateJob:
		m.ResetCandidateJob()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// AuditTrailMutation represents an operation that mutates the AuditTrail nodes in the graph.
type AuditTrailMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	recordId         *uuid.UUID
	module           *audittrail.Module
	actionType       *audittrail.ActionType
	note             *string
	record_changes   *string
	clearedFields    map[string]struct{}
	user_edge        *uuid.UUID
	cleareduser_edge bool
	done             bool
	oldValue         func(context.Context) (*AuditTrail, error)
	predicates       []predicate.AuditTrail
}

var _ ent.Mutation = (*AuditTrailMutation)(nil)

// audittrailOption allows management of the mutation configuration using functional options.
type audittrailOption func(*AuditTrailMutation)

// newAuditTrailMutation creates new mutation for the AuditTrail entity.
func newAuditTrailMutation(c config, op Op, opts ...audittrailOption) *AuditTrailMutation {
	m := &AuditTrailMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditTrail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditTrailID sets the ID field of the mutation.
func withAuditTrailID(id uuid.UUID) audittrailOption {
	return func(m *AuditTrailMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditTrail
		)
		m.oldValue = func(ctx context.Context) (*AuditTrail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditTrail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditTrail sets the old AuditTrail of the mutation.
func withAuditTrail(node *AuditTrail) audittrailOption {
	return func(m *AuditTrailMutation) {
		m.oldValue = func(context.Context) (*AuditTrail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditTrailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditTrailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditTrail entities.
func (m *AuditTrailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditTrailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditTrailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditTrail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditTrailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditTrailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditTrailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuditTrailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuditTrailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AuditTrailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[audittrail.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AuditTrailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuditTrailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, audittrail.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuditTrailMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuditTrailMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuditTrailMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[audittrail.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuditTrailMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuditTrailMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, audittrail.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AuditTrailMutation) SetCreatedBy(u uuid.UUID) {
	m.user_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AuditTrailMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AuditTrailMutation) ClearCreatedBy() {
	m.user_edge = nil
	m.clearedFields[audittrail.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AuditTrailMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AuditTrailMutation) ResetCreatedBy() {
	m.user_edge = nil
	delete(m.clearedFields, audittrail.FieldCreatedBy)
}

// SetRecordId sets the "recordId" field.
func (m *AuditTrailMutation) SetRecordId(u uuid.UUID) {
	m.recordId = &u
}

// RecordId returns the value of the "recordId" field in the mutation.
func (m *AuditTrailMutation) RecordId() (r uuid.UUID, exists bool) {
	v := m.recordId
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordId returns the old "recordId" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldRecordId(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordId: %w", err)
	}
	return oldValue.RecordId, nil
}

// ResetRecordId resets all changes to the "recordId" field.
func (m *AuditTrailMutation) ResetRecordId() {
	m.recordId = nil
}

// SetModule sets the "module" field.
func (m *AuditTrailMutation) SetModule(a audittrail.Module) {
	m.module = &a
}

// Module returns the value of the "module" field in the mutation.
func (m *AuditTrailMutation) Module() (r audittrail.Module, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldModule(ctx context.Context) (v audittrail.Module, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *AuditTrailMutation) ResetModule() {
	m.module = nil
}

// SetActionType sets the "actionType" field.
func (m *AuditTrailMutation) SetActionType(at audittrail.ActionType) {
	m.actionType = &at
}

// ActionType returns the value of the "actionType" field in the mutation.
func (m *AuditTrailMutation) ActionType() (r audittrail.ActionType, exists bool) {
	v := m.actionType
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "actionType" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldActionType(ctx context.Context) (v audittrail.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ClearActionType clears the value of the "actionType" field.
func (m *AuditTrailMutation) ClearActionType() {
	m.actionType = nil
	m.clearedFields[audittrail.FieldActionType] = struct{}{}
}

// ActionTypeCleared returns if the "actionType" field was cleared in this mutation.
func (m *AuditTrailMutation) ActionTypeCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldActionType]
	return ok
}

// ResetActionType resets all changes to the "actionType" field.
func (m *AuditTrailMutation) ResetActionType() {
	m.actionType = nil
	delete(m.clearedFields, audittrail.FieldActionType)
}

// SetNote sets the "note" field.
func (m *AuditTrailMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *AuditTrailMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *AuditTrailMutation) ClearNote() {
	m.note = nil
	m.clearedFields[audittrail.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *AuditTrailMutation) NoteCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *AuditTrailMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, audittrail.FieldNote)
}

// SetRecordChanges sets the "record_changes" field.
func (m *AuditTrailMutation) SetRecordChanges(s string) {
	m.record_changes = &s
}

// RecordChanges returns the value of the "record_changes" field in the mutation.
func (m *AuditTrailMutation) RecordChanges() (r string, exists bool) {
	v := m.record_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordChanges returns the old "record_changes" field's value of the AuditTrail entity.
// If the AuditTrail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditTrailMutation) OldRecordChanges(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordChanges: %w", err)
	}
	return oldValue.RecordChanges, nil
}

// ClearRecordChanges clears the value of the "record_changes" field.
func (m *AuditTrailMutation) ClearRecordChanges() {
	m.record_changes = nil
	m.clearedFields[audittrail.FieldRecordChanges] = struct{}{}
}

// RecordChangesCleared returns if the "record_changes" field was cleared in this mutation.
func (m *AuditTrailMutation) RecordChangesCleared() bool {
	_, ok := m.clearedFields[audittrail.FieldRecordChanges]
	return ok
}

// ResetRecordChanges resets all changes to the "record_changes" field.
func (m *AuditTrailMutation) ResetRecordChanges() {
	m.record_changes = nil
	delete(m.clearedFields, audittrail.FieldRecordChanges)
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *AuditTrailMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *AuditTrailMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *AuditTrailMutation) UserEdgeCleared() bool {
	return m.CreatedByCleared() || m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *AuditTrailMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *AuditTrailMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *AuditTrailMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// Where appends a list predicates to the AuditTrailMutation builder.
func (m *AuditTrailMutation) Where(ps ...predicate.AuditTrail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuditTrailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuditTrail).
func (m *AuditTrailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditTrailMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, audittrail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, audittrail.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, audittrail.FieldDeletedAt)
	}
	if m.user_edge != nil {
		fields = append(fields, audittrail.FieldCreatedBy)
	}
	if m.recordId != nil {
		fields = append(fields, audittrail.FieldRecordId)
	}
	if m.module != nil {
		fields = append(fields, audittrail.FieldModule)
	}
	if m.actionType != nil {
		fields = append(fields, audittrail.FieldActionType)
	}
	if m.note != nil {
		fields = append(fields, audittrail.FieldNote)
	}
	if m.record_changes != nil {
		fields = append(fields, audittrail.FieldRecordChanges)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditTrailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case audittrail.FieldCreatedAt:
		return m.CreatedAt()
	case audittrail.FieldUpdatedAt:
		return m.UpdatedAt()
	case audittrail.FieldDeletedAt:
		return m.DeletedAt()
	case audittrail.FieldCreatedBy:
		return m.CreatedBy()
	case audittrail.FieldRecordId:
		return m.RecordId()
	case audittrail.FieldModule:
		return m.Module()
	case audittrail.FieldActionType:
		return m.ActionType()
	case audittrail.FieldNote:
		return m.Note()
	case audittrail.FieldRecordChanges:
		return m.RecordChanges()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditTrailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case audittrail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case audittrail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case audittrail.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case audittrail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case audittrail.FieldRecordId:
		return m.OldRecordId(ctx)
	case audittrail.FieldModule:
		return m.OldModule(ctx)
	case audittrail.FieldActionType:
		return m.OldActionType(ctx)
	case audittrail.FieldNote:
		return m.OldNote(ctx)
	case audittrail.FieldRecordChanges:
		return m.OldRecordChanges(ctx)
	}
	return nil, fmt.Errorf("unknown AuditTrail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditTrailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case audittrail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case audittrail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case audittrail.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case audittrail.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case audittrail.FieldRecordId:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordId(v)
		return nil
	case audittrail.FieldModule:
		v, ok := value.(audittrail.Module)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case audittrail.FieldActionType:
		v, ok := value.(audittrail.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case audittrail.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case audittrail.FieldRecordChanges:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordChanges(v)
		return nil
	}
	return fmt.Errorf("unknown AuditTrail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditTrailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditTrailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditTrailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditTrail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditTrailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(audittrail.FieldUpdatedAt) {
		fields = append(fields, audittrail.FieldUpdatedAt)
	}
	if m.FieldCleared(audittrail.FieldDeletedAt) {
		fields = append(fields, audittrail.FieldDeletedAt)
	}
	if m.FieldCleared(audittrail.FieldCreatedBy) {
		fields = append(fields, audittrail.FieldCreatedBy)
	}
	if m.FieldCleared(audittrail.FieldActionType) {
		fields = append(fields, audittrail.FieldActionType)
	}
	if m.FieldCleared(audittrail.FieldNote) {
		fields = append(fields, audittrail.FieldNote)
	}
	if m.FieldCleared(audittrail.FieldRecordChanges) {
		fields = append(fields, audittrail.FieldRecordChanges)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditTrailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditTrailMutation) ClearField(name string) error {
	switch name {
	case audittrail.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case audittrail.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case audittrail.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case audittrail.FieldActionType:
		m.ClearActionType()
		return nil
	case audittrail.FieldNote:
		m.ClearNote()
		return nil
	case audittrail.FieldRecordChanges:
		m.ClearRecordChanges()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditTrailMutation) ResetField(name string) error {
	switch name {
	case audittrail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case audittrail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case audittrail.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case audittrail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case audittrail.FieldRecordId:
		m.ResetRecordId()
		return nil
	case audittrail.FieldModule:
		m.ResetModule()
		return nil
	case audittrail.FieldActionType:
		m.ResetActionType()
		return nil
	case audittrail.FieldNote:
		m.ResetNote()
		return nil
	case audittrail.FieldRecordChanges:
		m.ResetRecordChanges()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditTrailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_edge != nil {
		edges = append(edges, audittrail.EdgeUserEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditTrailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case audittrail.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditTrailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditTrailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditTrailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_edge {
		edges = append(edges, audittrail.EdgeUserEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditTrailMutation) EdgeCleared(name string) bool {
	switch name {
	case audittrail.EdgeUserEdge:
		return m.cleareduser_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditTrailMutation) ClearEdge(name string) error {
	switch name {
	case audittrail.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditTrailMutation) ResetEdge(name string) error {
	switch name {
	case audittrail.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	}
	return fmt.Errorf("unknown AuditTrail edge %s", name)
}

// CandidateMutation represents an operation that mutates the Candidate nodes in the graph.
type CandidateMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	email         *string
	phone         *string
	dob           *time.Time
	is_blacklist  *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Candidate, error)
	predicates    []predicate.Candidate
}

var _ ent.Mutation = (*CandidateMutation)(nil)

// candidateOption allows management of the mutation configuration using functional options.
type candidateOption func(*CandidateMutation)

// newCandidateMutation creates new mutation for the Candidate entity.
func newCandidateMutation(c config, op Op, opts ...candidateOption) *CandidateMutation {
	m := &CandidateMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateID sets the ID field of the mutation.
func withCandidateID(id uuid.UUID) candidateOption {
	return func(m *CandidateMutation) {
		var (
			err   error
			once  sync.Once
			value *Candidate
		)
		m.oldValue = func(ctx context.Context) (*Candidate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Candidate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidate sets the old Candidate of the mutation.
func withCandidate(node *Candidate) candidateOption {
	return func(m *CandidateMutation) {
		m.oldValue = func(context.Context) (*Candidate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Candidate entities.
func (m *CandidateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Candidate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidate.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidate.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidate.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidate.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidate.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidate.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *CandidateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CandidateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CandidateMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *CandidateMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CandidateMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CandidateMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *CandidateMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *CandidateMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *CandidateMutation) ResetPhone() {
	m.phone = nil
}

// SetDob sets the "dob" field.
func (m *CandidateMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *CandidateMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ResetDob resets all changes to the "dob" field.
func (m *CandidateMutation) ResetDob() {
	m.dob = nil
}

// SetIsBlacklist sets the "is_blacklist" field.
func (m *CandidateMutation) SetIsBlacklist(b bool) {
	m.is_blacklist = &b
}

// IsBlacklist returns the value of the "is_blacklist" field in the mutation.
func (m *CandidateMutation) IsBlacklist() (r bool, exists bool) {
	v := m.is_blacklist
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBlacklist returns the old "is_blacklist" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldIsBlacklist(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBlacklist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBlacklist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBlacklist: %w", err)
	}
	return oldValue.IsBlacklist, nil
}

// ResetIsBlacklist resets all changes to the "is_blacklist" field.
func (m *CandidateMutation) ResetIsBlacklist() {
	m.is_blacklist = nil
}

// Where appends a list predicates to the CandidateMutation builder.
func (m *CandidateMutation) Where(ps ...predicate.Candidate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Candidate).
func (m *CandidateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, candidate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidate.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidate.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, candidate.FieldName)
	}
	if m.email != nil {
		fields = append(fields, candidate.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, candidate.FieldPhone)
	}
	if m.dob != nil {
		fields = append(fields, candidate.FieldDob)
	}
	if m.is_blacklist != nil {
		fields = append(fields, candidate.FieldIsBlacklist)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidate.FieldCreatedAt:
		return m.CreatedAt()
	case candidate.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidate.FieldDeletedAt:
		return m.DeletedAt()
	case candidate.FieldName:
		return m.Name()
	case candidate.FieldEmail:
		return m.Email()
	case candidate.FieldPhone:
		return m.Phone()
	case candidate.FieldDob:
		return m.Dob()
	case candidate.FieldIsBlacklist:
		return m.IsBlacklist()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidate.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidate.FieldName:
		return m.OldName(ctx)
	case candidate.FieldEmail:
		return m.OldEmail(ctx)
	case candidate.FieldPhone:
		return m.OldPhone(ctx)
	case candidate.FieldDob:
		return m.OldDob(ctx)
	case candidate.FieldIsBlacklist:
		return m.OldIsBlacklist(ctx)
	}
	return nil, fmt.Errorf("unknown Candidate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidate.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case candidate.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case candidate.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case candidate.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case candidate.FieldIsBlacklist:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBlacklist(v)
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Candidate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidate.FieldUpdatedAt) {
		fields = append(fields, candidate.FieldUpdatedAt)
	}
	if m.FieldCleared(candidate.FieldDeletedAt) {
		fields = append(fields, candidate.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateMutation) ClearField(name string) error {
	switch name {
	case candidate.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidate.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Candidate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateMutation) ResetField(name string) error {
	switch name {
	case candidate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidate.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidate.FieldName:
		m.ResetName()
		return nil
	case candidate.FieldEmail:
		m.ResetEmail()
		return nil
	case candidate.FieldPhone:
		m.ResetPhone()
		return nil
	case candidate.FieldDob:
		m.ResetDob()
		return nil
	case candidate.FieldIsBlacklist:
		m.ResetIsBlacklist()
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Candidate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Candidate edge %s", name)
}

// CandidateJobMutation represents an operation that mutates the CandidateJob nodes in the graph.
type CandidateJobMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	candidate_id            *uuid.UUID
	status                  *candidatejob.Status
	clearedFields           map[string]struct{}
	attachment_edges        map[uuid.UUID]struct{}
	removedattachment_edges map[uuid.UUID]struct{}
	clearedattachment_edges bool
	hiring_job              *uuid.UUID
	clearedhiring_job       bool
	done                    bool
	oldValue                func(context.Context) (*CandidateJob, error)
	predicates              []predicate.CandidateJob
}

var _ ent.Mutation = (*CandidateJobMutation)(nil)

// candidatejobOption allows management of the mutation configuration using functional options.
type candidatejobOption func(*CandidateJobMutation)

// newCandidateJobMutation creates new mutation for the CandidateJob entity.
func newCandidateJobMutation(c config, op Op, opts ...candidatejobOption) *CandidateJobMutation {
	m := &CandidateJobMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidateJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateJobID sets the ID field of the mutation.
func withCandidateJobID(id uuid.UUID) candidatejobOption {
	return func(m *CandidateJobMutation) {
		var (
			err   error
			once  sync.Once
			value *CandidateJob
		)
		m.oldValue = func(ctx context.Context) (*CandidateJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CandidateJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidateJob sets the old CandidateJob of the mutation.
func withCandidateJob(node *CandidateJob) candidatejobOption {
	return func(m *CandidateJobMutation) {
		m.oldValue = func(context.Context) (*CandidateJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CandidateJob entities.
func (m *CandidateJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CandidateJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CandidateJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CandidateJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CandidateJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CandidateJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CandidateJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CandidateJobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[candidatejob.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CandidateJobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CandidateJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, candidatejob.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CandidateJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CandidateJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CandidateJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[candidatejob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CandidateJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CandidateJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, candidatejob.FieldDeletedAt)
}

// SetHiringJobID sets the "hiring_job_id" field.
func (m *CandidateJobMutation) SetHiringJobID(u uuid.UUID) {
	m.hiring_job = &u
}

// HiringJobID returns the value of the "hiring_job_id" field in the mutation.
func (m *CandidateJobMutation) HiringJobID() (r uuid.UUID, exists bool) {
	v := m.hiring_job
	if v == nil {
		return
	}
	return *v, true
}

// OldHiringJobID returns the old "hiring_job_id" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldHiringJobID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHiringJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHiringJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiringJobID: %w", err)
	}
	return oldValue.HiringJobID, nil
}

// ClearHiringJobID clears the value of the "hiring_job_id" field.
func (m *CandidateJobMutation) ClearHiringJobID() {
	m.hiring_job = nil
	m.clearedFields[candidatejob.FieldHiringJobID] = struct{}{}
}

// HiringJobIDCleared returns if the "hiring_job_id" field was cleared in this mutation.
func (m *CandidateJobMutation) HiringJobIDCleared() bool {
	_, ok := m.clearedFields[candidatejob.FieldHiringJobID]
	return ok
}

// ResetHiringJobID resets all changes to the "hiring_job_id" field.
func (m *CandidateJobMutation) ResetHiringJobID() {
	m.hiring_job = nil
	delete(m.clearedFields, candidatejob.FieldHiringJobID)
}

// SetCandidateID sets the "candidate_id" field.
func (m *CandidateJobMutation) SetCandidateID(u uuid.UUID) {
	m.candidate_id = &u
}

// CandidateID returns the value of the "candidate_id" field in the mutation.
func (m *CandidateJobMutation) CandidateID() (r uuid.UUID, exists bool) {
	v := m.candidate_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateID returns the old "candidate_id" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldCandidateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateID: %w", err)
	}
	return oldValue.CandidateID, nil
}

// ResetCandidateID resets all changes to the "candidate_id" field.
func (m *CandidateJobMutation) ResetCandidateID() {
	m.candidate_id = nil
}

// SetStatus sets the "status" field.
func (m *CandidateJobMutation) SetStatus(c candidatejob.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CandidateJobMutation) Status() (r candidatejob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CandidateJob entity.
// If the CandidateJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateJobMutation) OldStatus(ctx context.Context) (v candidatejob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CandidateJobMutation) ResetStatus() {
	m.status = nil
}

// AddAttachmentEdgeIDs adds the "attachment_edges" edge to the Attachment entity by ids.
func (m *CandidateJobMutation) AddAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.attachment_edges == nil {
		m.attachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.attachment_edges[ids[i]] = struct{}{}
	}
}

// ClearAttachmentEdges clears the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobMutation) ClearAttachmentEdges() {
	m.clearedattachment_edges = true
}

// AttachmentEdgesCleared reports if the "attachment_edges" edge to the Attachment entity was cleared.
func (m *CandidateJobMutation) AttachmentEdgesCleared() bool {
	return m.clearedattachment_edges
}

// RemoveAttachmentEdgeIDs removes the "attachment_edges" edge to the Attachment entity by IDs.
func (m *CandidateJobMutation) RemoveAttachmentEdgeIDs(ids ...uuid.UUID) {
	if m.removedattachment_edges == nil {
		m.removedattachment_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.attachment_edges, ids[i])
		m.removedattachment_edges[ids[i]] = struct{}{}
	}
}

// RemovedAttachmentEdges returns the removed IDs of the "attachment_edges" edge to the Attachment entity.
func (m *CandidateJobMutation) RemovedAttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedattachment_edges {
		ids = append(ids, id)
	}
	return
}

// AttachmentEdgesIDs returns the "attachment_edges" edge IDs in the mutation.
func (m *CandidateJobMutation) AttachmentEdgesIDs() (ids []uuid.UUID) {
	for id := range m.attachment_edges {
		ids = append(ids, id)
	}
	return
}

// ResetAttachmentEdges resets all changes to the "attachment_edges" edge.
func (m *CandidateJobMutation) ResetAttachmentEdges() {
	m.attachment_edges = nil
	m.clearedattachment_edges = false
	m.removedattachment_edges = nil
}

// ClearHiringJob clears the "hiring_job" edge to the HiringJob entity.
func (m *CandidateJobMutation) ClearHiringJob() {
	m.clearedhiring_job = true
}

// HiringJobCleared reports if the "hiring_job" edge to the HiringJob entity was cleared.
func (m *CandidateJobMutation) HiringJobCleared() bool {
	return m.HiringJobIDCleared() || m.clearedhiring_job
}

// HiringJobIDs returns the "hiring_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HiringJobID instead. It exists only for internal usage by the builders.
func (m *CandidateJobMutation) HiringJobIDs() (ids []uuid.UUID) {
	if id := m.hiring_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHiringJob resets all changes to the "hiring_job" edge.
func (m *CandidateJobMutation) ResetHiringJob() {
	m.hiring_job = nil
	m.clearedhiring_job = false
}

// Where appends a list predicates to the CandidateJobMutation builder.
func (m *CandidateJobMutation) Where(ps ...predicate.CandidateJob) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CandidateJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CandidateJob).
func (m *CandidateJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateJobMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, candidatejob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, candidatejob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, candidatejob.FieldDeletedAt)
	}
	if m.hiring_job != nil {
		fields = append(fields, candidatejob.FieldHiringJobID)
	}
	if m.candidate_id != nil {
		fields = append(fields, candidatejob.FieldCandidateID)
	}
	if m.status != nil {
		fields = append(fields, candidatejob.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidatejob.FieldCreatedAt:
		return m.CreatedAt()
	case candidatejob.FieldUpdatedAt:
		return m.UpdatedAt()
	case candidatejob.FieldDeletedAt:
		return m.DeletedAt()
	case candidatejob.FieldHiringJobID:
		return m.HiringJobID()
	case candidatejob.FieldCandidateID:
		return m.CandidateID()
	case candidatejob.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidatejob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case candidatejob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case candidatejob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case candidatejob.FieldHiringJobID:
		return m.OldHiringJobID(ctx)
	case candidatejob.FieldCandidateID:
		return m.OldCandidateID(ctx)
	case candidatejob.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown CandidateJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidatejob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case candidatejob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case candidatejob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case candidatejob.FieldHiringJobID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiringJobID(v)
		return nil
	case candidatejob.FieldCandidateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateID(v)
		return nil
	case candidatejob.FieldStatus:
		v, ok := value.(candidatejob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CandidateJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CandidateJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidatejob.FieldUpdatedAt) {
		fields = append(fields, candidatejob.FieldUpdatedAt)
	}
	if m.FieldCleared(candidatejob.FieldDeletedAt) {
		fields = append(fields, candidatejob.FieldDeletedAt)
	}
	if m.FieldCleared(candidatejob.FieldHiringJobID) {
		fields = append(fields, candidatejob.FieldHiringJobID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateJobMutation) ClearField(name string) error {
	switch name {
	case candidatejob.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case candidatejob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case candidatejob.FieldHiringJobID:
		m.ClearHiringJobID()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateJobMutation) ResetField(name string) error {
	switch name {
	case candidatejob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case candidatejob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case candidatejob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case candidatejob.FieldHiringJobID:
		m.ResetHiringJobID()
		return nil
	case candidatejob.FieldCandidateID:
		m.ResetCandidateID()
		return nil
	case candidatejob.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.attachment_edges != nil {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.hiring_job != nil {
		edges = append(edges, candidatejob.EdgeHiringJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.attachment_edges))
		for id := range m.attachment_edges {
			ids = append(ids, id)
		}
		return ids
	case candidatejob.EdgeHiringJob:
		if id := m.hiring_job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattachment_edges != nil {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		ids := make([]ent.Value, 0, len(m.removedattachment_edges))
		for id := range m.removedattachment_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedattachment_edges {
		edges = append(edges, candidatejob.EdgeAttachmentEdges)
	}
	if m.clearedhiring_job {
		edges = append(edges, candidatejob.EdgeHiringJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateJobMutation) EdgeCleared(name string) bool {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		return m.clearedattachment_edges
	case candidatejob.EdgeHiringJob:
		return m.clearedhiring_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateJobMutation) ClearEdge(name string) error {
	switch name {
	case candidatejob.EdgeHiringJob:
		m.ClearHiringJob()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateJobMutation) ResetEdge(name string) error {
	switch name {
	case candidatejob.EdgeAttachmentEdges:
		m.ResetAttachmentEdges()
		return nil
	case candidatejob.EdgeHiringJob:
		m.ResetHiringJob()
		return nil
	}
	return fmt.Errorf("unknown CandidateJob edge %s", name)
}

// HiringJobMutation represents an operation that mutates the HiringJob nodes in the graph.
type HiringJobMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	slug                       *string
	name                       *string
	description                *string
	amount                     *int
	addamount                  *int
	status                     *hiringjob.Status
	location                   *hiringjob.Location
	salary_type                *hiringjob.SalaryType
	salary_from                *int
	addsalary_from             *int
	salary_to                  *int
	addsalary_to               *int
	currency                   *hiringjob.Currency
	clearedFields              map[string]struct{}
	owner_edge                 *uuid.UUID
	clearedowner_edge          bool
	team_edge                  *uuid.UUID
	clearedteam_edge           bool
	candidate_job_edges        map[uuid.UUID]struct{}
	removedcandidate_job_edges map[uuid.UUID]struct{}
	clearedcandidate_job_edges bool
	done                       bool
	oldValue                   func(context.Context) (*HiringJob, error)
	predicates                 []predicate.HiringJob
}

var _ ent.Mutation = (*HiringJobMutation)(nil)

// hiringjobOption allows management of the mutation configuration using functional options.
type hiringjobOption func(*HiringJobMutation)

// newHiringJobMutation creates new mutation for the HiringJob entity.
func newHiringJobMutation(c config, op Op, opts ...hiringjobOption) *HiringJobMutation {
	m := &HiringJobMutation{
		config:        c,
		op:            op,
		typ:           TypeHiringJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHiringJobID sets the ID field of the mutation.
func withHiringJobID(id uuid.UUID) hiringjobOption {
	return func(m *HiringJobMutation) {
		var (
			err   error
			once  sync.Once
			value *HiringJob
		)
		m.oldValue = func(ctx context.Context) (*HiringJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HiringJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHiringJob sets the old HiringJob of the mutation.
func withHiringJob(node *HiringJob) hiringjobOption {
	return func(m *HiringJobMutation) {
		m.oldValue = func(context.Context) (*HiringJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HiringJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HiringJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HiringJob entities.
func (m *HiringJobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HiringJobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HiringJobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HiringJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HiringJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HiringJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HiringJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HiringJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HiringJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *HiringJobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[hiringjob.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *HiringJobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HiringJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, hiringjob.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HiringJobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HiringJobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HiringJobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hiringjob.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HiringJobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HiringJobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hiringjob.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *HiringJobMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *HiringJobMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *HiringJobMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *HiringJobMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HiringJobMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HiringJobMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *HiringJobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HiringJobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HiringJobMutation) ResetDescription() {
	m.description = nil
}

// SetAmount sets the "amount" field.
func (m *HiringJobMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *HiringJobMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *HiringJobMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *HiringJobMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *HiringJobMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *HiringJobMutation) SetStatus(h hiringjob.Status) {
	m.status = &h
}

// Status returns the value of the "status" field in the mutation.
func (m *HiringJobMutation) Status() (r hiringjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldStatus(ctx context.Context) (v hiringjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HiringJobMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *HiringJobMutation) SetCreatedBy(u uuid.UUID) {
	m.owner_edge = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HiringJobMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.owner_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *HiringJobMutation) ClearCreatedBy() {
	m.owner_edge = nil
	m.clearedFields[hiringjob.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *HiringJobMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HiringJobMutation) ResetCreatedBy() {
	m.owner_edge = nil
	delete(m.clearedFields, hiringjob.FieldCreatedBy)
}

// SetTeamID sets the "team_id" field.
func (m *HiringJobMutation) SetTeamID(u uuid.UUID) {
	m.team_edge = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HiringJobMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *HiringJobMutation) ClearTeamID() {
	m.team_edge = nil
	m.clearedFields[hiringjob.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *HiringJobMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[hiringjob.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HiringJobMutation) ResetTeamID() {
	m.team_edge = nil
	delete(m.clearedFields, hiringjob.FieldTeamID)
}

// SetLocation sets the "location" field.
func (m *HiringJobMutation) SetLocation(h hiringjob.Location) {
	m.location = &h
}

// Location returns the value of the "location" field in the mutation.
func (m *HiringJobMutation) Location() (r hiringjob.Location, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldLocation(ctx context.Context) (v hiringjob.Location, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *HiringJobMutation) ResetLocation() {
	m.location = nil
}

// SetSalaryType sets the "salary_type" field.
func (m *HiringJobMutation) SetSalaryType(ht hiringjob.SalaryType) {
	m.salary_type = &ht
}

// SalaryType returns the value of the "salary_type" field in the mutation.
func (m *HiringJobMutation) SalaryType() (r hiringjob.SalaryType, exists bool) {
	v := m.salary_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryType returns the old "salary_type" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryType(ctx context.Context) (v hiringjob.SalaryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryType: %w", err)
	}
	return oldValue.SalaryType, nil
}

// ResetSalaryType resets all changes to the "salary_type" field.
func (m *HiringJobMutation) ResetSalaryType() {
	m.salary_type = nil
}

// SetSalaryFrom sets the "salary_from" field.
func (m *HiringJobMutation) SetSalaryFrom(i int) {
	m.salary_from = &i
	m.addsalary_from = nil
}

// SalaryFrom returns the value of the "salary_from" field in the mutation.
func (m *HiringJobMutation) SalaryFrom() (r int, exists bool) {
	v := m.salary_from
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryFrom returns the old "salary_from" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryFrom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryFrom: %w", err)
	}
	return oldValue.SalaryFrom, nil
}

// AddSalaryFrom adds i to the "salary_from" field.
func (m *HiringJobMutation) AddSalaryFrom(i int) {
	if m.addsalary_from != nil {
		*m.addsalary_from += i
	} else {
		m.addsalary_from = &i
	}
}

// AddedSalaryFrom returns the value that was added to the "salary_from" field in this mutation.
func (m *HiringJobMutation) AddedSalaryFrom() (r int, exists bool) {
	v := m.addsalary_from
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalaryFrom resets all changes to the "salary_from" field.
func (m *HiringJobMutation) ResetSalaryFrom() {
	m.salary_from = nil
	m.addsalary_from = nil
}

// SetSalaryTo sets the "salary_to" field.
func (m *HiringJobMutation) SetSalaryTo(i int) {
	m.salary_to = &i
	m.addsalary_to = nil
}

// SalaryTo returns the value of the "salary_to" field in the mutation.
func (m *HiringJobMutation) SalaryTo() (r int, exists bool) {
	v := m.salary_to
	if v == nil {
		return
	}
	return *v, true
}

// OldSalaryTo returns the old "salary_to" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldSalaryTo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalaryTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalaryTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalaryTo: %w", err)
	}
	return oldValue.SalaryTo, nil
}

// AddSalaryTo adds i to the "salary_to" field.
func (m *HiringJobMutation) AddSalaryTo(i int) {
	if m.addsalary_to != nil {
		*m.addsalary_to += i
	} else {
		m.addsalary_to = &i
	}
}

// AddedSalaryTo returns the value that was added to the "salary_to" field in this mutation.
func (m *HiringJobMutation) AddedSalaryTo() (r int, exists bool) {
	v := m.addsalary_to
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalaryTo resets all changes to the "salary_to" field.
func (m *HiringJobMutation) ResetSalaryTo() {
	m.salary_to = nil
	m.addsalary_to = nil
}

// SetCurrency sets the "currency" field.
func (m *HiringJobMutation) SetCurrency(h hiringjob.Currency) {
	m.currency = &h
}

// Currency returns the value of the "currency" field in the mutation.
func (m *HiringJobMutation) Currency() (r hiringjob.Currency, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the HiringJob entity.
// If the HiringJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiringJobMutation) OldCurrency(ctx context.Context) (v hiringjob.Currency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *HiringJobMutation) ResetCurrency() {
	m.currency = nil
}

// SetOwnerEdgeID sets the "owner_edge" edge to the User entity by id.
func (m *HiringJobMutation) SetOwnerEdgeID(id uuid.UUID) {
	m.owner_edge = &id
}

// ClearOwnerEdge clears the "owner_edge" edge to the User entity.
func (m *HiringJobMutation) ClearOwnerEdge() {
	m.clearedowner_edge = true
}

// OwnerEdgeCleared reports if the "owner_edge" edge to the User entity was cleared.
func (m *HiringJobMutation) OwnerEdgeCleared() bool {
	return m.CreatedByCleared() || m.clearedowner_edge
}

// OwnerEdgeID returns the "owner_edge" edge ID in the mutation.
func (m *HiringJobMutation) OwnerEdgeID() (id uuid.UUID, exists bool) {
	if m.owner_edge != nil {
		return *m.owner_edge, true
	}
	return
}

// OwnerEdgeIDs returns the "owner_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringJobMutation) OwnerEdgeIDs() (ids []uuid.UUID) {
	if id := m.owner_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwnerEdge resets all changes to the "owner_edge" edge.
func (m *HiringJobMutation) ResetOwnerEdge() {
	m.owner_edge = nil
	m.clearedowner_edge = false
}

// SetTeamEdgeID sets the "team_edge" edge to the Team entity by id.
func (m *HiringJobMutation) SetTeamEdgeID(id uuid.UUID) {
	m.team_edge = &id
}

// ClearTeamEdge clears the "team_edge" edge to the Team entity.
func (m *HiringJobMutation) ClearTeamEdge() {
	m.clearedteam_edge = true
}

// TeamEdgeCleared reports if the "team_edge" edge to the Team entity was cleared.
func (m *HiringJobMutation) TeamEdgeCleared() bool {
	return m.TeamIDCleared() || m.clearedteam_edge
}

// TeamEdgeID returns the "team_edge" edge ID in the mutation.
func (m *HiringJobMutation) TeamEdgeID() (id uuid.UUID, exists bool) {
	if m.team_edge != nil {
		return *m.team_edge, true
	}
	return
}

// TeamEdgeIDs returns the "team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamEdgeID instead. It exists only for internal usage by the builders.
func (m *HiringJobMutation) TeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamEdge resets all changes to the "team_edge" edge.
func (m *HiringJobMutation) ResetTeamEdge() {
	m.team_edge = nil
	m.clearedteam_edge = false
}

// AddCandidateJobEdgeIDs adds the "candidate_job_edges" edge to the CandidateJob entity by ids.
func (m *HiringJobMutation) AddCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.candidate_job_edges == nil {
		m.candidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.candidate_job_edges[ids[i]] = struct{}{}
	}
}

// ClearCandidateJobEdges clears the "candidate_job_edges" edge to the CandidateJob entity.
func (m *HiringJobMutation) ClearCandidateJobEdges() {
	m.clearedcandidate_job_edges = true
}

// CandidateJobEdgesCleared reports if the "candidate_job_edges" edge to the CandidateJob entity was cleared.
func (m *HiringJobMutation) CandidateJobEdgesCleared() bool {
	return m.clearedcandidate_job_edges
}

// RemoveCandidateJobEdgeIDs removes the "candidate_job_edges" edge to the CandidateJob entity by IDs.
func (m *HiringJobMutation) RemoveCandidateJobEdgeIDs(ids ...uuid.UUID) {
	if m.removedcandidate_job_edges == nil {
		m.removedcandidate_job_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.candidate_job_edges, ids[i])
		m.removedcandidate_job_edges[ids[i]] = struct{}{}
	}
}

// RemovedCandidateJobEdges returns the removed IDs of the "candidate_job_edges" edge to the CandidateJob entity.
func (m *HiringJobMutation) RemovedCandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedcandidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// CandidateJobEdgesIDs returns the "candidate_job_edges" edge IDs in the mutation.
func (m *HiringJobMutation) CandidateJobEdgesIDs() (ids []uuid.UUID) {
	for id := range m.candidate_job_edges {
		ids = append(ids, id)
	}
	return
}

// ResetCandidateJobEdges resets all changes to the "candidate_job_edges" edge.
func (m *HiringJobMutation) ResetCandidateJobEdges() {
	m.candidate_job_edges = nil
	m.clearedcandidate_job_edges = false
	m.removedcandidate_job_edges = nil
}

// Where appends a list predicates to the HiringJobMutation builder.
func (m *HiringJobMutation) Where(ps ...predicate.HiringJob) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HiringJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HiringJob).
func (m *HiringJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HiringJobMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, hiringjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hiringjob.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hiringjob.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, hiringjob.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, hiringjob.FieldName)
	}
	if m.description != nil {
		fields = append(fields, hiringjob.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, hiringjob.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, hiringjob.FieldStatus)
	}
	if m.owner_edge != nil {
		fields = append(fields, hiringjob.FieldCreatedBy)
	}
	if m.team_edge != nil {
		fields = append(fields, hiringjob.FieldTeamID)
	}
	if m.location != nil {
		fields = append(fields, hiringjob.FieldLocation)
	}
	if m.salary_type != nil {
		fields = append(fields, hiringjob.FieldSalaryType)
	}
	if m.salary_from != nil {
		fields = append(fields, hiringjob.FieldSalaryFrom)
	}
	if m.salary_to != nil {
		fields = append(fields, hiringjob.FieldSalaryTo)
	}
	if m.currency != nil {
		fields = append(fields, hiringjob.FieldCurrency)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HiringJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hiringjob.FieldCreatedAt:
		return m.CreatedAt()
	case hiringjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case hiringjob.FieldDeletedAt:
		return m.DeletedAt()
	case hiringjob.FieldSlug:
		return m.Slug()
	case hiringjob.FieldName:
		return m.Name()
	case hiringjob.FieldDescription:
		return m.Description()
	case hiringjob.FieldAmount:
		return m.Amount()
	case hiringjob.FieldStatus:
		return m.Status()
	case hiringjob.FieldCreatedBy:
		return m.CreatedBy()
	case hiringjob.FieldTeamID:
		return m.TeamID()
	case hiringjob.FieldLocation:
		return m.Location()
	case hiringjob.FieldSalaryType:
		return m.SalaryType()
	case hiringjob.FieldSalaryFrom:
		return m.SalaryFrom()
	case hiringjob.FieldSalaryTo:
		return m.SalaryTo()
	case hiringjob.FieldCurrency:
		return m.Currency()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HiringJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hiringjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hiringjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hiringjob.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case hiringjob.FieldSlug:
		return m.OldSlug(ctx)
	case hiringjob.FieldName:
		return m.OldName(ctx)
	case hiringjob.FieldDescription:
		return m.OldDescription(ctx)
	case hiringjob.FieldAmount:
		return m.OldAmount(ctx)
	case hiringjob.FieldStatus:
		return m.OldStatus(ctx)
	case hiringjob.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hiringjob.FieldTeamID:
		return m.OldTeamID(ctx)
	case hiringjob.FieldLocation:
		return m.OldLocation(ctx)
	case hiringjob.FieldSalaryType:
		return m.OldSalaryType(ctx)
	case hiringjob.FieldSalaryFrom:
		return m.OldSalaryFrom(ctx)
	case hiringjob.FieldSalaryTo:
		return m.OldSalaryTo(ctx)
	case hiringjob.FieldCurrency:
		return m.OldCurrency(ctx)
	}
	return nil, fmt.Errorf("unknown HiringJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hiringjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hiringjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hiringjob.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case hiringjob.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case hiringjob.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hiringjob.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hiringjob.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case hiringjob.FieldStatus:
		v, ok := value.(hiringjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hiringjob.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hiringjob.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case hiringjob.FieldLocation:
		v, ok := value.(hiringjob.Location)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case hiringjob.FieldSalaryType:
		v, ok := value.(hiringjob.SalaryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryType(v)
		return nil
	case hiringjob.FieldSalaryFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryFrom(v)
		return nil
	case hiringjob.FieldSalaryTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalaryTo(v)
		return nil
	case hiringjob.FieldCurrency:
		v, ok := value.(hiringjob.Currency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	}
	return fmt.Errorf("unknown HiringJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HiringJobMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, hiringjob.FieldAmount)
	}
	if m.addsalary_from != nil {
		fields = append(fields, hiringjob.FieldSalaryFrom)
	}
	if m.addsalary_to != nil {
		fields = append(fields, hiringjob.FieldSalaryTo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HiringJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hiringjob.FieldAmount:
		return m.AddedAmount()
	case hiringjob.FieldSalaryFrom:
		return m.AddedSalaryFrom()
	case hiringjob.FieldSalaryTo:
		return m.AddedSalaryTo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiringJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hiringjob.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case hiringjob.FieldSalaryFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryFrom(v)
		return nil
	case hiringjob.FieldSalaryTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalaryTo(v)
		return nil
	}
	return fmt.Errorf("unknown HiringJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HiringJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hiringjob.FieldUpdatedAt) {
		fields = append(fields, hiringjob.FieldUpdatedAt)
	}
	if m.FieldCleared(hiringjob.FieldDeletedAt) {
		fields = append(fields, hiringjob.FieldDeletedAt)
	}
	if m.FieldCleared(hiringjob.FieldCreatedBy) {
		fields = append(fields, hiringjob.FieldCreatedBy)
	}
	if m.FieldCleared(hiringjob.FieldTeamID) {
		fields = append(fields, hiringjob.FieldTeamID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HiringJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HiringJobMutation) ClearField(name string) error {
	switch name {
	case hiringjob.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case hiringjob.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case hiringjob.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case hiringjob.FieldTeamID:
		m.ClearTeamID()
		return nil
	}
	return fmt.Errorf("unknown HiringJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HiringJobMutation) ResetField(name string) error {
	switch name {
	case hiringjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hiringjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hiringjob.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case hiringjob.FieldSlug:
		m.ResetSlug()
		return nil
	case hiringjob.FieldName:
		m.ResetName()
		return nil
	case hiringjob.FieldDescription:
		m.ResetDescription()
		return nil
	case hiringjob.FieldAmount:
		m.ResetAmount()
		return nil
	case hiringjob.FieldStatus:
		m.ResetStatus()
		return nil
	case hiringjob.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hiringjob.FieldTeamID:
		m.ResetTeamID()
		return nil
	case hiringjob.FieldLocation:
		m.ResetLocation()
		return nil
	case hiringjob.FieldSalaryType:
		m.ResetSalaryType()
		return nil
	case hiringjob.FieldSalaryFrom:
		m.ResetSalaryFrom()
		return nil
	case hiringjob.FieldSalaryTo:
		m.ResetSalaryTo()
		return nil
	case hiringjob.FieldCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown HiringJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HiringJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner_edge != nil {
		edges = append(edges, hiringjob.EdgeOwnerEdge)
	}
	if m.team_edge != nil {
		edges = append(edges, hiringjob.EdgeTeamEdge)
	}
	if m.candidate_job_edges != nil {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HiringJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		if id := m.owner_edge; id != nil {
			return []ent.Value{*id}
		}
	case hiringjob.EdgeTeamEdge:
		if id := m.team_edge; id != nil {
			return []ent.Value{*id}
		}
	case hiringjob.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.candidate_job_edges))
		for id := range m.candidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HiringJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcandidate_job_edges != nil {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HiringJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hiringjob.EdgeCandidateJobEdges:
		ids := make([]ent.Value, 0, len(m.removedcandidate_job_edges))
		for id := range m.removedcandidate_job_edges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HiringJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner_edge {
		edges = append(edges, hiringjob.EdgeOwnerEdge)
	}
	if m.clearedteam_edge {
		edges = append(edges, hiringjob.EdgeTeamEdge)
	}
	if m.clearedcandidate_job_edges {
		edges = append(edges, hiringjob.EdgeCandidateJobEdges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HiringJobMutation) EdgeCleared(name string) bool {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		return m.clearedowner_edge
	case hiringjob.EdgeTeamEdge:
		return m.clearedteam_edge
	case hiringjob.EdgeCandidateJobEdges:
		return m.clearedcandidate_job_edges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HiringJobMutation) ClearEdge(name string) error {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		m.ClearOwnerEdge()
		return nil
	case hiringjob.EdgeTeamEdge:
		m.ClearTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown HiringJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HiringJobMutation) ResetEdge(name string) error {
	switch name {
	case hiringjob.EdgeOwnerEdge:
		m.ResetOwnerEdge()
		return nil
	case hiringjob.EdgeTeamEdge:
		m.ResetTeamEdge()
		return nil
	case hiringjob.EdgeCandidateJobEdges:
		m.ResetCandidateJobEdges()
		return nil
	}
	return fmt.Errorf("unknown HiringJob edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	slug               *string
	name               *string
	clearedFields      map[string]struct{}
	user_edges         map[uuid.UUID]struct{}
	removeduser_edges  map[uuid.UUID]struct{}
	cleareduser_edges  bool
	hiring_team        map[uuid.UUID]struct{}
	removedhiring_team map[uuid.UUID]struct{}
	clearedhiring_team bool
	user_teams         map[uuid.UUID]struct{}
	removeduser_teams  map[uuid.UUID]struct{}
	cleareduser_teams  bool
	done               bool
	oldValue           func(context.Context) (*Team, error)
	predicates         []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[team.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, team.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeamMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeamMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeamMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[team.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeamMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeamMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, team.FieldDeletedAt)
}

// SetSlug sets the "slug" field.
func (m *TeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// AddUserEdgeIDs adds the "user_edges" edge to the User entity by ids.
func (m *TeamMutation) AddUserEdgeIDs(ids ...uuid.UUID) {
	if m.user_edges == nil {
		m.user_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_edges[ids[i]] = struct{}{}
	}
}

// ClearUserEdges clears the "user_edges" edge to the User entity.
func (m *TeamMutation) ClearUserEdges() {
	m.cleareduser_edges = true
}

// UserEdgesCleared reports if the "user_edges" edge to the User entity was cleared.
func (m *TeamMutation) UserEdgesCleared() bool {
	return m.cleareduser_edges
}

// RemoveUserEdgeIDs removes the "user_edges" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserEdgeIDs(ids ...uuid.UUID) {
	if m.removeduser_edges == nil {
		m.removeduser_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_edges, ids[i])
		m.removeduser_edges[ids[i]] = struct{}{}
	}
}

// RemovedUserEdges returns the removed IDs of the "user_edges" edge to the User entity.
func (m *TeamMutation) RemovedUserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_edges {
		ids = append(ids, id)
	}
	return
}

// UserEdgesIDs returns the "user_edges" edge IDs in the mutation.
func (m *TeamMutation) UserEdgesIDs() (ids []uuid.UUID) {
	for id := range m.user_edges {
		ids = append(ids, id)
	}
	return
}

// ResetUserEdges resets all changes to the "user_edges" edge.
func (m *TeamMutation) ResetUserEdges() {
	m.user_edges = nil
	m.cleareduser_edges = false
	m.removeduser_edges = nil
}

// AddHiringTeamIDs adds the "hiring_team" edge to the HiringJob entity by ids.
func (m *TeamMutation) AddHiringTeamIDs(ids ...uuid.UUID) {
	if m.hiring_team == nil {
		m.hiring_team = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_team[ids[i]] = struct{}{}
	}
}

// ClearHiringTeam clears the "hiring_team" edge to the HiringJob entity.
func (m *TeamMutation) ClearHiringTeam() {
	m.clearedhiring_team = true
}

// HiringTeamCleared reports if the "hiring_team" edge to the HiringJob entity was cleared.
func (m *TeamMutation) HiringTeamCleared() bool {
	return m.clearedhiring_team
}

// RemoveHiringTeamIDs removes the "hiring_team" edge to the HiringJob entity by IDs.
func (m *TeamMutation) RemoveHiringTeamIDs(ids ...uuid.UUID) {
	if m.removedhiring_team == nil {
		m.removedhiring_team = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_team, ids[i])
		m.removedhiring_team[ids[i]] = struct{}{}
	}
}

// RemovedHiringTeam returns the removed IDs of the "hiring_team" edge to the HiringJob entity.
func (m *TeamMutation) RemovedHiringTeamIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_team {
		ids = append(ids, id)
	}
	return
}

// HiringTeamIDs returns the "hiring_team" edge IDs in the mutation.
func (m *TeamMutation) HiringTeamIDs() (ids []uuid.UUID) {
	for id := range m.hiring_team {
		ids = append(ids, id)
	}
	return
}

// ResetHiringTeam resets all changes to the "hiring_team" edge.
func (m *TeamMutation) ResetHiringTeam() {
	m.hiring_team = nil
	m.clearedhiring_team = false
	m.removedhiring_team = nil
}

// AddUserTeamIDs adds the "user_teams" edge to the TeamManager entity by ids.
func (m *TeamMutation) AddUserTeamIDs(ids ...uuid.UUID) {
	if m.user_teams == nil {
		m.user_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_teams[ids[i]] = struct{}{}
	}
}

// ClearUserTeams clears the "user_teams" edge to the TeamManager entity.
func (m *TeamMutation) ClearUserTeams() {
	m.cleareduser_teams = true
}

// UserTeamsCleared reports if the "user_teams" edge to the TeamManager entity was cleared.
func (m *TeamMutation) UserTeamsCleared() bool {
	return m.cleareduser_teams
}

// RemoveUserTeamIDs removes the "user_teams" edge to the TeamManager entity by IDs.
func (m *TeamMutation) RemoveUserTeamIDs(ids ...uuid.UUID) {
	if m.removeduser_teams == nil {
		m.removeduser_teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_teams, ids[i])
		m.removeduser_teams[ids[i]] = struct{}{}
	}
}

// RemovedUserTeams returns the removed IDs of the "user_teams" edge to the TeamManager entity.
func (m *TeamMutation) RemovedUserTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_teams {
		ids = append(ids, id)
	}
	return
}

// UserTeamsIDs returns the "user_teams" edge IDs in the mutation.
func (m *TeamMutation) UserTeamsIDs() (ids []uuid.UUID) {
	for id := range m.user_teams {
		ids = append(ids, id)
	}
	return
}

// ResetUserTeams resets all changes to the "user_teams" edge.
func (m *TeamMutation) ResetUserTeams() {
	m.user_teams = nil
	m.cleareduser_teams = false
	m.removeduser_teams = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, team.FieldDeletedAt)
	}
	if m.slug != nil {
		fields = append(fields, team.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	case team.FieldDeletedAt:
		return m.DeletedAt()
	case team.FieldSlug:
		return m.Slug()
	case team.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case team.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case team.FieldSlug:
		return m.OldSlug(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case team.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case team.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldUpdatedAt) {
		fields = append(fields, team.FieldUpdatedAt)
	}
	if m.FieldCleared(team.FieldDeletedAt) {
		fields = append(fields, team.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case team.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case team.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case team.FieldSlug:
		m.ResetSlug()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user_edges != nil {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.hiring_team != nil {
		edges = append(edges, team.EdgeHiringTeam)
	}
	if m.user_teams != nil {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.user_edges))
		for id := range m.user_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHiringTeam:
		ids := make([]ent.Value, 0, len(m.hiring_team))
		for id := range m.hiring_team {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUserTeams:
		ids := make([]ent.Value, 0, len(m.user_teams))
		for id := range m.user_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_edges != nil {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.removedhiring_team != nil {
		edges = append(edges, team.EdgeHiringTeam)
	}
	if m.removeduser_teams != nil {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUserEdges:
		ids := make([]ent.Value, 0, len(m.removeduser_edges))
		for id := range m.removeduser_edges {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHiringTeam:
		ids := make([]ent.Value, 0, len(m.removedhiring_team))
		for id := range m.removedhiring_team {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeUserTeams:
		ids := make([]ent.Value, 0, len(m.removeduser_teams))
		for id := range m.removeduser_teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser_edges {
		edges = append(edges, team.EdgeUserEdges)
	}
	if m.clearedhiring_team {
		edges = append(edges, team.EdgeHiringTeam)
	}
	if m.cleareduser_teams {
		edges = append(edges, team.EdgeUserTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeUserEdges:
		return m.cleareduser_edges
	case team.EdgeHiringTeam:
		return m.clearedhiring_team
	case team.EdgeUserTeams:
		return m.cleareduser_teams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeUserEdges:
		m.ResetUserEdges()
		return nil
	case team.EdgeHiringTeam:
		m.ResetHiringTeam()
		return nil
	case team.EdgeUserTeams:
		m.ResetUserTeams()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamManagerMutation represents an operation that mutates the TeamManager nodes in the graph.
type TeamManagerMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	user_edge        *uuid.UUID
	cleareduser_edge bool
	team_edge        *uuid.UUID
	clearedteam_edge bool
	done             bool
	oldValue         func(context.Context) (*TeamManager, error)
	predicates       []predicate.TeamManager
}

var _ ent.Mutation = (*TeamManagerMutation)(nil)

// teammanagerOption allows management of the mutation configuration using functional options.
type teammanagerOption func(*TeamManagerMutation)

// newTeamManagerMutation creates new mutation for the TeamManager entity.
func newTeamManagerMutation(c config, op Op, opts ...teammanagerOption) *TeamManagerMutation {
	m := &TeamManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamManagerID sets the ID field of the mutation.
func withTeamManagerID(id uuid.UUID) teammanagerOption {
	return func(m *TeamManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamManager
		)
		m.oldValue = func(ctx context.Context) (*TeamManager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamManager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamManager sets the old TeamManager of the mutation.
func withTeamManager(node *TeamManager) teammanagerOption {
	return func(m *TeamManagerMutation) {
		m.oldValue = func(context.Context) (*TeamManager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamManager entities.
func (m *TeamManagerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamManagerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamManagerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamManager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamManagerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamManagerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[teammanager.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamManagerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[teammanager.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, teammanager.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TeamManagerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TeamManagerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TeamManagerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[teammanager.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TeamManagerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[teammanager.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TeamManagerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, teammanager.FieldDeletedAt)
}

// SetTeamID sets the "team_id" field.
func (m *TeamManagerMutation) SetTeamID(u uuid.UUID) {
	m.team_edge = &u
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TeamManagerMutation) TeamID() (r uuid.UUID, exists bool) {
	v := m.team_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldTeamID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TeamManagerMutation) ResetTeamID() {
	m.team_edge = nil
}

// SetUserID sets the "user_id" field.
func (m *TeamManagerMutation) SetUserID(u uuid.UUID) {
	m.user_edge = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TeamManagerMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_edge
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TeamManager entity.
// If the TeamManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamManagerMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TeamManagerMutation) ResetUserID() {
	m.user_edge = nil
}

// SetUserEdgeID sets the "user_edge" edge to the User entity by id.
func (m *TeamManagerMutation) SetUserEdgeID(id uuid.UUID) {
	m.user_edge = &id
}

// ClearUserEdge clears the "user_edge" edge to the User entity.
func (m *TeamManagerMutation) ClearUserEdge() {
	m.cleareduser_edge = true
}

// UserEdgeCleared reports if the "user_edge" edge to the User entity was cleared.
func (m *TeamManagerMutation) UserEdgeCleared() bool {
	return m.cleareduser_edge
}

// UserEdgeID returns the "user_edge" edge ID in the mutation.
func (m *TeamManagerMutation) UserEdgeID() (id uuid.UUID, exists bool) {
	if m.user_edge != nil {
		return *m.user_edge, true
	}
	return
}

// UserEdgeIDs returns the "user_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserEdgeID instead. It exists only for internal usage by the builders.
func (m *TeamManagerMutation) UserEdgeIDs() (ids []uuid.UUID) {
	if id := m.user_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserEdge resets all changes to the "user_edge" edge.
func (m *TeamManagerMutation) ResetUserEdge() {
	m.user_edge = nil
	m.cleareduser_edge = false
}

// SetTeamEdgeID sets the "team_edge" edge to the Team entity by id.
func (m *TeamManagerMutation) SetTeamEdgeID(id uuid.UUID) {
	m.team_edge = &id
}

// ClearTeamEdge clears the "team_edge" edge to the Team entity.
func (m *TeamManagerMutation) ClearTeamEdge() {
	m.clearedteam_edge = true
}

// TeamEdgeCleared reports if the "team_edge" edge to the Team entity was cleared.
func (m *TeamManagerMutation) TeamEdgeCleared() bool {
	return m.clearedteam_edge
}

// TeamEdgeID returns the "team_edge" edge ID in the mutation.
func (m *TeamManagerMutation) TeamEdgeID() (id uuid.UUID, exists bool) {
	if m.team_edge != nil {
		return *m.team_edge, true
	}
	return
}

// TeamEdgeIDs returns the "team_edge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamEdgeID instead. It exists only for internal usage by the builders.
func (m *TeamManagerMutation) TeamEdgeIDs() (ids []uuid.UUID) {
	if id := m.team_edge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamEdge resets all changes to the "team_edge" edge.
func (m *TeamManagerMutation) ResetTeamEdge() {
	m.team_edge = nil
	m.clearedteam_edge = false
}

// Where appends a list predicates to the TeamManagerMutation builder.
func (m *TeamManagerMutation) Where(ps ...predicate.TeamManager) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamManagerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TeamManager).
func (m *TeamManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamManagerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, teammanager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teammanager.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, teammanager.FieldDeletedAt)
	}
	if m.team_edge != nil {
		fields = append(fields, teammanager.FieldTeamID)
	}
	if m.user_edge != nil {
		fields = append(fields, teammanager.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammanager.FieldCreatedAt:
		return m.CreatedAt()
	case teammanager.FieldUpdatedAt:
		return m.UpdatedAt()
	case teammanager.FieldDeletedAt:
		return m.DeletedAt()
	case teammanager.FieldTeamID:
		return m.TeamID()
	case teammanager.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammanager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teammanager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case teammanager.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case teammanager.FieldTeamID:
		return m.OldTeamID(ctx)
	case teammanager.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown TeamManager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammanager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teammanager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case teammanager.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case teammanager.FieldTeamID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case teammanager.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown TeamManager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamManagerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamManagerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamManager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teammanager.FieldUpdatedAt) {
		fields = append(fields, teammanager.FieldUpdatedAt)
	}
	if m.FieldCleared(teammanager.FieldDeletedAt) {
		fields = append(fields, teammanager.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamManagerMutation) ClearField(name string) error {
	switch name {
	case teammanager.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case teammanager.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamManager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamManagerMutation) ResetField(name string) error {
	switch name {
	case teammanager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teammanager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case teammanager.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case teammanager.FieldTeamID:
		m.ResetTeamID()
		return nil
	case teammanager.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown TeamManager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_edge != nil {
		edges = append(edges, teammanager.EdgeUserEdge)
	}
	if m.team_edge != nil {
		edges = append(edges, teammanager.EdgeTeamEdge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamManagerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammanager.EdgeUserEdge:
		if id := m.user_edge; id != nil {
			return []ent.Value{*id}
		}
	case teammanager.EdgeTeamEdge:
		if id := m.team_edge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_edge {
		edges = append(edges, teammanager.EdgeUserEdge)
	}
	if m.clearedteam_edge {
		edges = append(edges, teammanager.EdgeTeamEdge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamManagerMutation) EdgeCleared(name string) bool {
	switch name {
	case teammanager.EdgeUserEdge:
		return m.cleareduser_edge
	case teammanager.EdgeTeamEdge:
		return m.clearedteam_edge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamManagerMutation) ClearEdge(name string) error {
	switch name {
	case teammanager.EdgeUserEdge:
		m.ClearUserEdge()
		return nil
	case teammanager.EdgeTeamEdge:
		m.ClearTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown TeamManager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamManagerMutation) ResetEdge(name string) error {
	switch name {
	case teammanager.EdgeUserEdge:
		m.ResetUserEdge()
		return nil
	case teammanager.EdgeTeamEdge:
		m.ResetTeamEdge()
		return nil
	}
	return fmt.Errorf("unknown TeamManager edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	name                *string
	work_email          *string
	oid                 *string
	clearedFields       map[string]struct{}
	audit_edge          map[uuid.UUID]struct{}
	removedaudit_edge   map[uuid.UUID]struct{}
	clearedaudit_edge   bool
	hiring_owner        map[uuid.UUID]struct{}
	removedhiring_owner map[uuid.UUID]struct{}
	clearedhiring_owner bool
	team_edges          map[uuid.UUID]struct{}
	removedteam_edges   map[uuid.UUID]struct{}
	clearedteam_edges   bool
	team_users          map[uuid.UUID]struct{}
	removedteam_users   map[uuid.UUID]struct{}
	clearedteam_users   bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetWorkEmail sets the "work_email" field.
func (m *UserMutation) SetWorkEmail(s string) {
	m.work_email = &s
}

// WorkEmail returns the value of the "work_email" field in the mutation.
func (m *UserMutation) WorkEmail() (r string, exists bool) {
	v := m.work_email
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEmail returns the old "work_email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWorkEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEmail: %w", err)
	}
	return oldValue.WorkEmail, nil
}

// ResetWorkEmail resets all changes to the "work_email" field.
func (m *UserMutation) ResetWorkEmail() {
	m.work_email = nil
}

// SetOid sets the "oid" field.
func (m *UserMutation) SetOid(s string) {
	m.oid = &s
}

// Oid returns the value of the "oid" field in the mutation.
func (m *UserMutation) Oid() (r string, exists bool) {
	v := m.oid
	if v == nil {
		return
	}
	return *v, true
}

// OldOid returns the old "oid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOid: %w", err)
	}
	return oldValue.Oid, nil
}

// ResetOid resets all changes to the "oid" field.
func (m *UserMutation) ResetOid() {
	m.oid = nil
}

// AddAuditEdgeIDs adds the "audit_edge" edge to the AuditTrail entity by ids.
func (m *UserMutation) AddAuditEdgeIDs(ids ...uuid.UUID) {
	if m.audit_edge == nil {
		m.audit_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.audit_edge[ids[i]] = struct{}{}
	}
}

// ClearAuditEdge clears the "audit_edge" edge to the AuditTrail entity.
func (m *UserMutation) ClearAuditEdge() {
	m.clearedaudit_edge = true
}

// AuditEdgeCleared reports if the "audit_edge" edge to the AuditTrail entity was cleared.
func (m *UserMutation) AuditEdgeCleared() bool {
	return m.clearedaudit_edge
}

// RemoveAuditEdgeIDs removes the "audit_edge" edge to the AuditTrail entity by IDs.
func (m *UserMutation) RemoveAuditEdgeIDs(ids ...uuid.UUID) {
	if m.removedaudit_edge == nil {
		m.removedaudit_edge = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.audit_edge, ids[i])
		m.removedaudit_edge[ids[i]] = struct{}{}
	}
}

// RemovedAuditEdge returns the removed IDs of the "audit_edge" edge to the AuditTrail entity.
func (m *UserMutation) RemovedAuditEdgeIDs() (ids []uuid.UUID) {
	for id := range m.removedaudit_edge {
		ids = append(ids, id)
	}
	return
}

// AuditEdgeIDs returns the "audit_edge" edge IDs in the mutation.
func (m *UserMutation) AuditEdgeIDs() (ids []uuid.UUID) {
	for id := range m.audit_edge {
		ids = append(ids, id)
	}
	return
}

// ResetAuditEdge resets all changes to the "audit_edge" edge.
func (m *UserMutation) ResetAuditEdge() {
	m.audit_edge = nil
	m.clearedaudit_edge = false
	m.removedaudit_edge = nil
}

// AddHiringOwnerIDs adds the "hiring_owner" edge to the HiringJob entity by ids.
func (m *UserMutation) AddHiringOwnerIDs(ids ...uuid.UUID) {
	if m.hiring_owner == nil {
		m.hiring_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hiring_owner[ids[i]] = struct{}{}
	}
}

// ClearHiringOwner clears the "hiring_owner" edge to the HiringJob entity.
func (m *UserMutation) ClearHiringOwner() {
	m.clearedhiring_owner = true
}

// HiringOwnerCleared reports if the "hiring_owner" edge to the HiringJob entity was cleared.
func (m *UserMutation) HiringOwnerCleared() bool {
	return m.clearedhiring_owner
}

// RemoveHiringOwnerIDs removes the "hiring_owner" edge to the HiringJob entity by IDs.
func (m *UserMutation) RemoveHiringOwnerIDs(ids ...uuid.UUID) {
	if m.removedhiring_owner == nil {
		m.removedhiring_owner = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hiring_owner, ids[i])
		m.removedhiring_owner[ids[i]] = struct{}{}
	}
}

// RemovedHiringOwner returns the removed IDs of the "hiring_owner" edge to the HiringJob entity.
func (m *UserMutation) RemovedHiringOwnerIDs() (ids []uuid.UUID) {
	for id := range m.removedhiring_owner {
		ids = append(ids, id)
	}
	return
}

// HiringOwnerIDs returns the "hiring_owner" edge IDs in the mutation.
func (m *UserMutation) HiringOwnerIDs() (ids []uuid.UUID) {
	for id := range m.hiring_owner {
		ids = append(ids, id)
	}
	return
}

// ResetHiringOwner resets all changes to the "hiring_owner" edge.
func (m *UserMutation) ResetHiringOwner() {
	m.hiring_owner = nil
	m.clearedhiring_owner = false
	m.removedhiring_owner = nil
}

// AddTeamEdgeIDs adds the "team_edges" edge to the Team entity by ids.
func (m *UserMutation) AddTeamEdgeIDs(ids ...uuid.UUID) {
	if m.team_edges == nil {
		m.team_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_edges[ids[i]] = struct{}{}
	}
}

// ClearTeamEdges clears the "team_edges" edge to the Team entity.
func (m *UserMutation) ClearTeamEdges() {
	m.clearedteam_edges = true
}

// TeamEdgesCleared reports if the "team_edges" edge to the Team entity was cleared.
func (m *UserMutation) TeamEdgesCleared() bool {
	return m.clearedteam_edges
}

// RemoveTeamEdgeIDs removes the "team_edges" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamEdgeIDs(ids ...uuid.UUID) {
	if m.removedteam_edges == nil {
		m.removedteam_edges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_edges, ids[i])
		m.removedteam_edges[ids[i]] = struct{}{}
	}
}

// RemovedTeamEdges returns the removed IDs of the "team_edges" edge to the Team entity.
func (m *UserMutation) RemovedTeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_edges {
		ids = append(ids, id)
	}
	return
}

// TeamEdgesIDs returns the "team_edges" edge IDs in the mutation.
func (m *UserMutation) TeamEdgesIDs() (ids []uuid.UUID) {
	for id := range m.team_edges {
		ids = append(ids, id)
	}
	return
}

// ResetTeamEdges resets all changes to the "team_edges" edge.
func (m *UserMutation) ResetTeamEdges() {
	m.team_edges = nil
	m.clearedteam_edges = false
	m.removedteam_edges = nil
}

// AddTeamUserIDs adds the "team_users" edge to the TeamManager entity by ids.
func (m *UserMutation) AddTeamUserIDs(ids ...uuid.UUID) {
	if m.team_users == nil {
		m.team_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.team_users[ids[i]] = struct{}{}
	}
}

// ClearTeamUsers clears the "team_users" edge to the TeamManager entity.
func (m *UserMutation) ClearTeamUsers() {
	m.clearedteam_users = true
}

// TeamUsersCleared reports if the "team_users" edge to the TeamManager entity was cleared.
func (m *UserMutation) TeamUsersCleared() bool {
	return m.clearedteam_users
}

// RemoveTeamUserIDs removes the "team_users" edge to the TeamManager entity by IDs.
func (m *UserMutation) RemoveTeamUserIDs(ids ...uuid.UUID) {
	if m.removedteam_users == nil {
		m.removedteam_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.team_users, ids[i])
		m.removedteam_users[ids[i]] = struct{}{}
	}
}

// RemovedTeamUsers returns the removed IDs of the "team_users" edge to the TeamManager entity.
func (m *UserMutation) RemovedTeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedteam_users {
		ids = append(ids, id)
	}
	return
}

// TeamUsersIDs returns the "team_users" edge IDs in the mutation.
func (m *UserMutation) TeamUsersIDs() (ids []uuid.UUID) {
	for id := range m.team_users {
		ids = append(ids, id)
	}
	return
}

// ResetTeamUsers resets all changes to the "team_users" edge.
func (m *UserMutation) ResetTeamUsers() {
	m.team_users = nil
	m.clearedteam_users = false
	m.removedteam_users = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.work_email != nil {
		fields = append(fields, user.FieldWorkEmail)
	}
	if m.oid != nil {
		fields = append(fields, user.FieldOid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldWorkEmail:
		return m.WorkEmail()
	case user.FieldOid:
		return m.Oid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldWorkEmail:
		return m.OldWorkEmail(ctx)
	case user.FieldOid:
		return m.OldOid(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldWorkEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEmail(v)
		return nil
	case user.FieldOid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOid(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldWorkEmail:
		m.ResetWorkEmail()
		return nil
	case user.FieldOid:
		m.ResetOid()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.audit_edge != nil {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.hiring_owner != nil {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.team_edges != nil {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.team_users != nil {
		edges = append(edges, user.EdgeTeamUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuditEdge:
		ids := make([]ent.Value, 0, len(m.audit_edge))
		for id := range m.audit_edge {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringOwner:
		ids := make([]ent.Value, 0, len(m.hiring_owner))
		for id := range m.hiring_owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamEdges:
		ids := make([]ent.Value, 0, len(m.team_edges))
		for id := range m.team_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamUsers:
		ids := make([]ent.Value, 0, len(m.team_users))
		for id := range m.team_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaudit_edge != nil {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.removedhiring_owner != nil {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.removedteam_edges != nil {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.removedteam_users != nil {
		edges = append(edges, user.EdgeTeamUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuditEdge:
		ids := make([]ent.Value, 0, len(m.removedaudit_edge))
		for id := range m.removedaudit_edge {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHiringOwner:
		ids := make([]ent.Value, 0, len(m.removedhiring_owner))
		for id := range m.removedhiring_owner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamEdges:
		ids := make([]ent.Value, 0, len(m.removedteam_edges))
		for id := range m.removedteam_edges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamUsers:
		ids := make([]ent.Value, 0, len(m.removedteam_users))
		for id := range m.removedteam_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaudit_edge {
		edges = append(edges, user.EdgeAuditEdge)
	}
	if m.clearedhiring_owner {
		edges = append(edges, user.EdgeHiringOwner)
	}
	if m.clearedteam_edges {
		edges = append(edges, user.EdgeTeamEdges)
	}
	if m.clearedteam_users {
		edges = append(edges, user.EdgeTeamUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAuditEdge:
		return m.clearedaudit_edge
	case user.EdgeHiringOwner:
		return m.clearedhiring_owner
	case user.EdgeTeamEdges:
		return m.clearedteam_edges
	case user.EdgeTeamUsers:
		return m.clearedteam_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAuditEdge:
		m.ResetAuditEdge()
		return nil
	case user.EdgeHiringOwner:
		m.ResetHiringOwner()
		return nil
	case user.EdgeTeamEdges:
		m.ResetTeamEdges()
		return nil
	case user.EdgeTeamUsers:
		m.ResetTeamUsers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
