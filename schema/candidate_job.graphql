enum CandidateJobStatusEnded {
  hired
  kiv
  offer_lost
  ex_staff
}

enum CandidateJobStatusOpen {
  applied
  interviewing
  offering
}
enum CandidateJobStatusAbleToClose {
  interviewing
  offering
}

enum CandidateJobStatusFailed {
  offer_lost
  kiv
}

enum CandidateJobStatus {
  hired
  kiv
  offer_lost
  ex_staff
  applied
  interviewing
  offering
  new
}

enum CandidateJobOrderField {
  created_at
  updated_at
}

enum CandidateJobOrderByField {
  created_at
  updated_at
  priority
  hiring_job_created_at
}

enum CandidateJobFailedReason {
  poor_professionalism
  poor_fit_and_engagement
  over_expectations
  over_qualification
  language_deficiency
  weak_technical_skills
  poor_interpersonal_skills
  poor_problem_solving_skills
  poor_management_skills
  candidate_withdrawal
  others
}

enum CandidateJobOrderByAdditionalField {
  priority
  hiring_job_created_at
}

input CandidateJobGroupByStatusFilter {
  hiring_job_id: [ID!]
  hiring_team_id: [ID!]
  priority: [Int!]
  skill_id: [ID!]
  from_date: Time
  to_date: Time
  location: [LocationEnum!]
  created_by_ids: [ID!]
}

input CandidateJobGroupByStatusFreeWord {
  job_title: String
}

type CandidateJob {
  id: ID!
  candidate_id: ID!
  hiring_job_id: ID!
  status: CandidateJobStatus!
  attachments: [Attachment!]
  candidate: Candidate
  hiring_job: HiringJob
  owner: User
  failed_reason: [CandidateJobFailedReason!]
  is_able_to_delete: Boolean!
  interview_feature: Int!
  steps: [CandidateJobStep!]
  onboard_date: Time
  offer_expiration_date: Time
  created_at: Time!
  updated_at: Time!
}

type CandidateJobGroupInterviewFeedback {
  interview: [CandidateInterview!]
  feedback: [CandidateJobFeedback!]
}

type CandidateJobGroupByInterview {
  hired: CandidateJobGroupInterviewFeedback
  kiv: CandidateJobGroupInterviewFeedback
  offer_lost: CandidateJobGroupInterviewFeedback
  ex_staff: CandidateJobGroupInterviewFeedback
  applied: CandidateJobGroupInterviewFeedback
  interviewing: CandidateJobGroupInterviewFeedback
  offering: CandidateJobGroupInterviewFeedback
}

type CandidateJobGroupByStatus {
  hired: [CandidateJob!]
  kiv: [CandidateJob!]
  offer_lost: [CandidateJob!]
  ex_staff: [CandidateJob!]
  applied: [CandidateJob!]
  interviewing: [CandidateJob!]
  offering: [CandidateJob!]
}

input NewCandidateJobInput {
  candidate_id: ID!
  hiring_job_id: ID!
  status: CandidateJobStatusOpen!
  attachments: [NewAttachmentInput!]
  onboard_date: Time
  offer_expiration_date: Time
  failed_reason: [CandidateJobFailedReason!]
}

input UpdateCandidateAttachment {
  attachments: [NewAttachmentInput!]
}

input UpdateCandidateJobStatus {
  status: CandidateJobStatus!
  onboard_date: Time
  offer_expiration_date: Time
  failed_reason: [CandidateJobFailedReason!]
}

type CandidateJobResponse {
  data: CandidateJob
}

type CandidateJobGroupByStatusResponse {
  data: CandidateJobGroupByStatus
  pagination: Pagination!
}

type CandidateJobGroupByInterviewResponse {
  data: CandidateJobGroupByInterview
}

type CandidateJobEdge {
  node: CandidateJob!
  cursor: Cursor!
}

type CandidateJobResponseGetAll {
  edges: [CandidateJobEdge!]!
  pagination: Pagination!
}

input CandidateJobFilter {
  status: CandidateJobStatus
  from_date: Time
  to_date: Time
  hiring_team_id: ID
  hiring_job_id: ID
  candidate_id: ID
  failed_reason: [CandidateJobFailedReason!]
}

input CandidateJobOrder {
  direction: OrderDirection!
  field: CandidateJobOrderField!
}

input CandidateJobByOrder {
  direction: OrderDirection!
  field: CandidateJobOrderByField!
}

input CandidateJobFreeWord {
  team: String
  hiring_job: String
}
